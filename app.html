<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Laboratorio Virtual de Hemostasia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <main class="main-container" id="main-content" role="main">

      <!-- Layout principal de tres columnas -->
      <div class="simulator-layout">
        <!-- Columna izquierda: Condiciones Clínicas -->
        <aside class="conditions-sidebar" role="complementary" aria-label="Condiciones clínicas">
          <div class="panel-card" role="region">
            <h2 class="conditions-title">
              <svg class="conditions-title-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="9" y1="15" x2="15" y2="15"></line>
                <line x1="12" y1="12" x2="12" y2="18"></line>
              </svg>
              Condición Clínica
            </h2>
            <div class="condition-grid" role="radiogroup">
            <button 
              class="condition-btn" 
              data-condition="normal"
              role="radio"
              aria-checked="false"
              aria-describedby="normal-desc"
            >
              <div class="condition-name">Normal</div>
              <div class="condition-desc" id="normal-desc">
                Coagulación fisiológica normal - Todos los factores funcionan
                correctamente
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="hemophilia"
              role="radio"
              aria-checked="false"
              aria-describedby="hemophilia-desc"
            >
              <div class="condition-name">Hemofilia A/B</div>
              <div class="condition-desc" id="hemophilia-desc">
                Déficit Factor VIII/IX - Las plaquetas se adhieren pero la
                fibrina se forma muy lentamente y es inestable
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="vwd"
              role="radio"
              aria-checked="false"
              aria-describedby="vwd-desc"
            >
              <div class="condition-name">von Willebrand</div>
              <div class="condition-desc" id="vwd-desc">
                Déficit Factor vWF - Las plaquetas tienen dificultad para
                adherirse a la herida
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="factorDeficiency"
              role="radio"
              aria-checked="false"
              aria-describedby="factorDeficiency-desc"
            >
              <div class="condition-name">Déficit de otros factores</div>
              <div class="condition-desc" id="factorDeficiency-desc">
                Déficit de factores de coagulación - Formación de fibrina reducida
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="thrombocytopenia"
              role="radio"
              aria-checked="false"
              aria-describedby="thrombocytopenia-desc"
            >
              <div class="condition-name">Plaquetopenia</div>
              <div class="condition-desc" id="thrombocytopenia-desc">
                Recuento bajo de plaquetas - Pocas plaquetas disponibles para
                formar el coágulo
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="thrombasthenia"
              role="radio"
              aria-checked="false"
              aria-describedby="thrombasthenia-desc"
            >
              <div class="condition-name">Plaquetopatía</div>
              <div class="condition-desc" id="thrombasthenia-desc">
                Déficit glicoproteína IIb/IIIa - Las plaquetas se adhieren pero
                no se agregan entre sí
              </div>
            </button>
          </div>
        </div>
        </aside>

        <!-- Columna central: Simulador -->
        <section class="viewer-section">
          
          <div class="viewer-container">
            <!-- Contador de FPS -->
            <div class="fps-counter" id="fps-counter">FPS: --</div>
            
            <!-- Leyenda dentro del visor -->
          <div class="legend">
            <div class="legend-item tooltip-container">
              <div class="legend-dot platelet"></div>
              <span class="tooltip-trigger">Plaquetas</span>
              <div class="tooltip">
                Células sanguíneas pequeñas que se adhieren a la herida y forman
                el tapón inicial. Se activan al contacto con el colágeno expuesto.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot rbc"></div>
              <span class="tooltip-trigger">Glóbulos Rojos</span>
              <div class="tooltip">
                Eritrocitos que transportan oxígeno. No participan directamente en
                la coagulación pero pueden quedar atrapados en el coágulo.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot wbc"></div>
              <span class="tooltip-trigger">Glóbulos Blancos</span>
              <div class="tooltip">
                Leucocitos que participan en la respuesta inmune. Pueden ayudar en
                la limpieza de la herida.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot fibrin"></div>
              <span class="tooltip-trigger">Red de Fibrina</span>
              <div class="tooltip">
                Proteína formada a partir del fibrinógeno por acción de la
                trombina. Crea una malla que refuerza el tapón plaquetario.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot vwf"></div>
              <span class="tooltip-trigger">Factor von Willebrand</span>
              <div class="tooltip">
                Proteína que media la adhesión de las plaquetas al colágeno
                expuesto. Esencial para el inicio de la hemostasia.
              </div>
            </div>
          </div>
          
            <div class="viewer-labels">
              <div class="label label-wound hidden" id="wound-label" role="status" aria-live="polite">
                Lesión Activa
              </div>
            </div>
            <div class="treatment-indicator" id="treatment-indicator" role="status" aria-live="assertive" aria-atomic="true">
              Tratamiento Administrado
            </div>


            <canvas 
              id="simulation-canvas"
            ></canvas>

            <!-- Métricas dentro del simulador (lado derecho) -->
            <div class="viewer-metrics">
              <div class="metric-box">
                <div class="metric-value blood-loss" id="blood-loss">0</div>
                <div class="metric-label">Pérdida Sanguínea</div>
              </div>
              <div class="metric-box">
                <div class="metric-value clot-progress" id="clot-percentage">
                  0%
                </div>
                <div class="metric-label">Cierre de la Herida</div>
              </div>
            </div>
          </div>

          <!-- Contenedor de botones de control -->
          <div class="simulation-controls-row">
            <button 
              class="start-btn control-btn-large" 
              id="start-btn"
              aria-label="Iniciar la simulación"
              title="Iniciar simulación (Alt+S)"
            >
              <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
              </svg>
              Iniciar Simulación
            </button>
            <button 
              class="pause-btn control-btn-small" 
              id="pause-btn"
              aria-label="Pausar la simulación"
              title="Pausar simulación"
              disabled
            >
              <svg class="btn-icon pause-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
              </svg>
              Pausar
            </button>
            <button 
              class="reset-btn control-btn-small" 
              id="reset-btn"
              aria-label="Reiniciar la simulación"
              title="Reiniciar simulación (Alt+R)"
            >
              <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
              </svg>
              Reiniciar
            </button>
            <div class="speed-control control-speed">
              <label>
                <svg class="speed-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                </svg>
                Velocidad:
              </label>
              <input
                type="range"
                class="speed-slider"
                id="speed-slider"
                min="0.25"
                max="2"
                step="0.25"
                value="1"
              />
              <span id="speed-value">1x</span>
            </div>
            <button 
              class="treatment-btn control-btn-large" 
              id="treatment-btn"
              aria-label="Administrar tratamiento médico"
              title="Aplicar tratamiento (Alt+T)"
            >
              Administrar Tratamiento
            </button>
          </div>


        </section>

      </div>
    </main>


    <script>
      // Matter.js modules
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Body,
        Composite,
        Constraint,
        Events,
        Vector,
      } = Matter;



      // Actualizar estados ARIA de condiciones
      function updateConditionARIA() {
        document.querySelectorAll('.condition-btn').forEach(btn => {
          const isActive = btn.classList.contains('active');
          btn.setAttribute('aria-checked', isActive);
        });
      }



      // Simulation Configuration - Tamaños base (referencia)
      const BASE_CONFIG = {
        canvas: {
          width: 1300,
          height: 300,
        },
        wound: {
          width: 450,
          height: 35,
        },
        wall: {
          thickness: 30,
          color: "#FDA4AF",
        },
        particles: {
          plateletRadius: 4,
          rbcRadius: 6,
          wbcRadius: 10,
        },
      };
      
      // Factor de escala global (se actualiza dinámicamente)
      let scaleFactor = 1.0;
      
      // Valores base para UI (referencia para escala)
      const BASE_UI = {
        fps: {
          fontSize: 0.875, // rem
          padding: { top: 6, right: 12, bottom: 6, left: 12 }, // px
          top: 16, // px
          left: 16, // px
          borderRadius: 8, // px
        },
        legend: {
          fontSize: 0.875, // rem - aumentado para mejor visibilidad
          padding: { top: 14, right: 10, bottom: 14, left: 10 }, // px
          gap: 10, // px
          top: 16, // px
          borderRadius: 12, // px
          maxWidth: 1000, // px
        },
        legendItem: {
          fontSize: 0.75, // rem
          padding: { top: 4, right: 16, bottom: 4, left: 16 }, // px
          gap: 10, // px
          borderRadius: 6, // px
        },
        legendDot: {
          platelet: { width: 12, height: 12 },
          rbc: { width: 14, height: 10 },
          wbc: { width: 20, height: 20 },
          fibrin: { width: 24, height: 3 },
          vwf: { width: 20, height: 2 },
        },
        woundLabel: {
          fontSize: 0.875, // rem
          padding: { top: 8, right: 16, bottom: 8, left: 16 }, // px
          top: 12, // px
          right: 17, // px
          borderRadius: 6, // px
        },
        metrics: {
          fontSize: { value: 1.75, label: 0.75 }, // rem
          padding: { top: 10, right: 14, bottom: 10, left: 14 }, // px
          gap: 16, // px
          bottom: 16, // px
          borderRadius: 8, // px
          minWidth: 110, // px
          marginBottom: 5, // px
        },
        sidebar: {
          width: 380, // px
          padding: 16, // px
        },
        conditionBtn: {
          padding: 12, // px
          minHeight: 80, // px
          borderRadius: 8, // px
          fontSize: { name: 0.9, desc: 0.75 }, // rem
          marginBottom: 4, // px
        },
        controlBtn: {
          large: {
            height: 48, // px
            padding: { top: 12, right: 24, bottom: 12, left: 24 }, // px
            minWidth: { start: 200, treatment: 300 }, // px
            fontSize: 1.0, // rem
          },
          small: {
            height: 48, // px
            padding: { top: 12, right: 16, bottom: 12, left: 16 }, // px
            minWidth: 120, // px
            fontSize: 1.0, // rem
          },
        },
        panelTitle: {
          fontSize: 0.7, // rem
          marginBottom: 10, // px
          gap: 6, // px
          iconSize: 16, // px
        },
        btnIcon: {
          size: 18, // px
        },
        speedControl: {
          height: 48, // px
          padding: { top: 0, right: 12, bottom: 0, left: 12 }, // px
          gap: 8, // px
          borderRadius: 8, // px
          fontSize: { label: 0.75, value: 0.75 }, // rem
          sliderWidth: 100, // px
          valueMinWidth: 30, // px
          iconSize: 18, // px (aproximado, basado en btn-icon)
        },
      };
      
      // Función simplificada para actualizar escalado de UI usando CSS
      function updateUIScaling(scale) {
        // Solo actualizar la variable CSS, el resto lo maneja CSS automáticamente
        document.documentElement.style.setProperty('--ui-scale', scale);
      }
      
      // Función antigua (mantenida por compatibilidad pero no se usa)
      function updateUIScalingOld(scale) {
        // FPS Counter
        const fpsEl = document.getElementById('fps-counter');
        if (fpsEl) {
          fpsEl.style.fontSize = `${BASE_UI.fps.fontSize * scale}rem`;
          fpsEl.style.padding = `${BASE_UI.fps.padding.top * scale}px ${BASE_UI.fps.padding.right * scale}px ${BASE_UI.fps.padding.bottom * scale}px ${BASE_UI.fps.padding.left * scale}px`;
          fpsEl.style.top = `${BASE_UI.fps.top * scale}px`;
          fpsEl.style.left = `${BASE_UI.fps.left * scale}px`;
          fpsEl.style.borderRadius = `${BASE_UI.fps.borderRadius * scale}px`;
        }
        
        // Leyenda
        const legendEl = document.querySelector('.legend');
        if (legendEl) {
          legendEl.style.fontSize = `${BASE_UI.legend.fontSize * scale}rem`;
          legendEl.style.padding = `${BASE_UI.legend.padding.top * scale}px ${BASE_UI.legend.padding.right * scale}px ${BASE_UI.legend.padding.bottom * scale}px ${BASE_UI.legend.padding.left * scale}px`;
          legendEl.style.gap = `${BASE_UI.legend.gap * scale}px`;
          legendEl.style.top = `${BASE_UI.legend.top * scale}px`;
          legendEl.style.borderRadius = `${BASE_UI.legend.borderRadius * scale}px`;
          legendEl.style.maxWidth = `${BASE_UI.legend.maxWidth * scale}px`;
        }
        
        // Elementos de la leyenda (texto "Plaquetas", "Glóbulos Rojos", etc.)
        const legendItems = document.querySelectorAll('.legend-item');
        legendItems.forEach(item => {
          item.style.fontSize = `${BASE_UI.legendItem.fontSize * scale}rem`;
          item.style.padding = `${BASE_UI.legendItem.padding.top * scale}px ${BASE_UI.legendItem.padding.right * scale}px ${BASE_UI.legendItem.padding.bottom * scale}px ${BASE_UI.legendItem.padding.left * scale}px`;
          item.style.gap = `${BASE_UI.legendItem.gap * scale}px`;
          item.style.borderRadius = `${BASE_UI.legendItem.borderRadius * scale}px`;
        });
        
        // Dots de la leyenda
        const legendDots = {
          '.legend-dot.platelet': BASE_UI.legendDot.platelet,
          '.legend-dot.rbc': BASE_UI.legendDot.rbc,
          '.legend-dot.wbc': BASE_UI.legendDot.wbc,
          '.legend-dot.fibrin': BASE_UI.legendDot.fibrin,
          '.legend-dot.vwf': BASE_UI.legendDot.vwf,
        };
        Object.keys(legendDots).forEach(selector => {
          const dots = document.querySelectorAll(selector);
          dots.forEach(dot => {
            const size = legendDots[selector];
            dot.style.width = `${size.width * scale}px`;
            dot.style.height = `${size.height * scale}px`;
          });
        });
        
        // Lesión Activa
        const woundLabelEl = document.getElementById('wound-label');
        if (woundLabelEl) {
          woundLabelEl.style.fontSize = `${BASE_UI.woundLabel.fontSize * scale}rem`;
          woundLabelEl.style.padding = `${BASE_UI.woundLabel.padding.top * scale}px ${BASE_UI.woundLabel.padding.right * scale}px ${BASE_UI.woundLabel.padding.bottom * scale}px ${BASE_UI.woundLabel.padding.left * scale}px`;
          woundLabelEl.style.top = `${BASE_UI.woundLabel.top * scale}px`;
          woundLabelEl.style.right = `${BASE_UI.woundLabel.right * scale}px`;
          woundLabelEl.style.borderRadius = `${BASE_UI.woundLabel.borderRadius * scale}px`;
        }
        
        // Métricas
        const metricsEl = document.querySelector('.viewer-metrics');
        if (metricsEl) {
          metricsEl.style.gap = `${BASE_UI.metrics.gap * scale}px`;
          metricsEl.style.bottom = `${BASE_UI.metrics.bottom * scale}px`;
        }
        
        const metricBoxes = document.querySelectorAll('.metric-box');
        metricBoxes.forEach(box => {
          box.style.padding = `${BASE_UI.metrics.padding.top * scale}px ${BASE_UI.metrics.padding.right * scale}px ${BASE_UI.metrics.padding.bottom * scale}px ${BASE_UI.metrics.padding.left * scale}px`;
          box.style.borderRadius = `${BASE_UI.metrics.borderRadius * scale}px`;
          box.style.minWidth = `${BASE_UI.metrics.minWidth * scale}px`;
        });
        
        const metricValues = document.querySelectorAll('.metric-value');
        metricValues.forEach(value => {
          value.style.fontSize = `${BASE_UI.metrics.fontSize.value * scale}rem`;
          value.style.marginBottom = `${BASE_UI.metrics.marginBottom * scale}px`;
        });
        
        const metricLabels = document.querySelectorAll('.metric-label');
        metricLabels.forEach(label => {
          label.style.fontSize = `${BASE_UI.metrics.fontSize.label * scale}rem`;
        });
        
        // Panel lateral izquierdo
        const sidebarEl = document.querySelector('.conditions-sidebar');
        const sidebarWidth = BASE_UI.sidebar.width * scale;
        const sidebarGap = 16 * scale; // Gap entre sidebar y visor
        
        if (sidebarEl) {
          sidebarEl.style.width = `${sidebarWidth}px`;
        }
        
        const panelCardEl = document.querySelector('.conditions-sidebar .panel-card:first-child');
        if (panelCardEl) {
          panelCardEl.style.padding = `${BASE_UI.sidebar.padding * scale}px`;
        }
        
        // Ajustar el layout del visor para mantener proporciones con el sidebar
        const simulatorLayout = document.querySelector('.simulator-layout');
        if (simulatorLayout) {
          simulatorLayout.style.marginLeft = `${sidebarWidth}px`;
          simulatorLayout.style.width = `calc(100% - ${sidebarWidth}px - ${sidebarGap}px)`;
          simulatorLayout.style.maxWidth = `calc(100% - ${sidebarWidth}px - ${sidebarGap}px)`;
          simulatorLayout.style.paddingRight = `${sidebarGap}px`;
        }
        
        // Botones de condición
        const conditionBtns = document.querySelectorAll('.condition-btn');
        conditionBtns.forEach(btn => {
          btn.style.padding = `${BASE_UI.conditionBtn.padding * scale}px`;
          btn.style.minHeight = `${BASE_UI.conditionBtn.minHeight * scale}px`;
        });
        
        const conditionNames = document.querySelectorAll('.condition-name');
        conditionNames.forEach(name => {
          name.style.fontSize = `${BASE_UI.conditionBtn.fontSize.name * scale}rem`;
          name.style.marginBottom = `${BASE_UI.conditionBtn.marginBottom * scale}px`;
        });
        
        const conditionDescs = document.querySelectorAll('.condition-desc');
        conditionDescs.forEach(desc => {
          desc.style.fontSize = `${BASE_UI.conditionBtn.fontSize.desc * scale}rem`;
        });
        
        // Botones de control grandes
        const controlBtnsLarge = document.querySelectorAll('.control-btn-large');
        controlBtnsLarge.forEach(btn => {
          btn.style.height = `${BASE_UI.controlBtn.large.height * scale}px`;
          btn.style.padding = `${BASE_UI.controlBtn.large.padding.top * scale}px ${BASE_UI.controlBtn.large.padding.right * scale}px ${BASE_UI.controlBtn.large.padding.bottom * scale}px ${BASE_UI.controlBtn.large.padding.left * scale}px`;
          btn.style.fontSize = `${BASE_UI.controlBtn.large.fontSize * scale}rem`;
        });
        
        const startBtn = document.querySelector('.start-btn.control-btn-large');
        if (startBtn) {
          startBtn.style.minWidth = `${BASE_UI.controlBtn.large.minWidth.start * scale}px`;
        }
        
        const treatmentBtn = document.querySelector('.treatment-btn.control-btn-large');
        if (treatmentBtn) {
          treatmentBtn.style.width = `${BASE_UI.controlBtn.large.minWidth.treatment * scale}px`;
          treatmentBtn.style.minWidth = `${BASE_UI.controlBtn.large.minWidth.treatment * scale}px`;
        }
        
        // Botones de control pequeños
        const controlBtnsSmall = document.querySelectorAll('.control-btn-small');
        controlBtnsSmall.forEach(btn => {
          btn.style.height = `${BASE_UI.controlBtn.small.height * scale}px`;
          btn.style.padding = `${BASE_UI.controlBtn.small.padding.top * scale}px ${BASE_UI.controlBtn.small.padding.right * scale}px ${BASE_UI.controlBtn.small.padding.bottom * scale}px ${BASE_UI.controlBtn.small.padding.left * scale}px`;
          btn.style.minWidth = `${BASE_UI.controlBtn.small.minWidth * scale}px`;
          btn.style.fontSize = `${BASE_UI.controlBtn.small.fontSize * scale}rem`;
        });
        
        // Títulos de panel
        const panelTitles = document.querySelectorAll('.panel-title');
        panelTitles.forEach(title => {
          title.style.fontSize = `${BASE_UI.panelTitle.fontSize * scale}rem`;
          title.style.marginBottom = `${BASE_UI.panelTitle.marginBottom * scale}px`;
          title.style.gap = `${BASE_UI.panelTitle.gap * scale}px`;
        });
        
        const panelTitleIcons = document.querySelectorAll('.panel-title svg');
        panelTitleIcons.forEach(icon => {
          icon.style.width = `${BASE_UI.panelTitle.iconSize * scale}px`;
          icon.style.height = `${BASE_UI.panelTitle.iconSize * scale}px`;
        });
        
        // Iconos de los botones de control
        const btnIcons = document.querySelectorAll('.btn-icon');
        btnIcons.forEach(icon => {
          icon.style.width = `${BASE_UI.btnIcon.size * scale}px`;
          icon.style.height = `${BASE_UI.btnIcon.size * scale}px`;
        });
        
        // Barra de velocidad
        const speedControl = document.querySelector('.control-speed');
        if (speedControl) {
          speedControl.style.height = `${BASE_UI.speedControl.height * scale}px`;
          speedControl.style.padding = `${BASE_UI.speedControl.padding.top * scale}px ${BASE_UI.speedControl.padding.right * scale}px ${BASE_UI.speedControl.padding.bottom * scale}px ${BASE_UI.speedControl.padding.left * scale}px`;
          speedControl.style.gap = `${BASE_UI.speedControl.gap * scale}px`;
          speedControl.style.borderRadius = `${BASE_UI.speedControl.borderRadius * scale}px`;
        }
        
        const speedLabels = document.querySelectorAll('.control-speed label');
        speedLabels.forEach(label => {
          label.style.fontSize = `${BASE_UI.speedControl.fontSize.label * scale}rem`;
        });
        
        const speedSliders = document.querySelectorAll('.speed-slider');
        speedSliders.forEach(slider => {
          slider.style.width = `${BASE_UI.speedControl.sliderWidth * scale}px`;
        });
        
        const speedValues = document.querySelectorAll('.control-speed #speed-value');
        speedValues.forEach(value => {
          value.style.fontSize = `${BASE_UI.speedControl.fontSize.value * scale}rem`;
          value.style.minWidth = `${BASE_UI.speedControl.valueMinWidth * scale}px`;
        });
        
        // Icono de velocidad
        const speedIcons = document.querySelectorAll('.speed-icon');
        speedIcons.forEach(icon => {
          icon.style.width = `${BASE_UI.speedControl.iconSize * scale}px`;
          icon.style.height = `${BASE_UI.speedControl.iconSize * scale}px`;
        });
      }
      
      // Simulation Configuration - Valores escalados dinámicamente
      const CONFIG = {
        canvas: {
          width: BASE_CONFIG.canvas.width,
          height: BASE_CONFIG.canvas.height,
        },
        wound: {
          x: BASE_CONFIG.canvas.width / 2, // Center
          width: BASE_CONFIG.wound.width,
          height: BASE_CONFIG.wound.height,
        },
        wall: {
          thickness: BASE_CONFIG.wall.thickness,
          color: BASE_CONFIG.wall.color,
        },
        adhesionLineY: BASE_CONFIG.canvas.height - 250, // Posición base de la herida
        physics: {
          flowForce: 0.000175, // Base: promedio entre 0.00015 y 0.00020
          flowForceMin: 0.00008, // Mínimo muy reducido para pulso extremadamente dramático
          flowForceMax: 0.00045, // Máximo muy aumentado para hacer el pulso extremadamente visible (5.6x diferencia)
          suctionForce: 0.00030, // Fuerza de succión hacia la herida (positivo = atraer)
          suctionRadius: 2000, // Radio de efecto muy grande para ocupar todo el ancho del visor (solo mitad superior)
        },
        particles: {
          maxCount: 150, // Reduced for better performance
          spawnRate: 3, // Increased spawn rate for more particles
          plateletRatio: 0.30, // 30% para efectos didácticos
          rbcRatio: 0.65, // 65% - mayoría en sangre real
          wbcRatio: 0.05, // 5%
        },
        fibrin: {
          maxConnections: 200, // Limit fibrin connections to prevent performance issues
          maxConnectionsPerPlatelet: 8, // Limit connections per platelet
        },
        stuckPlatelets: {
          maxCount: 80, // Límite máximo de plaquetas pegadas para mantener rendimiento
        },
        conditions: {
          normal: {
            name: "Normal",
            description:
              "Coagulación fisiológica normal - Todos los factores funcionan correctamente",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregación: SÍ
            fibrinFormationRate: 1.0,
            fibrinStability: 1.0, // Fibrina FUERTE (stiffness: 0.9) - Resultado: Tapón sólido verde
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            bleedingTime: 3,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676", // Verde sólido
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La coagulación normal es un proceso fisiológico complejo que permite detener el sangrado tras una lesión vascular. Todos los componentes del sistema hemostático funcionan de manera coordinada.",
              pathophysiology: "En condiciones normales, la hemostasia primaria (adhesión y agregación plaquetaria) y secundaria (cascada de coagulación) trabajan en sinergia. Las plaquetas se adhieren al colágeno expuesto mediante el factor von Willebrand (vWF), se agregan entre sí, y la cascada de coagulación genera trombina que convierte el fibrinógeno en fibrina, formando una red estable que refuerza el tapón plaquetario.",
              symptoms: "No hay síntomas anormales. El tiempo de sangrado es normal (2-4 minutos) y la formación del coágulo es eficiente y estable.",
              causes: "Estado fisiológico normal. No hay déficit ni alteración de factores de coagulación.",
              treatment: "No requiere tratamiento. El sistema hemostático funciona correctamente.",
              prognosis: "Excelente. La coagulación ocurre de manera eficiente, minimizando la pérdida sanguínea y permitiendo la cicatrización adecuada.",
              clinicalNotes: "Este es el estado de referencia para comparar otras condiciones. Los tiempos normales de coagulación son: tiempo de sangrado 2-4 min, tiempo de protrombina (PT) 11-13 seg, tiempo de tromboplastina parcial (PTT) 25-35 seg.",
              affectedFactors: "Ninguno - todos los factores funcionan normalmente",
              cascadePathway: "Ambas vías (intrínseca y extrínseca) funcionan correctamente, convergiendo en la vía común que genera trombina eficientemente.",
            },
          },
          hemophilia: {
            name: "Hemofilia A/B",
            description:
              "Déficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ (Se forma el tapón blanco)
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregación: SÍ
            fibrinFormationRate: 0.1, // Probabilidad 10% - MUY DÉBIL o INEXISTENTE
            fibrinStability: 0.001, // MUY DÉBIL (stiffness: 0.001) - La fuerza de succión lo rompe
            fibrinDecayRate: 0.05, // Decaimiento rápido
            fibrinFormationDelay: 1500,
            bleedingTime: 30,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF6B6B", // Rojo para indicar débil
              fibrinGlow: false,
              fibrinOpacity: 0.3, // Muy transparente
            },
            educational: {
              overview: "La hemofilia es un trastorno hemorrágico hereditario causado por déficit de Factor VIII (Hemofilia A) o Factor IX (Hemofilia B). Es la coagulopatía hereditaria más común, afectando principalmente a varones.",
              pathophysiology: "El déficit de Factor VIII o IX interrumpe la vía intrínseca de la cascada de coagulación. Las plaquetas se adhieren normalmente formando el tapón primario, pero la generación de trombina está severamente reducida. Sin suficiente trombina, el fibrinógeno no se convierte eficientemente en fibrina, resultando en coágulos débiles e inestables que se desintegran fácilmente.",
              symptoms: "Sangrado prolongado tras lesiones menores, hemartrosis (sangrado en articulaciones), hematomas espontáneos, sangrado post-quirúrgico severo. El tiempo de sangrado puede ser normal, pero el tiempo de tromboplastina parcial (PTT) está prolongado.",
              causes: "Mutaciones genéticas en el cromosoma X que codifican para Factor VIII (Hemofilia A) o Factor IX (Hemofilia B). Patrón de herencia ligado al cromosoma X (afecta principalmente varones).",
              treatment: "Tratamiento de reemplazo con concentrados de Factor VIII o IX según el tipo. En casos leves puede usarse desmopresina (DDAVP) para Hemofilia A. Tratamiento profiláctico en casos severos. Tratamiento de episodios hemorrágicos agudos.",
              prognosis: "Con tratamiento adecuado, los pacientes pueden llevar una vida relativamente normal. Sin tratamiento, el sangrado recurrente puede causar artropatía hemofílica, anemia crónica y complicaciones graves.",
              clinicalNotes: "Hemofilia A (déficit Factor VIII) es más común que Hemofilia B (déficit Factor IX). La severidad depende del nivel de factor: severa (<1%), moderada (1-5%), leve (5-40%). El PTT está prolongado mientras que el PT es normal.",
              affectedFactors: "Factor VIII (Hemofilia A) o Factor IX (Hemofilia B) - componentes críticos de la vía intrínseca",
              cascadePathway: "Vía intrínseca defectuosa. El Factor VIII actúa como cofactor del Factor IX activado. Sin estos factores, la generación de trombina es insuficiente.",
            },
          },
          vwd: {
            name: "Enfermedad de Von Willebrand",
            description:
              "Déficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida",
            plateletRatio: 0.30, // Spawn normal
            canStick: false, // Adhesión: NO - Fallo en el "pegamento" (vWF)
            canFormFibrin: true,
            stickProbability: 0.0, // No pueden adherirse
            plateletFunction: 0.4,
            adhesionStrength: 0.0,
            aggregationRate: 0.0, // Sin agregación porque no hay adhesión
            fibrinFormationRate: 0.0, // No se forma porque no hay adhesión
            fibrinStability: 0.0,
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            plateletBounceFactor: 0.9, // Rebote alto (restitution: 0.9) - rebotan contra la pared
            adhesionRetryChance: 0.0,
            bleedingTime: 15,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676",
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La enfermedad de Von Willebrand (EvW) es el trastorno hemorrágico hereditario más común, afectando aproximadamente al 1% de la población. Se caracteriza por déficit o disfunción del factor von Willebrand (vWF).",
              pathophysiology: "El factor von Willebrand actúa como 'pegamento' que permite que las plaquetas se adhieran al colágeno expuesto en la pared vascular lesionada. También transporta y estabiliza el Factor VIII en plasma. Sin vWF funcional, las plaquetas no pueden adherirse al sitio de la lesión, impidiendo la formación del tapón primario y, por tanto, la iniciación de la cascada de coagulación.",
              symptoms: "Sangrado mucocutáneo (epistaxis, sangrado gingival, menorragia), sangrado prolongado tras cirugía menor, hematomas fáciles, tiempo de sangrado prolongado. Los síntomas suelen ser más leves que en hemofilia.",
              causes: "Mutaciones genéticas en el gen VWF localizado en el cromosoma 12. Puede ser heredada de forma autosómica dominante (tipo 1 y 2) o recesiva (tipo 3). Tipo 1: déficit cuantitativo parcial; Tipo 2: defectos cualitativos; Tipo 3: déficit completo severo.",
              treatment: "Desmopresina (DDAVP) para tipos 1 y 2A leves - aumenta la liberación de vWF endógeno. Concentrados de vWF/Factor VIII para casos severos o cuando DDAVP no es efectivo. Ácido tranexámico como coadyuvante para sangrado mucocutáneo.",
              prognosis: "Generalmente buena. La mayoría de los pacientes tienen síntomas leves y pueden manejar episodios hemorrágicos con tratamiento adecuado. Los casos severos requieren manejo similar a hemofilia.",
              clinicalNotes: "Existen tres tipos principales: Tipo 1 (déficit parcial, 75% de casos), Tipo 2 (defectos cualitativos, 20-25%), Tipo 3 (déficit severo, raro). El tiempo de sangrado está prolongado y el Factor VIII puede estar reducido.",
              affectedFactors: "Factor von Willebrand (vWF) - esencial para la adhesión plaquetaria y estabilización del Factor VIII",
              cascadePathway: "Fallo en la hemostasia primaria. Sin adhesión plaquetaria, no se inicia adecuadamente la cascada de coagulación, aunque los factores de coagulación pueden estar normales.",
            },
          },
          thrombocytopenia: {
            name: "Trombocitopenia",
            description:
              "Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el coágulo",
            plateletRatio: 0.075, // Spawn BAJO (5-10%, promedio 7.5%)
            canStick: true, // Funcionalidad normal
            canFormFibrin: true, // El "cemento" (fibrina) funciona bien
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 1.0, // Normal - si logran juntarse, tejen fibrina
            fibrinStability: 1.0, // Normal
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            spawnRateMultiplier: 0.3,
            bleedingTime: 20,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676",
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La trombocitopenia es una condición caracterizada por un recuento bajo de plaquetas (<150,000/μL). Las plaquetas existentes funcionan normalmente, pero su número insuficiente dificulta la formación adecuada del tapón hemostático.",
              pathophysiology: "Con pocas plaquetas circulantes, aunque cada plaqueta funcione correctamente, no hay suficientes células para cubrir el área de la lesión y formar un tapón primario efectivo. La cascada de coagulación puede funcionar normalmente, pero sin un tapón plaquetario adecuado, la formación de fibrina es limitada o ineficaz.",
              symptoms: "Petequias (pequeñas manchas rojas en la piel), púrpura (manchas moradas), equimosis (hematomas), sangrado mucocutáneo, sangrado prolongado tras lesiones menores. El riesgo de sangrado aumenta significativamente con recuentos <50,000/μL y es severo con <20,000/μL.",
              causes: "Múltiples causas: disminución de producción (anemia aplásica, leucemia, déficit de vitamina B12/folato), aumento de destrucción (púrpura trombocitopénica inmune, trombocitopenia inducida por fármacos), secuestro esplénico, consumo excesivo (coagulación intravascular diseminada).",
              treatment: "Depende de la causa: corticosteroides o inmunoglobulina IV para trombocitopenia inmune, transfusión de plaquetas para sangrado activo o recuentos muy bajos, esplenectomía en casos refractarios, tratamiento de la causa subyacente.",
              prognosis: "Varía según la causa. La trombocitopenia inmune aguda en niños suele resolverse espontáneamente. Las formas crónicas requieren manejo a largo plazo. Con tratamiento adecuado, la mayoría de los pacientes pueden mantener recuentos seguros.",
              clinicalNotes: "Recuento normal: 150,000-450,000/μL. Leve: 100,000-150,000/μL (sangrado menor). Moderada: 50,000-100,000/μL (sangrado con trauma). Severa: <50,000/μL (sangrado espontáneo). El tiempo de sangrado está prolongado proporcionalmente al déficit.",
              affectedFactors: "Ningún factor de coagulación está afectado - el problema es cuantitativo (número de plaquetas) no cualitativo (función)",
              cascadePathway: "La cascada de coagulación funciona normalmente, pero la hemostasia primaria es inadecuada debido al número insuficiente de plaquetas para formar el tapón inicial.",
            },
          },
          hemophiliaSevere: {
            name: "Hemofilia Severa",
            description:
              "Déficit grave Factor VIII/IX (<1%) - Sin formación de fibrina, sangrado prolongado",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ (Se forma tapón blanco)
            canFormFibrin: false, // Fibrina: CERO
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregación: SÍ
            fibrinFormationRate: 0.0, // CERO
            fibrinStability: 0.0, // CERO
            fibrinDecayRate: 0.2,
            fibrinFormationDelay: 0,
            bleedingTime: 60,
            blockThickCords: true,
            blockMediumCords: true,
            blockThinCords: true, // Bloquear todas las cuerdas
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF0000",
              fibrinGlow: false,
              fibrinOpacity: 0.0, // Invisible porque no se forma
            },
            educational: {
              overview: "La hemofilia severa se define por niveles de Factor VIII o IX <1% de lo normal. Representa la forma más grave de hemofilia, con sangrado espontáneo frecuente y riesgo significativo de complicaciones hemorrágicas graves.",
              pathophysiology: "Con niveles prácticamente indetectables de Factor VIII o IX, la vía intrínseca de coagulación está completamente bloqueada. El tapón plaquetario primario se forma normalmente, pero sin generación de trombina, no hay conversión de fibrinógeno a fibrina. Los coágulos que se forman son extremadamente débiles y se desintegran rápidamente, resultando en sangrado prolongado o recurrente.",
              symptoms: "Sangrado espontáneo frecuente (sin trauma aparente), hemartrosis recurrente que puede llevar a artropatía hemofílica, hematomas extensos, sangrado intracraneal (complicación grave), sangrado post-quirúrgico severo, sangrado gastrointestinal o genitourinario.",
              causes: "Mutaciones genéticas severas en los genes de Factor VIII (Hemofilia A severa) o Factor IX (Hemofilia B severa) que resultan en producción mínima o nula del factor. Patrón de herencia ligado al cromosoma X.",
              treatment: "Tratamiento profiláctico regular con concentrados de Factor VIII/IX (2-3 veces por semana) para prevenir sangrados. Tratamiento de episodios hemorrágicos agudos con dosis altas. En algunos casos, terapia génica experimental. Manejo multidisciplinario incluyendo fisioterapia para prevenir artropatía.",
              prognosis: "Sin tratamiento, la esperanza de vida está significativamente reducida debido a complicaciones hemorrágicas. Con tratamiento profiláctico adecuado, los pacientes pueden llevar vidas relativamente normales, aunque requieren atención médica continua. La artropatía hemofílica es una complicación común a largo plazo.",
              clinicalNotes: "Niveles de factor <1% definen hemofilia severa. El PTT está muy prolongado (>60 segundos). Los pacientes requieren tratamiento profiláctico para prevenir sangrados espontáneos. El desarrollo de inhibidores (anticuerpos contra el factor) es una complicación grave que afecta al 20-30% de pacientes con Hemofilia A severa.",
              affectedFactors: "Factor VIII o Factor IX prácticamente ausentes (<1% de actividad normal) - bloqueo completo de la vía intrínseca",
              cascadePathway: "Vía intrínseca completamente bloqueada. Sin Factor VIII/IX, no hay activación del Factor X, resultando en ausencia total de generación de trombina y formación de fibrina.",
            },
          },
          thrombasthenia: {
            name: "Trombastenia de Glanzmann",
            description:
              "Déficit glicoproteína IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre sí",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión (Pared): SÍ - Se pegan al tejido
            canFormFibrin: true,
            stickProbability: 0.9,
            plateletFunction: 0.2,
            adhesionStrength: 0.85, // Se pegan a la pared
            aggregationRate: 0.0, // Agregación (Plaqueta-Plaqueta): NO
            fibrinFormationRate: 0.0, // No se forma porque no hay agregación
            fibrinStability: 0.0,
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            maxPlateletClusterSize: 1, // Solo una plaqueta por posición - no agregación
            bleedingTime: 25,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FFA500",
              fibrinGlow: false,
              fibrinOpacity: 0.0, // No se forma fibrina
            },
            educational: {
              overview: "La trombastenia de Glanzmann es un trastorno hemorrágico hereditario raro caracterizado por déficit o disfunción del complejo glicoproteína IIb/IIIa (GPIIb/IIIa), el receptor principal de fibrinógeno en las plaquetas.",
              pathophysiology: "Las plaquetas pueden adherirse normalmente a la pared vascular mediante vWF y otros receptores, pero no pueden agregarse entre sí porque el receptor GPIIb/IIIa está ausente o disfuncional. Este receptor es esencial para que las plaquetas se unan mediante puentes de fibrinógeno. Sin agregación, no se forma un tapón plaquetario efectivo, y aunque la cascada de coagulación funcione, sin un tapón adecuado la formación de fibrina es limitada.",
              symptoms: "Sangrado mucocutáneo severo (epistaxis, gingivorragia, menorragia), púrpura, equimosis, sangrado prolongado tras cirugía o trauma. El tiempo de sangrado está muy prolongado. Las plaquetas no se agregan en respuesta a agonistas como ADP, trombina o colágeno.",
              causes: "Mutaciones en los genes ITGA2B (codifica GPIIb) o ITGB3 (codifica GPIIIa) localizados en el cromosoma 17. Herencia autosómica recesiva. Tipo I: ausencia completa del complejo; Tipo II: presencia pero disfunción del complejo.",
              treatment: "Transfusión de plaquetas para episodios hemorrágicos agudos o antes de procedimientos quirúrgicos. Ácido tranexámico como coadyuvante. Desmopresina puede tener efecto limitado. En casos refractarios, factor VIIa recombinante. Evitar antiagregantes plaquetarios.",
              prognosis: "Es un trastorno crónico que requiere manejo de por vida. Con tratamiento adecuado de episodios hemorrágicos, los pacientes pueden llevar vidas relativamente normales, aunque el sangrado puede ser severo. La menorragia puede ser particularmente problemática en mujeres.",
              clinicalNotes: "El recuento plaquetario es normal, pero la agregación plaquetaria está ausente o severamente reducida. El tiempo de sangrado está muy prolongado (>20 minutos). La prueba de agregación plaquetaria muestra ausencia de respuesta a todos los agonistas. Es más común en poblaciones con consanguinidad.",
              affectedFactors: "Glicoproteína IIb/IIIa (GPIIb/IIIa) - receptor de fibrinógeno esencial para la agregación plaquetaria",
              cascadePathway: "La cascada de coagulación puede funcionar normalmente, pero sin agregación plaquetaria no se forma un tapón primario efectivo, limitando la iniciación y eficacia de la formación de fibrina.",
            },
          },
          factorDeficiency: {
            name: "Déficit Factor VII",
            description:
              "Déficit Factor VII - Vía extrínseca defectuosa, formación de fibrina reducida",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ - Las plaquetas se pegan
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 1.0, // Normal después del retraso
            fibrinStability: 0.9, // Normal después del retraso
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 4000, // Retraso 3-5 segundos extra (4000ms) tras la adhesión
            bleedingTime: 12,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FFD700",
              fibrinGlow: false,
              fibrinOpacity: 0.9,
            },
            educational: {
              overview: "El déficit de Factor VII es un trastorno hemorrágico hereditario raro que afecta la vía extrínseca de la coagulación. El Factor VII es el primer factor activado en la vía extrínseca cuando se expone el factor tisular tras una lesión.",
              pathophysiology: "El Factor VII, junto con el factor tisular (FT), inicia la vía extrínseca activando el Factor X. Con déficit de Factor VII, esta activación inicial está retrasada o reducida. La vía intrínseca puede compensar parcialmente, pero hay un retraso significativo en la generación de trombina y formación de fibrina. Las plaquetas funcionan normalmente, pero el refuerzo de fibrina tarda más en formarse.",
              symptoms: "Sangrado variable según la severidad del déficit. Puede incluir sangrado mucocutáneo, hemartrosis (menos común que en hemofilia), sangrado post-quirúrgico, menorragia. Los síntomas suelen ser más leves que en hemofilia. El tiempo de protrombina (PT) está prolongado mientras que el PTT puede ser normal.",
              causes: "Mutaciones en el gen F7 localizado en el cromosoma 13 que codifica el Factor VII. Herencia autosómica recesiva. Puede ser congénito (raro) o adquirido (asociado a enfermedad hepática, déficit de vitamina K, o uso de warfarina).",
              treatment: "Concentrados de Factor VII recombinante o plasma fresco congelado para episodios hemorrágicos. En casos leves puede no requerir tratamiento profiláctico. El tratamiento de reemplazo es efectivo pero de corta duración (vida media corta del Factor VII).",
              prognosis: "Generalmente buena. Los pacientes con déficit leve pueden tener síntomas mínimos. Los casos severos requieren tratamiento de episodios hemorrágicos pero pueden llevar vidas relativamente normales con manejo adecuado.",
              clinicalNotes: "El PT está prolongado mientras que el PTT es normal (patrón inverso a hemofilia). El déficit de Factor VII es el más común de los déficits de factores de la vía extrínseca, aunque sigue siendo raro. La vida media del Factor VII es corta (4-6 horas), requiriendo dosis frecuentes en tratamiento.",
              affectedFactors: "Factor VII - componente crítico de la vía extrínseca que inicia la activación del Factor X",
              cascadePathway: "Vía extrínseca defectuosa o retrasada. La vía intrínseca puede compensar parcialmente, pero hay un retraso en la generación inicial de trombina, resultando en formación tardía de fibrina.",
            },
          },
          anticoagulated: {
            name: "Anticoagulado (Warfarina)",
            description:
              "Anticoagulación oral - Factores dependientes de vitamina K reducidos, fibrina inestable",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: Normal
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 0.3, // ESCASA - probabilidad baja
            fibrinStability: 0.3, // DÉBIL (stiffness baja) - similar a hemofilia leve
            fibrinDecayRate: 0.08, // Decaimiento rápido
            fibrinFormationDelay: 800,
            bleedingTime: 8,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF6347",
              fibrinGlow: false,
              fibrinOpacity: 0.5, // Más transparente
            },
            educational: {
              overview: "La anticoagulación con warfarina es un tratamiento común para prevenir trombosis en pacientes con fibrilación auricular, prótesis valvulares cardíacas, o historia de tromboembolismo. La warfarina inhibe la síntesis de factores de coagulación dependientes de vitamina K.",
              pathophysiology: "La warfarina bloquea la enzima vitamina K epóxido reductasa, impidiendo la carboxilación de los factores II, VII, IX y X (factores dependientes de vitamina K). Sin esta modificación post-traduccional, estos factores no pueden unirse al calcio y fosfolípidos, reduciendo su actividad. Esto resulta en generación reducida de trombina y formación de fibrina débil e inestable. Las plaquetas funcionan normalmente, pero el refuerzo de fibrina es insuficiente.",
              symptoms: "Aumento del riesgo de sangrado, especialmente con sobredosificación. Puede presentar sangrado mucocutáneo, hematomas fáciles, sangrado prolongado tras procedimientos, hemorragia gastrointestinal o intracraneal (complicación grave). El tiempo de protrombina (PT/INR) está prolongado.",
              causes: "Uso terapéutico de warfarina para prevención de trombosis. La dosis se ajusta según el INR objetivo (generalmente 2-3 para mayoría de indicaciones, 2.5-3.5 para prótesis valvulares mecánicas). Interacciones con múltiples fármacos y alimentos pueden afectar los niveles.",
              treatment: "Para sangrado menor: suspender warfarina temporalmente. Para sangrado mayor o INR muy elevado: vitamina K oral o IV para revertir la anticoagulación, concentrado de complejo protrombínico (PCC) para reversión rápida en emergencias, plasma fresco congelado como alternativa. Monitoreo regular de INR para ajuste de dosis.",
              prognosis: "Con monitoreo adecuado y mantenimiento del INR en rango terapéutico, el riesgo de sangrado es bajo. Sin embargo, requiere monitoreo regular y ajuste de dosis. El riesgo de sangrado aumenta con INR >4.5. Los pacientes deben evitar traumatismos y ser cuidadosos con interacciones farmacológicas.",
              clinicalNotes: "El INR (International Normalized Ratio) es el parámetro de monitoreo estándar. Rango terapéutico típico: 2-3. La warfarina tiene inicio de acción lento (2-3 días) y vida media larga (36-42 horas). Requiere 5-7 días para alcanzar efecto completo y similar tiempo para revertirse. Interacciones comunes con antibióticos, AINEs, y alimentos ricos en vitamina K.",
              affectedFactors: "Factores II (protrombina), VII, IX y X - todos dependientes de vitamina K para su activación funcional",
              cascadePathway: "Ambas vías (intrínseca y extrínseca) están afectadas porque comparten factores dependientes de vitamina K. La generación de trombina está reducida, resultando en formación de fibrina débil e inestable.",
            },
          },
        },
      };

      // Game State
      let state = {
        condition: "normal",
        treatmentApplied: false,
        bloodLoss: 0,
        clotPercentage: 0,
        hemostasisAchieved: false,
        stuckPlatelets: [],
        fibrinConstraints: [],
        fibrinBodies: [], // Physical bodies for fibrin network
        allBodies: [],
        showOintment: false,
        fibrinStarted: false,
        simulationRunning: false, // Control manual de simulación
        startTime: null,
        plateletsSpawned: 0,
        // Controles de velocidad
        timeScale: 1.0,
        isPaused: false,
      };

      // Spawn timing for fixed interval
      let spawnInterval = null;
      let lastSpawnTime = 0;
      // spawnIntervalCounter removido
      let actualSpawnIntervals = []; // Array para calcular el intervalo promedio
      const SPAWN_INTERVAL_MS = 125; // Intervalo variable entre 100-150ms (promedio 125ms)

      // Performance optimization: frame counters for throttling
      let frameCount = 0;
      const CLEANUP_INTERVAL = 5; // Cleanup every 5 frames (más frecuente para mejor limpieza)
      const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames

      // Fixed timestep loop variables - garantizar velocidad constante independiente del FPS
      let physicsLoopId = null;
      let renderLoopId = null;
      let lastPhysicsTime = 0;
      const FIXED_TIMESTEP = 1000 / 60; // 16.67ms = 60 FPS fijo para física
      let accumulatedTime = 0;
      let accumulatedSimulationTime = 0; // Tiempo de simulación acumulado (ajustado por timeScale)
      let lastSimulationTimeUpdate = 0; // Última vez que se actualizó el tiempo de simulación

      // Matter.js Setup
      let engine, render, runner;
      
      // FPS Counter variables
      let fpsFrameCount = 0;
      let fpsLastTime = performance.now();
      let currentFPS = 0;

      function initSimulation() {
        // Clear spawn timeout
        if (spawnInterval !== null) {
          clearTimeout(spawnInterval);
          spawnInterval = null;
        }
        // spawnIntervalCounter removido

        lastSpawnTime = 0;
        actualSpawnIntervals = [];
        spawnStats = {
          lastSpawnCount: 0,
          totalSpawned: 0,
          spawnHistory: [],
        };

        // Reset state (preservar propiedades nuevas)
        state = {
          condition: state.condition,
          treatmentApplied: false,
          bloodLoss: 0,
          clotPercentage: 0,
          hemostasisAchieved: false,
          stuckPlatelets: [],
          fibrinConstraints: [],
          fibrinBodies: [],
          allBodies: [],
          showOintment: false,
          fibrinStarted: false,
          simulationRunning: false,
          startTime: null,
          plateletsSpawned: 0,
          // Controles de velocidad (base speed = 0.75, slider 1.0 = velocidad normal más lenta)
          timeScale: state.timeScale || 0.75,
          isPaused: false,
        };

        // FPS counter removed

        // Clear previous engine events
        if (engine) {
          Events.off(engine, "beforeUpdate");
          Events.off(engine, "afterUpdate");
          Events.off(engine, "collisionStart");
          // Remove anchor platelets before clearing world
          if (state.stuckPlatelets) {
            state.stuckPlatelets.forEach((plateletData) => {
              if (plateletData.isAnchor && plateletData.body) {
                Composite.remove(engine.world, plateletData.body);
              }
            });
          }
          Composite.clear(engine.world);
          Engine.clear(engine);
        }
        if (render) {
          Events.off(render, "afterRender");
          Render.stop(render);
        }
        // No necesitamos detener el runner porque usamos nuestro propio loop
        // if (runner) {
        //     Runner.stop(runner);
        // }

        // Reset canvas
        const canvas = document.getElementById("simulation-canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Reset state
        state.fibrinStarted = false;
        state.simulationRunning = false;

        // Resetear tiempo acumulado de simulación
        accumulatedSimulationTime = 0;
        lastSimulationTimeUpdate = 0;

        // Reset UI elements
        const woundLabel = document.getElementById("wound-label");
        // El label se oculta por defecto y solo aparece al iniciar la simulación
        woundLabel.classList.add("hidden");
        woundLabel.classList.remove("healed", "active-pulse");
        woundLabel.innerHTML = "Lesión Activa";
        
        // Remover efecto de pulsación del botón de reiniciar
        const resetBtn = document.getElementById("reset-btn");
        if (resetBtn) {
          resetBtn.classList.remove("hemostasis-pulse");
        }

        const treatmentBtn = document.getElementById("treatment-btn");
        treatmentBtn.classList.remove("applied");
        treatmentBtn.innerHTML = `Administrar Tratamiento`;
        treatmentBtn.disabled = false;

        // Resetear tiempo hasta cierre de herida
        const adhesionTimeEl = document.getElementById(
          "first-adhesion-time"
        );
        if (adhesionTimeEl) {
          adhesionTimeEl.textContent = "--";
        }


        // Create engine with zero gravity
        engine = Engine.create();
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 0;

        // Create renderer using existing canvas
        const canvasEl = document.getElementById("simulation-canvas");

        // Función para detectar el zoom del navegador
        const getBrowserZoom = () => {
          // Crear un elemento de referencia para medir el zoom
          const testEl = document.createElement('div');
          testEl.style.width = '100px';
          testEl.style.height = '100px';
          testEl.style.position = 'absolute';
          testEl.style.visibility = 'hidden';
          testEl.style.top = '-9999px';
          document.body.appendChild(testEl);
          
          const logicalWidth = testEl.offsetWidth;
          const visualWidth = testEl.getBoundingClientRect().width;
          const zoom = visualWidth / logicalWidth;
          
          document.body.removeChild(testEl);
          return zoom;
        };

        // El tamaño del canvas se inicializa en initializeResizeHandlers()
        // que se ejecuta una sola vez cuando el DOM está cargado

        render = Render.create({
          canvas: canvasEl,
          engine: engine,
          options: {
            width: canvasEl.width,
            height: canvasEl.height,
            wireframes: false,
            background: "transparent", // Fondo transparente - dibujamos nosotros
            // Desacoplar el renderer del timestep de la física
            // El renderer se actualiza a su propio ritmo, pero la física siempre usa timestep fijo
            // Usar pixelRatio 1 para evitar que Matter.js escale el canvas internamente
            // Ya estamos manejando el tamaño manualmente para soportar zoom
            pixelRatio: 1,
          },
        });
        
        // Mejorar calidad de renderizado del canvas
        const canvasCtx = canvasEl.getContext("2d");
        if (canvasCtx) {
          canvasCtx.imageSmoothingEnabled = true;
          canvasCtx.imageSmoothingQuality = "high";
        }

        // Asegurar que el engine siempre use timestep fijo
        engine.timing.timeScale = 1.0;
        engine.timing.timestamp = 0;

        // Create vessel walls
        createVesselWalls();

        // Start engine and renderer with fixed timestep
        // Configurar el engine para usar timestep fijo
        engine.timing.timeScale = 1.0; // Asegurar que el timeScale sea 1.0

        // Crear Runner pero NO ejecutarlo automáticamente
        // Usaremos nuestro propio loop con timestep fijo garantizado
        runner = Runner.create({
          delta: FIXED_TIMESTEP,
          isFixed: true,
          enabled: false, // Deshabilitar el loop automático
        });

        // Loop de renderizado independiente (puede ejecutarse a cualquier FPS)
        function renderLoop() {
          if (render) {
            Render.world(render);
          }
          
          // Calcular FPS
          fpsFrameCount++;
          const currentTime = performance.now();
          const elapsed = currentTime - fpsLastTime;
          
          if (elapsed >= 1000) { // Actualizar cada segundo
            currentFPS = Math.round((fpsFrameCount * 1000) / elapsed);
            fpsFrameCount = 0;
            fpsLastTime = currentTime;
            
            // Actualizar el contador de FPS en el DOM
            const fpsCounterEl = document.getElementById("fps-counter");
            if (fpsCounterEl) {
              fpsCounterEl.textContent = `FPS: ${currentFPS}`;
            }
          }
          
          renderLoopId = requestAnimationFrame(renderLoop);
        }

        // Iniciar el loop de renderizado (siempre activo)
        renderLoop();

        // Loop de física con timestep fijo (solo se ejecuta cuando simulationRunning = true)
        function physicsLoop(currentTime) {
          if (!state.simulationRunning) {
            physicsLoopId = requestAnimationFrame(physicsLoop);
            return;
          }

          // Calcular tiempo transcurrido desde el último frame
          if (lastPhysicsTime === 0) {
            lastPhysicsTime = currentTime;
          }

          const deltaTime = currentTime - lastPhysicsTime;
          lastPhysicsTime = currentTime;

          // Acumular tiempo y ejecutar pasos de física a intervalos fijos
          accumulatedTime += deltaTime;

          // Acumular tiempo de simulación ajustado por timeScale (solo cuando está corriendo y no pausada)
          if (!state.isPaused && state.simulationRunning) {
            const timeScale = state.timeScale || 1.0;
            accumulatedSimulationTime += deltaTime * timeScale;
          }

          // Ejecutar tantos pasos de física como sean necesarios para mantener timestep fijo
          // Ajustar el número de pasos según timeScale para acelerar la simulación
          const timeScale = state.timeScale || 1.0;
          const maxSteps = 5; // Limitar pasos por frame para evitar "spiral of death"
          let stepsExecuted = 0;

          // Ejecutar múltiples pasos según timeScale, pero mantener timestep fijo
          // Esto acelera la simulación sin afectar la estabilidad física
          const stepsToExecute = Math.max(1, Math.ceil(timeScale));

          while (
            accumulatedTime >= FIXED_TIMESTEP &&
            stepsExecuted < maxSteps
          ) {
            // Solo ejecutar física si no está pausada
            if (!state.isPaused && state.simulationRunning) {
              // Ejecutar múltiples pasos de física con timestep fijo para acelerar la simulación
              // En lugar de escalar el timestep, ejecutamos más pasos por iteración
              // Esto mantiene la física estable pero acelera la simulación
              for (let i = 0; i < stepsToExecute; i++) {
                Engine.update(engine, FIXED_TIMESTEP);
              }
            }
            // Restar el tiempo correspondiente a los pasos ejecutados
            accumulatedTime -= FIXED_TIMESTEP;
            stepsExecuted++;
          }

          // Si acumulamos demasiado tiempo, resetear para evitar lag
          if (accumulatedTime > FIXED_TIMESTEP * 5) {
            accumulatedTime = 0;
          }

          physicsLoopId = requestAnimationFrame(physicsLoop);
        }

        // Iniciar el loop de física (siempre activo, pero solo procesa cuando simulationRunning = true)
        // Resetear variables de tiempo
        lastPhysicsTime = 0;
        accumulatedTime = 0;

        // Iniciar el loop de física
        if (!physicsLoopId) {
          physicsLoopId = requestAnimationFrame(physicsLoop);
        }

        // Estado inicial: simulación no corriendo
        state.simulationRunning = false;

        // Setup collision events
        setupCollisionEvents();

        // Start particle spawning
        startParticleSpawning();

        // Reset frame counter
        frameCount = 0;

        // Update loop for forces - use fixed timestep for frame-independent forces
        // Con isFixed: true, el Runner ejecuta pasos de física a intervalos fijos
        // Cada paso siempre es de 16.67ms, independientemente del FPS del renderer
        Events.on(engine, "beforeUpdate", () => {
          // Solo actualizar si la simulación está corriendo y no está pausada
          if (!state.simulationRunning || state.isPaused) return;

          frameCount++;
          // Aplicar fuerzas con timestep fijo (el timeScale se maneja ejecutando múltiples pasos de física)
          // Esto asegura que las fuerzas de adhesión funcionen correctamente independientemente de la velocidad
          applyForces(runner.delta);

          // Update fibrin barrier positions to follow platelets (every 3 frames for performance)
          if (frameCount % 3 === 0 && state.fibrinConstraints.length > 0) {
            state.fibrinConstraints.forEach((fibrin) => {
              if (fibrin.body && fibrin.pointA && fibrin.pointB) {
                const midX =
                  (fibrin.pointA.position.x + fibrin.pointB.position.x) / 2;
                const midY =
                  (fibrin.pointA.position.y + fibrin.pointB.position.y) / 2;
                const dist = Vector.magnitude(
                  Vector.sub(fibrin.pointB.position, fibrin.pointA.position)
                );
                const angle = Math.atan2(
                  fibrin.pointB.position.y - fibrin.pointA.position.y,
                  fibrin.pointB.position.x - fibrin.pointA.position.x
                );

                Body.setPosition(fibrin.body, { x: midX, y: midY });
                Body.setAngle(fibrin.body, angle);
                // Update width to match distance
                const currentWidth =
                  fibrin.body.bounds.max.x - fibrin.body.bounds.min.x;
                if (Math.abs(currentWidth - dist) > 1) {
                  Body.scale(fibrin.body, dist / currentWidth, 1);
                }
              }
            });
          }

          // Throttle expensive operations
          if (frameCount % CLEANUP_INTERVAL === 0) {
            cleanupParticles();
            // También limpiar plaquetas pegadas antiguas periódicamente
            cleanupOldStuckPlatelets();
          }
          if (frameCount % UI_UPDATE_INTERVAL === 0) {
            calculateClotPercentage();
            updateUI();
          }

          // vWF se renderiza como líneas entre plaquetas (no necesita actualización)
        });

        // Custom render - todo en afterRender, en orden: fondo, paredes, fibrina, vWF, partículas
        Events.on(render, "afterRender", renderVesselBackground);
        Events.on(render, "afterRender", renderVesselWalls);
        Events.on(render, "afterRender", renderFibrin);
        Events.on(render, "afterRender", renderVWF); // vWF se renderiza después de las cuerdas
        Events.on(render, "afterRender", renderParticlesCustom);

        // Update UI
        updateUI();
      }

      // FPS Counter removido

      function createVesselWalls() {
        const { width, height } = CONFIG.canvas;
        const { thickness, color } = CONFIG.wall;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;

        // Top wall - Left and Right segments - moved down visually to match wound position
        const adhesionLineY = CONFIG.adhesionLineY;
        const leftWallWidth = woundX - woundWidth / 2;
        const topWallLeft = Bodies.rectangle(
          leftWallWidth / 2,
          adhesionLineY,
          leftWallWidth,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Top wall - Right segment - with bounce and collision filter (moved down visually)
        const rightWallStart = woundX + woundWidth / 2;
        const rightWallWidth = width - rightWallStart;
        const topWallRight = Bodies.rectangle(
          rightWallStart + rightWallWidth / 2,
          adhesionLineY,
          rightWallWidth,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Wound edge markers (left and right edges of wound)
        const woundEdgeLeft = Bodies.rectangle(
          woundX - woundWidth / 2,
          thickness / 2,
          6,
          thickness + 10,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "woundEdge",
            isSensor: false,
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        const woundEdgeRight = Bodies.rectangle(
          woundX + woundWidth / 2,
          thickness / 2,
          6,
          thickness + 10,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "woundEdge",
            isSensor: false,
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        Composite.add(engine.world, [
          topWallLeft,
          topWallRight,
          woundEdgeLeft,
          woundEdgeRight,
        ]);

        // Create invisible anchor platelets on each side of the wound
        createInvisibleAnchorPlatelets(woundX, woundWidth, thickness);
      }

      function createInvisibleAnchorPlatelets(
        woundX,
        woundWidth,
        wallThickness
      ) {
        const adhesionLineY = CONFIG.adhesionLineY; // More down visually = higher Y in canvas coords (rotated 180°)
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Left anchor platelet - positioned just inside the left edge of the wound
        const leftAnchorX = woundLeft + 2 * scaleFactor;
        const leftAnchor = Bodies.circle(leftAnchorX, adhesionLineY + 6 * scaleFactor, BASE_CONFIG.particles.plateletRadius * scaleFactor, {
          isStatic: true,
          render: { fillStyle: "transparent", visible: false },
          label: "platelet",
          isStuck: true,
          isAnchor: true, // Mark as anchor platelet
        });

        // Right anchor platelet - positioned just inside the right edge of the wound
        const rightAnchorX = woundRight - 10 * scaleFactor;
        const rightAnchor = Bodies.circle(rightAnchorX, adhesionLineY + 6 * scaleFactor, BASE_CONFIG.particles.plateletRadius * scaleFactor, {
          isStatic: true,
          render: { fillStyle: "transparent", visible: false },
          label: "platelet",
          isStuck: true,
          isAnchor: true, // Mark as anchor platelet
        });

        Composite.add(engine.world, [leftAnchor, rightAnchor]);

        // Add to stuck platelets list so they can form fibrin connections
        const leftAnchorData = {
          body: leftAnchor,
          constraint: null,
          hasFibrin: false,
          fibrinConnections: [],
          isAnchor: true,
        };

        const rightAnchorData = {
          body: rightAnchor,
          constraint: null,
          hasFibrin: false,
          fibrinConnections: [],
          isAnchor: true,
        };

        state.stuckPlatelets.push(leftAnchorData, rightAnchorData);

        // Try to form fibrin connections from anchor platelets after a delay
        setTimeout(() => {
          if (state.stuckPlatelets.includes(leftAnchorData)) {
            tryFormFibrin(leftAnchorData);
          }
          if (state.stuckPlatelets.includes(rightAnchorData)) {
            tryFormFibrin(rightAnchorData);
          }
        }, 200);
      }

      function createParticle(type) {
        // Spawn particles at the top (visually), which is low Y in canvas coordinates (rotated 180°)
        // Particles spawn from the top of the screen (low Y in canvas coords due to 180° rotation)
        const y = 10 * scaleFactor + Math.random() * 30 * scaleFactor; // Top visually = low Y in canvas coords (rotated 180°)
        // Spawn particles across the entire width of the canvas
        const x = 20 * scaleFactor + Math.random() * (CONFIG.canvas.width - 40 * scaleFactor); // Todo el ancho del visor con márgenes

        let body;

        switch (type) {
          case "platelet":
            // En Von Willebrand, las plaquetas tienen alta restitución (rebotan)
            const conditionConfig = CONFIG.conditions[state.condition];
            const plateletRestitution = 
              (state.condition === "vwd" && !state.treatmentApplied) 
                ? 0.9 // Alta restitución para vWD - rebotan en lugar de adherirse
                : 0.5; // Rebote medio normal
            
            body = Bodies.circle(x, y, BASE_CONFIG.particles.plateletRadius * scaleFactor, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "platelet",
              restitution: plateletRestitution,
              friction: 0.1,
              frictionAir: 0.02, // Reducido para que se muevan más rápido, pero aún suficiente para adhesión
              density: 0.001,
              isSticky: true,
              isStuck: false,
              collisionFilter: {
                group: 0,
                category: 0x0001,
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            // Agregar timestamp de creación para duración de vida
            body.createdAt = performance.now();
            // Rastrear plaquetas spawnadas
            state.plateletsSpawned++;
            break;

          case "rbc":
            // Glóbulos rojos: usar círculo pero renderizar como elipse en custom render
            body = Bodies.circle(x, y, BASE_CONFIG.particles.rbcRadius * scaleFactor, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "rbc",
              restitution: 0.5, // Rebote medio - ligero, relleno visual
              friction: 0.05,
              frictionAir: 0.01,
              density: 0.0008, // Ligero
              collisionFilter: {
                group: 0,
                category: 0x0001, // RBC category
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            // Agregar timestamp de creación para duración de vida
            body.createdAt = performance.now();
            break;

          case "wbc":
            body = Bodies.circle(x, y, BASE_CONFIG.particles.wbcRadius * scaleFactor, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "wbc",
              restitution: 0.7,
              friction: 0.1,
              frictionAir: 0.03,
              density: 0.04, // Pesado - obstáculo visual
              collisionFilter: {
                group: 0,
                category: 0x0001, // WBC category
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            // Agregar timestamp de creación para duración de vida
            body.createdAt = performance.now();
            break;
        }

        if (body) {
          // Aplicar velocidad inicial basada en la fuerza del flujo para que aparezcan ya con velocidad normal
          // Calcular velocidad inicial basada en la fuerza promedio del flujo
          // Simula que la partícula ya ha estado acelerándose por un tiempo
          const flowForceAvg = (CONFIG.physics.flowForceMin + CONFIG.physics.flowForceMax) / 2;
          // Velocidad inicial: simula ~1 segundo de aceleración previa hacia abajo
          // v = a * t, donde a = F/m y t = tiempo de aceleración
          const accelerationTime = 1.0; // 1 segundo de aceleración previa
          const acceleration = flowForceAvg / body.mass; // a = F/m
          const initialVelocityY = acceleration * accelerationTime;
          
          Body.setVelocity(body, {
            x: 0, // Sin velocidad horizontal inicial
            y: Math.max(0.02, initialVelocityY), // Caer hacia abajo visualmente = aumentar Y en canvas coords (positivo)
          });
          
          Composite.add(engine.world, body);
          state.allBodies.push(body);
        }

        return body;
      }

      // Variables para tracking de spawn
      let spawnStats = {
        lastSpawnCount: 0,
        totalSpawned: 0,
        spawnHistory: [], // Últimos 10 conteos de spawn
      };

      function startParticleSpawning() {
        // Clear any existing timeout
        if (spawnInterval !== null) {
          clearTimeout(spawnInterval);
          spawnInterval = null;
        }
        // spawnIntervalCounter removido

        lastSpawnTime = performance.now();
        actualSpawnIntervals = [];
        spawnStats = {
          lastSpawnCount: 0,
          totalSpawned: 0,
          spawnHistory: [],
        };

        // Función para spawnear partículas
        const spawnParticles = () => {
          // Solo spawnear si la simulación está corriendo
          if (!state.simulationRunning) {
            return;
          }

          const currentTime = performance.now();
          const actualInterval = currentTime - lastSpawnTime;

          // Registrar el intervalo real para el contador
          actualSpawnIntervals.push(actualInterval);
          if (actualSpawnIntervals.length > 20) {
            actualSpawnIntervals.shift(); // Mantener solo los últimos 20
          }

          let spawnedThisCycle = 0;

          // Spawn constante: siempre generar partículas sin verificar límites
            const conditionConfig = CONFIG.conditions[state.condition];
            const plateletRatio = conditionConfig.plateletRatio;

            // Apply spawn rate multiplier for conditions like thrombocytopenia
            const spawnMultiplier = conditionConfig.spawnRateMultiplier || 1.0;
            const spawnCount = Math.max(
              1,
              Math.floor(CONFIG.particles.spawnRate * spawnMultiplier)
            );

            for (let i = 0; i < spawnCount; i++) {
              const rand = Math.random();

              if (rand < plateletRatio) {
                createParticle("platelet");
                spawnedThisCycle++;
              } else if (rand < plateletRatio + CONFIG.particles.rbcRatio) {
                createParticle("rbc");
                spawnedThisCycle++;
              } else {
                createParticle("wbc");
                spawnedThisCycle++;
            }
          }

          // Registrar estadísticas de spawn
          spawnStats.lastSpawnCount = spawnedThisCycle;
          spawnStats.totalSpawned += spawnedThisCycle;
          spawnStats.spawnHistory.push(spawnedThisCycle);
          if (spawnStats.spawnHistory.length > 10) {
            spawnStats.spawnHistory.shift();
          }

          lastSpawnTime = currentTime;
        };

        // Función recursiva que mantiene intervalo constante en tiempo real (8-10 partículas/segundo)
        const scheduleNextSpawn = () => {
          if (!state.simulationRunning) return;

          // Intervalo variable entre 100-150ms (promedio 125ms) - siempre constante en tiempo real
          // Esto garantiza 8-10 partículas por segundo independientemente de la velocidad de simulación
          const variableInterval = 100 + Math.random() * 50; // 100-150ms

          spawnInterval = setTimeout(() => {
            spawnParticles();
            scheduleNextSpawn(); // Programar siguiente spawn con nuevo intervalo
          }, variableInterval);
        };

        // Iniciar el ciclo de spawn solo si la simulación está corriendo
        if (state.simulationRunning) {
          scheduleNextSpawn();
        }

        // Contador de spawn removido
        
        // Resetear el flag de inicialización después de un pequeño delay
        // para permitir que todos los cambios del DOM se completen
        setTimeout(() => {
          isInitializingSimulation = false;
        }, 100);
      }

      function toggleSimulation() {
        if (!state.simulationRunning) {
          // Iniciar simulación
          state.simulationRunning = true;
          state.isPaused = false;
          state.startTime = Date.now();
          state.adhesionTime = null;
          state.closureTime = null;
          state.plateletsSpawned = 0;
          state.history = {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          };
          // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
          lastPhysicsTime = 0;
          accumulatedTime = 0;

          // Asegurar que timeScale tenga un valor válido
          if (!state.timeScale || state.timeScale <= 0) {
            state.timeScale = 1.0;
          }

          // Reiniciar el spawn para asegurar que funcione
          startParticleSpawning();
          
          // Mostrar el label "Lesión Activa" con efecto de pulso
          const woundLabel = document.getElementById("wound-label");
          if (woundLabel) {
            woundLabel.classList.remove("hidden");
            woundLabel.classList.add("active-pulse");
            woundLabel.classList.remove("healed");
            woundLabel.innerHTML = "Lesión Activa";
          }

          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitar botón de inicio cuando está corriendo
          }
          if (pauseBtn) {
            pauseBtn.disabled = false; // Habilitar botón de pausa cuando está corriendo
          }
          
          // Habilitar botón de tratamiento cuando la simulación está corriendo
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied) {
            treatmentBtn.disabled = false;
          }
          
        } else {
          // Pausar simulación
          state.simulationRunning = false;
          state.isPaused = true;
          // No usar Runner.stop() - usamos nuestro propio loop
          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = false; // Habilitar botón de inicio cuando está pausada
          }
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar botón de pausa cuando está pausada
          }
          
          // El botón de tratamiento permanece habilitado cuando la simulación está pausada
          // (siempre que se haya iniciado al menos una vez y no se haya aplicado ya)
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied && state.startTime) {
            treatmentBtn.disabled = false;
          }
          
        }
      }

      function applyForces(timestep = 16.67) {
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Invisible adhesion line parameters - positioned at wound opening
        const adhesionLineY = CONFIG.adhesionLineY; // Y position center of the adhesion zone (more down visually = higher Y in canvas coords)
        const adhesionLineThreshold = 25; // Width of adhesion zone (más ancho para efecto de profundidad)
        const adhesionDetectionThreshold = 8; // Umbral más estricto para detectar adhesión (solo cuando está muy cerca)

        // IMPORTANTE: Con Runner.isFixed = true y delta = 16.67ms,
        // el timestep siempre es constante independientemente del FPS del renderer.
        // El Runner ejecuta pasos de física a intervalos fijos, y cada paso siempre es de 16.67ms.
        // Por lo tanto, timeScale siempre debe ser 1.0 para mantener velocidad constante.
        // NO escalamos por el timestep real porque ya está fijo en 16.67ms.
        const timeScale = 1.0; // Siempre 1.0 porque el timestep es fijo

        state.allBodies.forEach((body) => {
          // Skip stuck platelets and static bodies
          if (body.isStuck || body.isStatic) return;

          // Prevent particles from passing through walls by checking bounds
          const { width, height } = CONFIG.canvas;
          const wallThickness = CONFIG.wall.thickness;
          const particleRadius =
            body.circleRadius ||
            (body.label === "rbc" ? 6 : body.label === "wbc" ? 10 : 4);

          // Check top walls (left and right segments)
          const woundX = CONFIG.wound.x;
          const woundWidth = CONFIG.wound.width;
          const woundLeft = woundX - woundWidth / 2;
          const woundRight = woundX + woundWidth / 2;

          // Check collision near wound area (wound is near bottom of canvas)
          const adhesionLineY = CONFIG.adhesionLineY;
          const woundCollisionThreshold = 15;
          if (body.position.y < adhesionLineY + woundCollisionThreshold && body.position.y > adhesionLineY - woundCollisionThreshold) {
            // Check if particle is in wound area
            if (body.position.x < woundLeft || body.position.x > woundRight) {
              // Outside wound - push away from wound area
              const pushDirection = body.position.y < adhesionLineY ? 1 : -1;
              Body.setPosition(body, {
                x: body.position.x,
                y: adhesionLineY + (woundCollisionThreshold + 1) * pushDirection,
              });
              Body.setVelocity(body, {
                x: body.velocity.x,
                y: body.velocity.y * -0.8,
              });
            }
          }

          // Also check collision with top wall (bottom visually) - removed to allow particles to spawn and fall freely
          // Particles spawn at y=10-40, so they should fall freely without hitting this wall

          // Laminar flow force constante (sin pulso)
          // Usar fuerza promedio constante
          const flowForce = (CONFIG.physics.flowForceMin + CONFIG.physics.flowForceMax) / 2;
          
          // Aplicar fuerza gravitacional constante (hacia abajo visualmente = positivo en canvas coords)
          Body.applyForce(body, body.position, {
                x: 0,
            y: flowForce * body.mass * timeScale, // Hacia abajo visualmente = positivo en canvas coords
              });

          // Fuerza de succión hacia la herida (solo en la mitad superior) - OPTIMIZADO
          const particlePos = body.position;
          
          // Optimización: solo calcular si está arriba de la herida y dentro del área aproximada
          if (particlePos.y < adhesionLineY) {
            const dx = woundX - particlePos.x;
            const dy = adhesionLineY - particlePos.y;
            
            // Optimización: usar distancia al cuadrado para evitar sqrt innecesario
            const distanceSq = dx * dx + dy * dy;
            const suctionRadiusSq = CONFIG.physics.suctionRadius * CONFIG.physics.suctionRadius;
            
            // Aplicar succión solo si está dentro del radio de efecto (comparar distancias al cuadrado)
            if (distanceSq < suctionRadiusSq && distanceSq > 0) {
              // Optimización: calcular sqrt solo una vez cuando realmente se necesita
              const distance = Math.sqrt(distanceSq);
              const invDistance = 1 / distance; // Evitar división repetida
              
              // La fuerza de succión es inversamente proporcional a la distancia
              const baseSuctionStrength = Math.abs(CONFIG.physics.suctionForce) * (1 - distance / CONFIG.physics.suctionRadius);
              
              // Aumentar la fuerza horizontal cuando está más lejos del centro (en los lados)
              // Calcular distancia horizontal desde el centro de la herida
              const horizontalDistance = Math.abs(dx);
              const woundWidth = CONFIG.wound.width;
              // Factor multiplicador: más fuerza horizontal cuando está más lejos del centro
              // Usar una función que aumenta exponencialmente con la distancia horizontal
              const sideMultiplier = 1.0 + (horizontalDistance / (CONFIG.canvas.width / 2)) * 1.0; // Hasta 3x más fuerza en los bordes
              
              const suctionStrength = baseSuctionStrength;
              const horizontalSuctionStrength = baseSuctionStrength * sideMultiplier; // Fuerza horizontal aumentada en los lados
              const massTimeScale = body.mass * timeScale;

              Body.applyForce(body, body.position, {
                x: dx * invDistance * horizontalSuctionStrength * massTimeScale, // Fuerza horizontal aumentada en los lados
                y: dy * invDistance * suctionStrength * massTimeScale, // Fuerza vertical normal
              });
            }
          }

          // FIBRIN NET BOUNCE - Make RBCs and WBCs bounce off fibrin network
          if (
            (body.label === "rbc" || body.label === "wbc") &&
            state.fibrinConstraints.length > 0
          ) {
            const cellRadius = body.label === "rbc" ? 6 : 10;
            const bounceThreshold = cellRadius + 6; // Increased detection threshold
            const bounceStrength = body.label === "rbc" ? 0.008 : 0.012; // Much stronger bounce force
            const cellPos = body.position;

            // Only check fibrin near the wound area for performance
            const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2 - 30;
            const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2 + 30;

            if (
              cellPos.x >= woundLeft &&
              cellPos.x <= woundRight &&
              cellPos.y < 120
            ) {
              for (let i = 0; i < state.fibrinConstraints.length; i++) {
                const fibrin = state.fibrinConstraints[i];
                const pointA = fibrin.pointA.position;
                const pointB = fibrin.pointB.position;

                if (!pointA || !pointB) continue;

                // Quick bounds check - skip if fibrin line is far from cell
                const minX = Math.min(pointA.x, pointB.x);
                const maxX = Math.max(pointA.x, pointB.x);
                const minY = Math.min(pointA.y, pointB.y);
                const maxY = Math.max(pointA.y, pointB.y);

                if (
                  cellPos.x < minX - bounceThreshold ||
                  cellPos.x > maxX + bounceThreshold ||
                  cellPos.y < minY - bounceThreshold ||
                  cellPos.y > maxY + bounceThreshold
                ) {
                  continue;
                }

                // Calculate distance from cell to fibrin line segment
                const lineVec = Vector.sub(pointB, pointA);
                const lineLength = Vector.magnitude(lineVec);

                if (lineLength < 0.1) continue; // Skip very short lines

                const toCell = Vector.sub(cellPos, pointA);
                const lineLengthSq = lineLength * lineLength;
                const t = Math.max(
                  0,
                  Math.min(1, Vector.dot(toCell, lineVec) / lineLengthSq)
                );
                const closestPoint = Vector.add(
                  pointA,
                  Vector.mult(lineVec, t)
                );
                const distVec = Vector.sub(cellPos, closestPoint);
                const distance = Vector.magnitude(distVec);
                const bounceThresholdSq = bounceThreshold * bounceThreshold;
                const distanceSq = distance * distance;

                // If cell is close to fibrin line, apply bounce force (or allow passage if weak)
                if (distanceSq < bounceThresholdSq && distance > 0.1) {
                  // Get fibrin stability - affects barrier effectiveness
                  const fibrinStability = fibrin.stability || 1.0;

                  // Si está sellado, bloquear completamente el paso
                  const passThroughChance = state.hemostasisAchieved
                    ? 0
                    : (1 - fibrinStability) * 0.3; // Up to 30% chance for very weak fibrin

                  if (Math.random() < passThroughChance) {
                    // Cell passes through weak fibrin - reduce velocity slightly
                    Body.setVelocity(body, {
                      x: body.velocity.x * 0.9,
                      y: body.velocity.y * 0.9,
                    });
                    continue; // Skip bounce for this fibrin connection
                  }

                  // Normalize distance vector to get bounce direction
                  const bounceDir = {
                    x: distVec.x / distance,
                    y: distVec.y / distance,
                  };

                  // Calculate velocity component towards the line
                  const velocityDot =
                    body.velocity.x * bounceDir.x +
                    body.velocity.y * bounceDir.y;

                  // Only apply bounce if moving towards the line
                  if (velocityDot < 0) {
                    // Bounce force reduced by stability - weaker fibrin = weaker bounce
                    const proximityFactor = 1 - distance / bounceThreshold;
                    const stabilityMultiplier = 0.3 + fibrinStability * 0.7; // 0.3-1.0 range
                    const bounceForce =
                      bounceStrength *
                      proximityFactor *
                      proximityFactor *
                      stabilityMultiplier;

                    // Scale bounce force by timestep for frame independence (use timeScale from function scope)
                    Body.applyForce(body, body.position, {
                      x: bounceDir.x * bounceForce * body.mass * 10 * timeScale,
                      y: bounceDir.y * bounceForce * body.mass * 10 * timeScale,
                    });

                    // Invert velocity component - effectiveness depends on stability
                    const bounceFactor =
                      0.5 + fibrinStability * 0.3 + proximityFactor * 0.2; // 0.5-1.0 range
                    Body.setVelocity(body, {
                      x:
                        body.velocity.x -
                        bounceDir.x * velocityDot * bounceFactor,
                      y:
                        body.velocity.y -
                        bounceDir.y * velocityDot * bounceFactor,
                    });

                    // Push cell away from the line - less effective for weak fibrin
                    const pushDistance =
                      (bounceThreshold - distance) * 0.3 * fibrinStability;
                    Body.setPosition(body, {
                      x: body.position.x + bounceDir.x * pushDistance,
                      y: body.position.y + bounceDir.y * pushDistance,
                    });
                  }
                }
              }
            }
          }

          // INVISIBLE ADHESION LINE - Check if platelet crosses the invisible line
          if (body.label === "platelet" && !body.isStuck) {
            const inWoundZone =
              body.position.x > woundLeft && body.position.x < woundRight;
            // Usar umbral más estricto para detectar adhesión (solo cuando está muy cerca del centro)
            const distanceFromCenter = Math.abs(
              body.position.y - adhesionLineY
            );
            const nearAdhesionLine = distanceFromCenter < adhesionLineThreshold; // Área amplia para variación
            const veryCloseToCenter = distanceFromCenter < 8; // Solo adherir cuando está muy cerca del centro

            if (inWoundZone && nearAdhesionLine && veryCloseToCenter) {
              const conditionConfig = CONFIG.conditions[state.condition];
              const canStick = state.treatmentApplied
                ? true
                : conditionConfig.canStick;
              // Reducir probabilidad base de adhesión
              const stickProb = state.treatmentApplied
                ? 0.7
                : conditionConfig.stickProbability * 0.3;

              // Check platelet function first
              if (
                !state.treatmentApplied &&
                Math.random() > conditionConfig.plateletFunction
              ) {
                // Platelet dysfunction - let it pass through fibrin network instead of bouncing
                // Reduce restitution to prevent bouncing and allow passage
                body.restitution = 0;
                Body.setVelocity(body, {
                  x: body.velocity.x * 0.95,
                  y: body.velocity.y * 0.95,
                });
                return;
              }

              // Fuerza de adhesión ajustada (un poco más alta que antes)
              const baseAdhesionStrength = state.treatmentApplied
                ? 0.5
                : conditionConfig.adhesionStrength * 0.2;

              // Añadir factor de distancia: más cerca del centro = mayor probabilidad
              // Solo adherir si está muy cerca del centro (dentro de 6px)
              const distanceFactor = Math.max(0.3, 1 - distanceFromCenter / 6); // Factor moderado
              const finalAdhesionStrength =
                baseAdhesionStrength * distanceFactor;

              // Añadir factor de velocidad: plaquetas más lentas tienen mayor probabilidad
              const speed = Math.sqrt(
                body.velocity.x * body.velocity.x +
                  body.velocity.y * body.velocity.y
              );
              const speedFactor = Math.max(0.5, 1 - speed / 0.4); // Factor de velocidad moderado
              const finalAdhesionWithSpeed =
                finalAdhesionStrength * speedFactor;

              if (canStick && Math.random() < finalAdhesionWithSpeed) {
                // Stick to the invisible line
                stickPlateletToLine(body, adhesionLineY, conditionConfig);
              } else if (
                !state.treatmentApplied &&
                conditionConfig.adhesionRetryChance
              ) {
                // Retry adhesion chance
                setTimeout(() => {
                  if (
                    !body.isStuck &&
                    Math.random() < conditionConfig.adhesionRetryChance
                  ) {
                    if (canStick && Math.random() < adhesionStrength) {
                      stickPlateletToLine(body, adhesionLineY, conditionConfig);
                    }
                  }
                }, 100);
              } else {
                // Las plaquetas que no se adhieren atraviesan la malla en lugar de rebotar
                // Reducir restitution para evitar rebotes y permitir paso
                body.restitution = 0;
                Body.setVelocity(body, {
                  x: body.velocity.x * 0.95,
                  y: body.velocity.y * 0.95,
                });
              }
            }
          }
        });

        // For hemophilia and conditions with unstable fibrin - apply extra force to dislodge weakly attached platelets
        const conditionConfig = CONFIG.conditions[state.condition];
        if (
          (state.condition === "hemophilia" ||
            state.condition === "hemophiliaSevere" ||
            conditionConfig.fibrinStability < 0.5) &&
          !state.treatmentApplied
        ) {
          state.stuckPlatelets.forEach((platelet) => {
            if (
              !platelet.hasFibrin ||
              platelet.fibrinConnections.length === 0
            ) {
              // Gradually increase dislodge force for platelets without fibrin support - scaled by timestep
              const dislodgeForce =
                0.00015 * (1 - conditionConfig.fibrinStability);
              Body.applyForce(platelet.body, platelet.body.position, {
                x: 0,
                y:
                  -dislodgeForce *
                  platelet.body.mass *
                  (1 + Math.random()) *
                  timeScale,
              });
            }
          });
        }
      }

      function stickPlateletToLine(platelet, lineY, conditionConfig) {
        if (platelet.isStuck) return;

        platelet.isStuck = true;

        // Apply visual effects based on condition
        const visualEffects =
          conditionConfig.visualEffects ||
          CONFIG.conditions.normal.visualEffects;
        platelet.render.fillStyle = visualEffects.plateletColor || "#808080";

        // Stop movement and position within the adhesion zone (efecto de profundidad)
        Body.setVelocity(platelet, { x: 0, y: 0 });
        // Variar la posición Y dentro del área de adhesión para crear profundidad
        // Las plaquetas pueden adherirse en un rango simétrico alrededor de la línea central
        const adhesionZoneHalfWidth = 12; // Mitad del ancho del área de adhesión
        const adhesionZoneTop = lineY - adhesionZoneHalfWidth;
        const adhesionZoneBottom = lineY + adhesionZoneHalfWidth;
        // Posición aleatoria dentro del área de adhesión, con distribución normal centrada
        // Usar la posición actual de la plaqueta como referencia, pero limitada al área de adhesión
        const currentY = platelet.position.y;
        const targetY = Math.max(
          adhesionZoneTop,
          Math.min(adhesionZoneBottom, currentY)
        );
        // Añadir pequeña variación aleatoria para efecto de profundidad
        const randomVariation = (Math.random() - 0.5) * 4; // Variación de ±2 píxeles
        const stickY = Math.max(
          adhesionZoneTop,
          Math.min(adhesionZoneBottom, targetY + randomVariation)
        );
        Body.setPosition(platelet, { x: platelet.position.x, y: stickY });

        // Make platelet completely static so it doesn't move
        Body.setStatic(platelet, true);

        // Create constraint to the adhesion point - maximum stiffness
        const constraint = Constraint.create({
          bodyA: platelet,
          pointB: { x: platelet.position.x, y: stickY },
          stiffness: 1.0, // Maximum stiffness
          damping: 1.0, // Maximum damping
          length: 0,
          render: { visible: false },
        });

        Composite.add(engine.world, constraint);

        const plateletData = {
          body: platelet,
          constraint: constraint,
          hasFibrin: false,
          fibrinConnections: [],
          condition: state.condition,
          stuckAt: Date.now(), // Timestamp para identificar las más antiguas
          isAnchor: false,
        };

        state.stuckPlatelets.push(plateletData);

        // Rastrear primera adhesión
        if (!state.adhesionTime && state.startTime) {
          state.adhesionTime = Date.now();
        }

        // Limitar el número de plaquetas pegadas para mantener rendimiento
        cleanupOldStuckPlatelets();

        // El cartel "Lesión Activa" permanece visible hasta que la herida esté sellada
        // Solo se oculta cuando se logra la hemostasia completa

        // Secuencia: plaquetas primero, luego malla
        // Activar formación de fibrina solo después de umbral de plaquetas
        // Con tratamiento, reducir el umbral mínimo de plaquetas
        const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
        if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
          state.fibrinStarted = true;

          // Try to form fibrin after delay if specified
          // Con tratamiento, reducir significativamente el delay
          const baseDelay = conditionConfig.fibrinFormationDelay || 150;
          const delay = state.treatmentApplied
            ? Math.max(50, baseDelay * 0.3)
            : baseDelay;
          setTimeout(() => {
            if (state.stuckPlatelets.includes(plateletData)) {
              tryFormFibrin(plateletData);

              // Also try to form fibrin from nearby anchor platelets
              state.stuckPlatelets.forEach((other) => {
                if (other.isAnchor && other.body) {
                  const dist = Vector.magnitude(
                    Vector.sub(plateletData.body.position, other.body.position)
                  );
                  if (dist < 80) {
                    tryFormFibrin(other);
                  }
                }
              });
            }
          }, delay);
        }
      }

      function cleanupOldStuckPlatelets() {
        const maxStuckPlatelets = CONFIG.stuckPlatelets.maxCount;

        // Si no excedemos el límite, no hacer nada
        if (state.stuckPlatelets.length <= maxStuckPlatelets) {
          return;
        }

        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const woundAreaMargin = 100; // Margen alrededor de la herida para considerar "relevante"

        // Ordenar plaquetas pegadas por timestamp (más antiguas primero)
        // Pero excluir las anchor platelets y las que están cerca de la herida
        const plateletsToConsider = state.stuckPlatelets
          .filter((p) => !p.isAnchor) // No eliminar anchor platelets
          .map((p) => ({
            data: p,
            distance: Math.abs(p.body.position.x - woundX),
            isNearWound:
              p.body.position.x >= woundLeft - woundAreaMargin &&
              p.body.position.x <= woundRight + woundAreaMargin &&
              p.body.position.y >= 20 &&
              p.body.position.y <= 100,
          }))
          .sort((a, b) => {
            // Priorizar eliminar las que están lejos de la herida
            if (a.isNearWound && !b.isNearWound) return 1;
            if (!a.isNearWound && b.isNearWound) return -1;
            // Si ambas están cerca o lejos, ordenar por timestamp (más antiguas primero)
            return (a.data.stuckAt || 0) - (b.data.stuckAt || 0);
          });

        // Calcular cuántas necesitamos eliminar
        const toRemove = state.stuckPlatelets.length - maxStuckPlatelets;

        // Eliminar las más antiguas que están lejos de la herida
        for (let i = 0; i < toRemove && i < plateletsToConsider.length; i++) {
          const plateletData = plateletsToConsider[i].data;

          // Eliminar constraints de fibrina conectados
          for (let j = state.fibrinConstraints.length - 1; j >= 0; j--) {
            const fibrin = state.fibrinConstraints[j];
            if (
              fibrin.pointA === plateletData.body ||
              fibrin.pointB === plateletData.body
            ) {
              removeFibrinConnection(fibrin);
            }
          }

          // Eliminar constraint de la plaqueta
          if (plateletData.constraint) {
            Composite.remove(engine.world, plateletData.constraint);
          }

          // Eliminar el body
          Composite.remove(engine.world, plateletData.body);

          // Eliminar de la lista
          const index = state.stuckPlatelets.indexOf(plateletData);
          if (index > -1) {
            state.stuckPlatelets.splice(index, 1);
          }

          // Eliminar de allBodies
          const bodyIndex = state.allBodies.indexOf(plateletData.body);
          if (bodyIndex > -1) {
            state.allBodies.splice(bodyIndex, 1);
          }
        }
      }

      function cleanupParticles() {
        const toRemove = [];
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const adhesionLineY = CONFIG.adhesionLineY; // Posición de la herida

        // Optimized cleanup: iterate backwards for better performance when removing
        for (let i = state.allBodies.length - 1; i >= 0; i--) {
          const body = state.allBodies[i];
          const px = body.position.x;
          const py = body.position.y;

          // Solo eliminar partículas móviles (no pegadas) en la limpieza básica
          const isStuck = state.stuckPlatelets.some((p) => p.body === body);

          if (!isStuck) {
            // Verificar duración de vida de 10 segundos
            if (body.createdAt) {
              const age = (performance.now() - body.createdAt) / 1000; // Edad en segundos
              if (age >= 10) {
                toRemove.push(body);
                continue; // Ya marcada para eliminar, no verificar otras condiciones
              }
            }
            
            // Remove particles that exit right (eliminar cuando salen completamente del canvas)
            if (px > CONFIG.canvas.width + 20) {
              toRemove.push(body);
            }
            // Remove particles way off screen (left side)
            else if (px < -30) {
              toRemove.push(body);
            }
            // Remove particles that exit bottom visually (top in canvas coords, outside screen)
            else if (py < -20) {
              toRemove.push(body);
            }
            // Remove particles that have passed through the wound and reached the bottom
            // Particles that are below the wound (adhesionLineY) and reach the bottom disappear
            // Solo eliminar si están realmente fuera del canvas (más allá del borde inferior)
            else if (py > adhesionLineY + 50 && py > CONFIG.canvas.height + 20) {
              toRemove.push(body);
              state.bloodLoss++;
            }
          }
        }

        // Optimized removal: use Map for faster lookups
        const bodySet = new Set(toRemove);

        toRemove.forEach((body) => {
          // Remove associated constraints if it's a stuck platelet
          const plateletIndex = state.stuckPlatelets.findIndex(
            (p) => p.body === body
          );
          if (plateletIndex !== -1) {
            const plateletData = state.stuckPlatelets[plateletIndex];

            // Remove fibrin constraints connected to this platelet (iterate backwards)
            for (let i = state.fibrinConstraints.length - 1; i >= 0; i--) {
              const fibrin = state.fibrinConstraints[i];
              if (fibrin.pointA === body || fibrin.pointB === body) {
                removeFibrinConnection(fibrin);
              }
            }

            // Remove platelet constraint
            if (plateletData.constraint) {
              Composite.remove(engine.world, plateletData.constraint);
            }

            // Remove from stuck platelets list (but not anchor platelets)
            if (!plateletData.isAnchor) {
              state.stuckPlatelets.splice(plateletIndex, 1);
            }
          }

          Composite.remove(engine.world, body);
        });

        // Remove from allBodies array (more efficient)
        state.allBodies = state.allBodies.filter((b) => !bodySet.has(b));

        // Limpieza agresiva: eliminar partículas que están cerca del borde derecho
        // Esto asegura que las partículas se eliminen antes de llegar al límite máximo
        const aggressiveCleanupThreshold = CONFIG.particles.maxCount * 0.7; // 70% del límite (105 partículas)
        if (state.allBodies.length > aggressiveCleanupThreshold) {
          const additionalToRemove = [];

          for (let i = state.allBodies.length - 1; i >= 0; i--) {
            const body = state.allBodies[i];
            if (!body || !body.position) continue;

            const px = body.position.x;
            const py = body.position.y;

            // Solo eliminar partículas móviles (no pegadas)
            const isStuck = state.stuckPlatelets.some((p) => p.body === body);
            if (isStuck) continue;

            // Eliminar partículas que están muy cerca del borde derecho (dentro de 30px del final)
            if (px > CONFIG.canvas.width - 30) {
              additionalToRemove.push(body);
            }
            // También eliminar partículas que han atravesado la herida y están muy abajo visualmente
            const adhesionLineY = CONFIG.adhesionLineY;
            if (py > adhesionLineY + 20 && py > CONFIG.canvas.height - 10) {
              additionalToRemove.push(body);
            }
          }

          // Eliminar las partículas adicionales encontradas
          additionalToRemove.forEach((body) => {
            try {
              Composite.remove(engine.world, body);
              const index = state.allBodies.indexOf(body);
              if (index > -1) {
                state.allBodies.splice(index, 1);
              }
            } catch (e) {
              // Ignorar errores si el body ya fue eliminado
            }
          });
        }
      }

      function setupCollisionEvents() {
        Events.on(engine, "collisionStart", (event) => {
          event.pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            // Check for platelet collision with wound edges or stuck platelets
            handlePlateletCollision(bodyA, bodyB);
            handlePlateletCollision(bodyB, bodyA);

            // Handle weak fibrin barrier collisions - allow occasional passage
            handleFibrinBarrierCollision(bodyA, bodyB);
            handleFibrinBarrierCollision(bodyB, bodyA);
          });
        });
      }

      function handleFibrinBarrierCollision(cell, barrier) {
        // Check if cell (RBC/WBC) collides with fibrin barrier
        if (
          (cell.label !== "rbc" && cell.label !== "wbc") ||
          barrier.label !== "fibrinBarrier"
        ) {
          return;
        }

        // Get fibrin stability from barrier
        const fibrinStability = barrier.fibrinStability || 1.0;

        // Si está sellado, bloquear completamente el paso
        if (state.hemostasisAchieved) {
          return; // No permitir paso cuando está sellado
        }

        // Weak fibrin occasionally allows cells to pass through
        if (fibrinStability < 0.6) {
          const passThroughChance = (1 - fibrinStability) * 0.4; // Up to 40% chance for very weak fibrin

          if (Math.random() < passThroughChance) {
            // Allow cell to pass through - make barrier temporarily non-collidable
            barrier.collisionFilter.mask = 0x0000; // No collisions

            // Restore collision after a short time
            setTimeout(() => {
              if (barrier.label === "fibrinBarrier") {
                barrier.collisionFilter.mask = 0x0001;
              }
            }, 500);

            // Reduce cell velocity slightly as it passes through
            Body.setVelocity(cell, {
              x: cell.velocity.x * 0.85,
              y: cell.velocity.y * 0.85,
            });
          } else {
            // Reduce bounce effectiveness for weak fibrin
            const bounceReduction = 1 - fibrinStability;
            Body.setVelocity(cell, {
              x: cell.velocity.x * (1 - bounceReduction * 0.3),
              y: cell.velocity.y * (1 - bounceReduction * 0.3),
            });
          }
        }
      }

      function handlePlateletCollision(platelet, other) {
        if (platelet.label !== "platelet" || platelet.isStuck) return;

        const conditionConfig = CONFIG.conditions[state.condition];

        // Check platelet function first
        if (
          !state.treatmentApplied &&
          Math.random() > conditionConfig.plateletFunction
        ) {
          // Platelet dysfunction - let it pass through instead of bouncing
          // Reduce restitution to prevent bouncing and allow passage
          platelet.restitution = 0;
          Body.setVelocity(platelet, {
            x: platelet.velocity.x * 0.95,
            y: platelet.velocity.y * 0.95,
          });
          return;
        }

        const canStick = state.treatmentApplied
          ? true
          : conditionConfig.canStick;
        const adhesionStrength = state.treatmentApplied
          ? 0.95
          : conditionConfig.adhesionStrength;

        // Check if collision is with wound edge or stuck platelet
        const isWoundEdge = other.label === "woundEdge";
        const isStuckPlatelet = other.label === "platelet" && other.isStuck;

        if (isWoundEdge || isStuckPlatelet) {
          // Check if in wound zone
          const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
          const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;

          // Solo permitir adhesión cuando está cerca de la línea de adhesión (herida)
          const adhesionLineY = CONFIG.adhesionLineY;
          const adhesionThreshold = 30; // Distancia máxima desde la línea de adhesión
          const distanceFromAdhesionLine = Math.abs(platelet.position.y - adhesionLineY);

          if (
            platelet.position.x >= woundLeft - 20 &&
            platelet.position.x <= woundRight + 20 &&
            distanceFromAdhesionLine < adhesionThreshold
          ) {
            // Check aggregation rate for platelet-to-platelet adhesion
            // En vWD sin tratamiento, las plaquetas no se agregan (no hay cemento vWF)
            if (isStuckPlatelet) {
              const aggregationRate = state.treatmentApplied
                ? 0.9
                : conditionConfig.aggregationRate;
              if (Math.random() > aggregationRate) {
                // Failed aggregation - plaquetas rebotan/se separan (sin cemento vWF)
                platelet.restitution = 0.9;
                // En vWD, rebote más fuerte para simular que no hay cemento
                const bounceStrength =
                  state.condition === "vwd" && !state.treatmentApplied
                    ? 1.5
                    : 1.0;
                Body.setVelocity(platelet, {
                  x: platelet.velocity.x * (0.8 * bounceStrength),
                  y: Math.abs(platelet.velocity.y) * (1.2 * bounceStrength) + 1,
                });
                return;
              }
            }

            if (canStick && Math.random() < adhesionStrength) {
              stickPlatelet(platelet, other, conditionConfig);
            } else if (
              !state.treatmentApplied &&
              conditionConfig.adhesionRetryChance
            ) {
              // Retry adhesion chance
              setTimeout(() => {
                if (
                  !platelet.isStuck &&
                  Math.random() < conditionConfig.adhesionRetryChance
                ) {
                  if (canStick && Math.random() < adhesionStrength) {
                    stickPlatelet(platelet, other, conditionConfig);
                  }
                }
              }, 100);
            } else {
              // Las plaquetas que no se adhieren atraviesan en lugar de rebotar
              // Reducir restitution para evitar rebotes y permitir paso
              platelet.restitution = 0;
              Body.setVelocity(platelet, {
                x: platelet.velocity.x * 0.95,
                y: platelet.velocity.y * 0.95,
              });
            }
          }
        }
      }

      function stickPlatelet(platelet, anchor, conditionConfig) {
        if (platelet.isStuck) return;

        platelet.isStuck = true;

        // Apply visual effects based on condition
        const visualEffects =
          conditionConfig.visualEffects ||
          CONFIG.conditions.normal.visualEffects;
        platelet.render.fillStyle = visualEffects.plateletColor || "#808080";

        // Stop movement completely
        Body.setVelocity(platelet, { x: 0, y: 0 });

        // Make platelet completely static so it doesn't move
        Body.setStatic(platelet, true);

        // Create constraint to anchor point - maximum stiffness
        const constraint = Constraint.create({
          bodyA: platelet,
          pointB: anchor.isStatic
            ? { x: anchor.position.x, y: anchor.position.y }
            : null,
          bodyB: anchor.isStatic ? null : anchor,
          stiffness: 1.0, // Maximum stiffness
          damping: 1.0, // Maximum damping
          length: 0,
          render: { visible: false },
        });

        Composite.add(engine.world, constraint);

        const plateletData = {
          body: platelet,
          constraint: constraint,
          hasFibrin: false,
          fibrinConnections: [],
          condition: state.condition,
          stuckAt: Date.now(), // Timestamp para identificar las más antiguas
          isAnchor: false,
        };

        state.stuckPlatelets.push(plateletData);

        // Rastrear primera adhesión
        if (!state.adhesionTime && state.startTime) {
          state.adhesionTime = Date.now();
        }

        // Limitar el número de plaquetas pegadas para mantener rendimiento
        cleanupOldStuckPlatelets();

        // El cartel "Lesión Activa" permanece visible hasta que la herida esté sellada
        // Solo se oculta cuando se logra la hemostasia completa

        // Secuencia: plaquetas primero, luego malla
        // Activar formación de fibrina solo después de umbral de plaquetas
        // Con tratamiento, reducir el umbral mínimo de plaquetas
        const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
        if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
          state.fibrinStarted = true;

          // Try to form fibrin with delay if specified
          // Con tratamiento, reducir significativamente el delay
          const baseDelay = conditionConfig.fibrinFormationDelay || 100;
          const delay = state.treatmentApplied
            ? Math.max(50, baseDelay * 0.3)
            : baseDelay;
          setTimeout(() => {
            if (state.stuckPlatelets.includes(plateletData)) {
              tryFormFibrin(plateletData);
            }
          }, delay);
        }
      }

      function tryFormFibrin(plateletData) {
        const conditionConfig = CONFIG.conditions[state.condition];
        const canFormFibrin = state.treatmentApplied
          ? true
          : conditionConfig.canFormFibrin;

        if (!canFormFibrin) return;

        // Secuencia: plaquetas primero, luego malla - solo formar si ya empezó la formación
        if (!state.fibrinStarted) return;

        // Check fibrin formation rate
        const fibrinRate = state.treatmentApplied
          ? 1.0
          : conditionConfig.fibrinFormationRate; // Note: keeping config name as is
        if (Math.random() > fibrinRate) {
          return; // Failed to form fibrin this time
        }

        // Limit total fibrin connections
        if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections)
          return;

        // Limit connections per platelet
        if (
          plateletData.fibrinConnections.length >=
          CONFIG.fibrin.maxConnectionsPerPlatelet
        )
          return;

        // Check max cluster size for thrombasthenia
        if (conditionConfig.maxPlateletClusterSize) {
          const nearbyCount = state.stuckPlatelets.filter((p) => {
            const dx = p.body.position.x - plateletData.body.position.x;
            const dy = p.body.position.y - plateletData.body.position.y;
            return dx * dx + dy * dy < 400 && p.fibrinConnections.length > 0;
          }).length;
          if (nearbyCount >= conditionConfig.maxPlateletClusterSize) {
            return; // Cannot form larger clusters
          }
        }

        const platelet = plateletData.body;

        // Get fibrin stability from condition - affects connection distance
        const fibrinStability = state.treatmentApplied
          ? 1.0
          : conditionConfig.fibrinStability;

        // When fibrin is weaker, platelets must be closer to form connections
        // Strong fibrin (1.0): can connect up to 90px away, minimum 20px
        // Weak fibrin (0.3): can connect up to 40px away, minimum 8px
        // El tratamiento NO afecta la distancia de conexión, solo la velocidad de adhesión
        const baseMaxSearchRadius = 40 + fibrinStability * 50; // 40-90px range
        const maxSearchRadius = baseMaxSearchRadius; // Distancia fija, no afectada por tratamiento
        const minDistance = 8 + fibrinStability * 12; // 8-20px range
        const minDistanceSq = minDistance * minDistance;

        const plateletX = platelet.position.x;
        const plateletY = platelet.position.y;

        // Find nearby stuck platelets (optimized with early exit)
        for (let i = 0; i < state.stuckPlatelets.length; i++) {
          const other = state.stuckPlatelets[i];
          if (other.body === platelet) continue;
          if (plateletData.fibrinConnections.includes(other.body.id)) continue;

          // Limit connections per other platelet too
          if (
            other.fibrinConnections.length >=
            CONFIG.fibrin.maxConnectionsPerPlatelet
          )
            continue;

          // Quick distance check using squared distance (avoid sqrt)
          const dx = other.body.position.x - plateletX;
          const dy = other.body.position.y - plateletY;
          const distSq = dx * dx + dy * dy;
          const searchRadiusSq = maxSearchRadius * maxSearchRadius;

          if (distSq < searchRadiusSq && distSq > minDistanceSq) {
            const dist = Math.sqrt(distSq);

            // Clasificar tipo de cuerda según distancia y estabilidad
            let fibrinType = "thin"; // Por defecto pequeña
            if (dist < 30 && fibrinStability > 0.7) {
              fibrinType = "thick"; // Gruesa: distancia < 30px y estabilidad alta
            } else if (dist < 60 && fibrinStability > 0.4) {
              fibrinType = "medium"; // Mediana: distancia 30-60px y estabilidad media
            }

            // Verificar restricciones según condición
            const canFormThick = !conditionConfig.blockThickCords;
            const canFormMedium = !conditionConfig.blockMediumCords;
            const canFormThin = !conditionConfig.blockThinCords;

            if (
              (fibrinType === "thick" && !canFormThick) ||
              (fibrinType === "medium" && !canFormMedium) ||
              (fibrinType === "thin" && !canFormThin)
            ) {
              continue; // Saltar esta conexión si está bloqueada
            }

            const visualEffects =
              conditionConfig.visualEffects ||
              CONFIG.conditions.normal.visualEffects;

            // Create fibrin constraint with stability-based properties
            const fibrinConstraint = Constraint.create({
              bodyA: platelet,
              bodyB: other.body,
              stiffness: 0.9 * fibrinStability,
              damping: 0.3 * (2 - fibrinStability),
              length: dist * 0.8,
              render: { visible: false },
            });

            Composite.add(engine.world, fibrinConstraint);

            // Create physical body for fibrin barrier (thin rectangle)
            const midX = (platelet.position.x + other.body.position.x) / 2;
            const midY = (platelet.position.y + other.body.position.y) / 2;
            const angle = Math.atan2(
              other.body.position.y - platelet.position.y,
              other.body.position.x - platelet.position.x
            );

            // Create a thin rectangular body as barrier
            // Thickness depends on stability - weaker fibrin = thinner barrier
            const barrierThickness = 2 + fibrinStability * 3; // 2-5px range
            const fibrinBody = Bodies.rectangle(
              midX,
              midY,
              dist,
              barrierThickness,
              {
                isStatic: true, // Static so it acts as a solid barrier
                render: {
                  fillStyle: "transparent", // Invisible, we render it separately
                  visible: false,
                },
                label: "fibrinBarrier",
                restitution: 0.9 * fibrinStability, // Stability affects bounce
                friction: 0.1,
                collisionFilter: {
                  group: 0,
                  category: 0x0002, // Separate category for fibrin
                  mask: 0x0001, // Only collide with RBCs and WBCs
                },
                // Store stability for collision handling
                fibrinStability: fibrinStability,
              }
            );

            Body.setAngle(fibrinBody, angle);
            Composite.add(engine.world, fibrinBody);

            const fibrinData = {
              constraint: fibrinConstraint,
              pointA: platelet,
              pointB: other.body,
              body: fibrinBody,
              glowing: state.treatmentApplied,
              stability: fibrinStability,
              decayRate: conditionConfig.fibrinDecayRate || 0,
              visualColor: "#FFFFFF", // Blanco para las cuerdas (solo la malla horizontal es morada)
              opacity: visualEffects.fibrinOpacity || 1.0,
              fibrinType: fibrinType, // 'thick', 'medium', o 'thin'
              createdAt: Date.now(),
            };

            state.fibrinConstraints.push(fibrinData);
            state.fibrinBodies.push(fibrinBody);

            plateletData.fibrinConnections.push(other.body.id);
            plateletData.hasFibrin = true;
            other.fibrinConnections.push(platelet.id);
            other.hasFibrin = true;

            // Schedule fibrin decay if condition has decay rate
            if (
              conditionConfig.fibrinDecayRate > 0 &&
              !state.treatmentApplied
            ) {
              scheduleFibrinDecay(fibrinData, conditionConfig.fibrinDecayRate);
            }

            // Stop if we've reached the limit
            if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections)
              break;
          }
        }

        // Check if wound is sealed after forming new fibrin connection
        checkWoundSealed();
      }

      function scheduleFibrinDecay(fibrinData, decayRate) {
        // Decay fibrin over time based on decay rate
        const decayInterval = setInterval(() => {
          if (!state.fibrinConstraints.includes(fibrinData)) {
            clearInterval(decayInterval);
            return;
          }

          // Reduce stability over time
          fibrinData.stability -= decayRate * 0.1;

          if (fibrinData.stability <= 0.1 || Math.random() < decayRate) {
            // Remove unstable fibrin
            removeFibrinConnection(fibrinData);
            clearInterval(decayInterval);
          } else {
            // Update constraint properties based on stability
            fibrinData.constraint.stiffness = 0.9 * fibrinData.stability;
            fibrinData.constraint.damping = 0.3 * (2 - fibrinData.stability);
          }
        }, 2000); // Check every 2 seconds
      }

      function removeFibrinConnection(fibrinData) {
        // Remove from world
        Composite.remove(engine.world, fibrinData.constraint);
        if (fibrinData.body) {
          Composite.remove(engine.world, fibrinData.body);
          state.fibrinBodies = state.fibrinBodies.filter(
            (b) => b !== fibrinData.body
          );
        }

        // Remove from arrays
        state.fibrinConstraints = state.fibrinConstraints.filter(
          (f) => f !== fibrinData
        );

        // Update platelet connections
        const plateletA = state.stuckPlatelets.find(
          (p) => p.body === fibrinData.pointA
        );
        const plateletB = state.stuckPlatelets.find(
          (p) => p.body === fibrinData.pointB
        );

        if (plateletA) {
          plateletA.fibrinConnections = plateletA.fibrinConnections.filter(
            (id) => id !== fibrinData.pointB.id
          );
          plateletA.hasFibrin = plateletA.fibrinConnections.length > 0;
        }
        if (plateletB) {
          plateletB.fibrinConnections = plateletB.fibrinConnections.filter(
            (id) => id !== fibrinData.pointA.id
          );
          plateletB.hasFibrin = plateletB.fibrinConnections.length > 0;
        }
      }

      function checkWoundSealed() {
        if (state.hemostasisAchieved) return; // Already sealed

        const conditionConfig = CONFIG.conditions[state.condition];
        // En condiciones patológicas, requerir tratamiento para sellado completo
        if (conditionConfig.requiresTreatment && !state.treatmentApplied) {
          return; // No sellar sin tratamiento
        }

        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const adhesionLineY = CONFIG.adhesionLineY; // Y position where platelets stick (herida)
        const woundCenterY = adhesionLineY; // Usar la posición real de la herida

        // Find platelets on the left side of the wound (including anchor platelets)
        const leftSidePlatelets = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          // Include anchor platelets or platelets near left edge
          return (
            (p.isAnchor && px < woundLeft) ||
            (px < woundLeft + 30 && Math.abs(py - woundCenterY) < 20)
          );
        });

        // Find platelets on the right side of the wound (including anchor platelets)
        const rightSidePlatelets = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          // Include anchor platelets or platelets near right edge
          return (
            (p.isAnchor && px > woundRight) ||
            (px > woundRight - 30 && Math.abs(py - woundCenterY) < 20)
          );
        });

        if (leftSidePlatelets.length === 0 || rightSidePlatelets.length === 0) {
          return; // Need platelets on both sides
        }

        // Check if there's a path from left to right through fibrin connections
        for (let i = 0; i < leftSidePlatelets.length; i++) {
          const leftPlatelet = leftSidePlatelets[i];
          if (hasPathToRight(leftPlatelet, rightSidePlatelets, new Set())) {
            // Wound is sealed!
            state.hemostasisAchieved = true;
            state.clotPercentage = 100;
            // Capturar el momento del cierre de la herida (tiempo de simulación acumulado)
            if (!state.closureTime && state.startTime) {
              state.closureTime = accumulatedSimulationTime / 1000; // Guardar tiempo de simulación en segundos
            }
            const woundLabel = document.getElementById("wound-label");
            woundLabel.classList.remove("active-pulse");
            woundLabel.classList.add("healed");
            woundLabel.innerHTML = "Lesión Sellada";
            
            // Agregar efecto de pulsación al botón de reiniciar
            const resetBtn = document.getElementById("reset-btn");
            if (resetBtn) {
              resetBtn.classList.add("hemostasis-pulse");
            }
            
            updateUI();
            return;
          }
        }
      }

      function hasPathToRight(currentPlatelet, rightSidePlatelets, visited) {
        // Check if current platelet is on the right side
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;

        if (currentPlatelet.body.position.x > woundRight - 20) {
          return true; // Reached right side
        }

        // Mark as visited
        visited.add(currentPlatelet.body.id);

        // Check all fibrin connections from this platelet
        for (let i = 0; i < state.fibrinConstraints.length; i++) {
          const fibrin = state.fibrinConstraints[i];
          let connectedPlatelet = null;

          // Find which platelet is connected to current one
          if (fibrin.pointA === currentPlatelet.body) {
            connectedPlatelet = state.stuckPlatelets.find(
              (p) => p.body === fibrin.pointB
            );
          } else if (fibrin.pointB === currentPlatelet.body) {
            connectedPlatelet = state.stuckPlatelets.find(
              (p) => p.body === fibrin.pointA
            );
          }

          if (connectedPlatelet && !visited.has(connectedPlatelet.body.id)) {
            // Check if this connection crosses the wound area
            const px1 = currentPlatelet.body.position.x;
            const px2 = connectedPlatelet.body.position.x;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;

            // Connection crosses wound if one point is left and other is right
            if (
              (px1 < woundLeft && px2 > woundRight) ||
              (px2 < woundLeft && px1 > woundRight)
            ) {
              // Direct crossing found
              return true;
            }

            // Continue searching through this connection
            if (
              hasPathToRight(connectedPlatelet, rightSidePlatelets, visited)
            ) {
              return true;
            }
          }
        }

        return false;
      }

      // ==================== RENDERIZADO DEL VASO SANGUÍNEO ====================

      // Cache para el fondo del vaso (se genera una vez y se reutiliza)
      let vesselBackgroundCache = null;

      function renderVesselBackground(event) {
        const ctx = render.context;
        // Usar las dimensiones lógicas del canvas (tamaño visual)
        const dpr = window.devicePixelRatio || 1;
        const width = CONFIG.canvas.width;
        const height = CONFIG.canvas.height;
        
        ctx.save();
        // El contexto ya está escalado con dpr en updateCanvasSizeGlobal, 
        // así que solo necesitamos resetear la transformación si es necesario
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        // Si el canvas cambió de tamaño, regenerar el cache
        if (
          !vesselBackgroundCache ||
          vesselBackgroundCache.width !== width * dpr ||
          vesselBackgroundCache.height !== height * dpr
        ) {
          const cacheCanvas = document.createElement("canvas");
          // Cache en alta resolución para mejor calidad
          cacheCanvas.width = width * dpr;
          cacheCanvas.height = height * dpr;
          const cacheCtx = cacheCanvas.getContext("2d");
          cacheCtx.scale(dpr, dpr);
          cacheCtx.imageSmoothingEnabled = true;
          cacheCtx.imageSmoothingQuality = "high";

          // Fondo base - gradiente que simula el interior de un vaso sanguíneo
          const baseGradient = cacheCtx.createLinearGradient(0, 0, 0, height);
          baseGradient.addColorStop(0, "#1a0505"); // Muy oscuro arriba (cerca de la pared)
          baseGradient.addColorStop(0.15, "#2a0a0a"); // Transición
          baseGradient.addColorStop(0.35, "#3d1515"); // Zona media-alta
          baseGradient.addColorStop(0.5, "#4a1a1a"); // Centro - más iluminado (flujo sanguíneo)
          baseGradient.addColorStop(0.65, "#3d1515"); // Zona media-baja
          baseGradient.addColorStop(0.85, "#2a0a0a"); // Transición
          baseGradient.addColorStop(1, "#1a0505"); // Muy oscuro abajo (cerca de la pared)

          cacheCtx.fillStyle = baseGradient;
          cacheCtx.fillRect(0, 0, width, height);

          // Agregar gradiente radial central para simular el flujo de sangre (lumen)
          const centerGradient = cacheCtx.createRadialGradient(
            width * 0.4,
            height / 2,
            0,
            width * 0.4,
            height / 2,
            Math.max(width, height) * 0.6
          );
          centerGradient.addColorStop(0, "rgba(139, 30, 30, 0.25)"); // Rojo oscuro en el centro
          centerGradient.addColorStop(0.3, "rgba(100, 20, 20, 0.15)");
          centerGradient.addColorStop(0.6, "rgba(60, 10, 10, 0.08)");
          centerGradient.addColorStop(1, "rgba(0, 0, 0, 0)");

          cacheCtx.fillStyle = centerGradient;
          cacheCtx.fillRect(0, 0, width, height);

          // Agregar efecto de profundidad con sombras en los bordes
          const edgeShadow = cacheCtx.createLinearGradient(0, 0, 0, height);
          edgeShadow.addColorStop(0, "rgba(0, 0, 0, 0.5)");
          edgeShadow.addColorStop(0.1, "rgba(0, 0, 0, 0.1)");
          edgeShadow.addColorStop(0.9, "rgba(0, 0, 0, 0.1)");
          edgeShadow.addColorStop(1, "rgba(0, 0, 0, 0.5)");

          cacheCtx.fillStyle = edgeShadow;
          cacheCtx.fillRect(0, 0, width, height);

          // Líneas horizontales sutiles para simular el flujo laminar de la sangre
          cacheCtx.strokeStyle = "rgba(80, 20, 20, 0.08)";
          cacheCtx.lineWidth = 1;
          for (let y = 30; y < height - 30; y += 8) {
            cacheCtx.beginPath();
            // Líneas ligeramente onduladas
            cacheCtx.moveTo(0, y);
            for (let x = 0; x < width; x += 50) {
              const wave = Math.sin(x * 0.02 + y * 0.1) * 1.5;
              cacheCtx.lineTo(x, y + wave);
            }
            cacheCtx.stroke();
          }

          vesselBackgroundCache = cacheCanvas;
        }

        // Dibujar el fondo desde el cache ocupando todo el espacio del canvas
        // El cache está en alta resolución (width * dpr x height * dpr)
        // El canvas interno también está en alta resolución, así que dibujamos directamente
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Resetear transformación
        ctx.drawImage(vesselBackgroundCache, 0, 0);
        ctx.restore();
      }

      function renderVesselWalls(event) {
        const ctx = render.context;
        // Usar las dimensiones lógicas (no las internas de alta resolución)
        const dpr = window.devicePixelRatio || 1;
        const width = CONFIG.canvas.width;
        const height = CONFIG.canvas.height;
        const { thickness } = CONFIG.wall;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        ctx.save();

        // Asegurar que el contexto esté escalado correctamente para alta resolución
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        
        // Mejorar calidad de renderizado para pantallas pequeñas
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        
        // Asegurar que las líneas se rendericen con mejor calidad
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // ========== PARED SUPERIOR IZQUIERDA ==========
        const adhesionLineY = CONFIG.adhesionLineY;
        const topY = adhesionLineY - thickness / 2;

        // Gradiente Adventitia (tejido conectivo externo) - más oscuro
        const adventitiaGradient = ctx.createLinearGradient(
          0,
          topY,
          0,
          topY + thickness
        );
        adventitiaGradient.addColorStop(0, "#2d1a1a");
        adventitiaGradient.addColorStop(0.3, "#3d2222");
        adventitiaGradient.addColorStop(0.7, "#4a2828");
        adventitiaGradient.addColorStop(1, "#3d2222");

        // Adventitia
        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(0, topY, woundLeft, thickness);

        // Media
        const topMediaGradient = ctx.createLinearGradient(
          0,
          topY + thickness * 0.4,
          0,
          topY + thickness
        );
        topMediaGradient.addColorStop(0, "#7a4a4a");
        topMediaGradient.addColorStop(0.5, "#6b4040");
        topMediaGradient.addColorStop(1, "#5a3535");

        ctx.fillStyle = topMediaGradient;
        ctx.fillRect(0, topY + thickness * 0.4, woundLeft, thickness * 0.6);

        // Intima
        const topIntimaGradient = ctx.createLinearGradient(
          0,
          topY + thickness * 0.7,
          0,
          topY + thickness
        );
        topIntimaGradient.addColorStop(0, "#c98888");
        topIntimaGradient.addColorStop(0.3, "#b87777");
        topIntimaGradient.addColorStop(0.7, "#a06666");
        topIntimaGradient.addColorStop(1, "#8b5555");

        ctx.fillStyle = topIntimaGradient;
        ctx.fillRect(0, topY + thickness * 0.7, woundLeft, thickness * 0.3);

        // Brillo del endotelio - mejorar calidad en pantallas pequeñas
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        // Ajustar grosor de línea según escala para mantener calidad
        const minLineWidth = Math.max(1, 2 * scaleFactor);
        ctx.lineWidth = minLineWidth;
        ctx.beginPath();
        ctx.moveTo(0, topY + thickness);
        ctx.lineTo(woundLeft, topY + thickness);
        ctx.stroke();

        // Textura - ajustar espaciado según escala para mantener detalle
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        const textureSpacing = Math.max(2, 4 * scaleFactor);
        const minTextureLineWidth = Math.max(0.5, 1 * scaleFactor);
        ctx.lineWidth = minTextureLineWidth;
        for (let y = topY + 3; y < topY + thickness - 2; y += textureSpacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(woundLeft, y);
          ctx.stroke();
        }

        // ========== PARED SUPERIOR DERECHA ==========
        // Adventitia
        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(woundRight, topY, width - woundRight, thickness);

        // Media
        ctx.fillStyle = topMediaGradient;
        ctx.fillRect(
          woundRight,
          topY + thickness * 0.4,
          width - woundRight,
          thickness * 0.6
        );

        // Intima
        ctx.fillStyle = topIntimaGradient;
        ctx.fillRect(
          woundRight,
          topY + thickness * 0.7,
          width - woundRight,
          thickness * 0.3
        );

        // Brillo del endotelio - mejorar calidad en pantallas pequeñas
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = minLineWidth;
        ctx.beginPath();
        ctx.moveTo(woundRight, topY + thickness);
        ctx.lineTo(width, topY + thickness);
        ctx.stroke();

        // Textura - ajustar espaciado según escala para mantener detalle
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = minTextureLineWidth;
        for (let y = topY + 3; y < topY + thickness - 2; y += textureSpacing) {
          ctx.beginPath();
          ctx.moveTo(woundRight, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        // ========== BORDES DE LA HERIDA ==========
        // Renderizar los bordes de la herida como tejido dañado
        // Ajustar grosor según escala para mantener calidad visual
        const woundEdgeWidth = Math.max(4, 6 * scaleFactor);

        // Borde izquierdo de la herida
        const woundEdgeGradient = ctx.createLinearGradient(
          woundLeft - woundEdgeWidth,
          topY,
          woundLeft,
          topY
        );
        woundEdgeGradient.addColorStop(0, "#c98888");
        woundEdgeGradient.addColorStop(0.3, "#d46666");
        woundEdgeGradient.addColorStop(0.7, "#e55555");
        woundEdgeGradient.addColorStop(1, "#ff6666");

        ctx.fillStyle = woundEdgeGradient;
        ctx.fillRect(
          woundLeft - woundEdgeWidth / 2,
          topY,
          woundEdgeWidth,
          thickness + 5
        );

        // Borde derecho de la herida
        const woundEdgeGradientRight = ctx.createLinearGradient(
          woundRight,
          topY,
          woundRight + woundEdgeWidth,
          topY
        );
        woundEdgeGradientRight.addColorStop(0, "#ff6666");
        woundEdgeGradientRight.addColorStop(0.3, "#e55555");
        woundEdgeGradientRight.addColorStop(0.7, "#d46666");
        woundEdgeGradientRight.addColorStop(1, "#c98888");

        ctx.fillStyle = woundEdgeGradientRight;
        ctx.fillRect(
          woundRight - woundEdgeWidth / 2,
          topY,
          woundEdgeWidth,
          thickness + 5
        );

        // Efecto de "sangrado" en los bordes de la herida - mejorar calidad
        ctx.strokeStyle = "rgba(255, 80, 80, 0.6)";
        const bleedingLineWidth = Math.max(1, 2 * scaleFactor);
        ctx.lineWidth = bleedingLineWidth;
        ctx.beginPath();
        ctx.moveTo(woundLeft - 1, topY);
        ctx.lineTo(woundLeft - 1, topY + thickness + 8);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(woundRight + 1, topY);
        ctx.lineTo(woundRight + 1, topY + thickness + 8);
        ctx.stroke();

        // Brillo/reflejo en los bordes de la herida - mejorar calidad
        ctx.strokeStyle = "rgba(255, 150, 150, 0.4)";
        const highlightLineWidth = Math.max(0.5, 1 * scaleFactor);
        ctx.lineWidth = highlightLineWidth;
        ctx.beginPath();
        ctx.moveTo(woundLeft - 2, topY);
        ctx.lineTo(woundLeft - 2, topY + thickness + 6);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(woundRight + 2, topY);
        ctx.lineTo(woundRight + 2, topY + thickness + 6);
        ctx.stroke();

        ctx.restore();
      }

      // Cache para el campo de succión (solo se regenera si cambia el tamaño del canvas)
      let suctionFieldCache = null;
      let suctionFieldCacheWidth = 0;
      let suctionFieldCacheHeight = 0;
      
      function renderSuctionField(event) {
        const ctx = render.context;
        const canvas = render.canvas;
        const width = canvas.width;
        const height = canvas.height;
        const woundX = CONFIG.wound.x;
        const adhesionLineY = CONFIG.adhesionLineY;
        const suctionRadius = Math.min(CONFIG.physics.suctionRadius, height); // Limitar al tamaño del canvas
        
        // Optimización: usar cache si el tamaño no ha cambiado
        if (!suctionFieldCache || width !== suctionFieldCacheWidth || height !== suctionFieldCacheHeight) {
          // Crear canvas para cache
          const cacheCanvas = document.createElement("canvas");
          cacheCanvas.width = width;
          cacheCanvas.height = height;
          const cacheCtx = cacheCanvas.getContext("2d");
          
          // Solo dibujar en la mitad superior usando un clip path
          cacheCtx.beginPath();
          cacheCtx.rect(0, 0, width, adhesionLineY);
          cacheCtx.clip();
          
          // Crear gradiente radial optimizado
          const gradient = cacheCtx.createRadialGradient(
            woundX, adhesionLineY, 0,
            woundX, adhesionLineY - Math.min(suctionRadius, adhesionLineY), Math.min(suctionRadius, adhesionLineY)
          );
          
          gradient.addColorStop(0, "rgba(100, 150, 255, 0.4)");
          gradient.addColorStop(0.3, "rgba(100, 150, 255, 0.25)");
          gradient.addColorStop(0.6, "rgba(100, 150, 255, 0.1)");
          gradient.addColorStop(1, "rgba(100, 150, 255, 0.0)");
          
          cacheCtx.fillStyle = gradient;
          cacheCtx.beginPath();
          cacheCtx.arc(woundX, adhesionLineY, Math.min(suctionRadius, adhesionLineY), 0, Math.PI * 2);
          cacheCtx.fill();
          
          // Optimización: dibujar menos líneas de fuerza (grid más espaciado)
          cacheCtx.strokeStyle = "rgba(100, 150, 255, 0.6)";
          cacheCtx.lineWidth = 1.5;
          cacheCtx.lineCap = "round";
          
          const gridSpacing = 60; // Aumentado de 40 a 60 para menos líneas
          const startX = 20;
          const endX = width - 20;
          const startY = Math.max(20, adhesionLineY - Math.min(suctionRadius, adhesionLineY));
          const endY = adhesionLineY - 10;
          
          // Pre-calcular valores constantes
          const suctionRadiusSq = suctionRadius * suctionRadius;
          
          for (let x = startX; x <= endX; x += gridSpacing) {
            for (let y = startY; y <= endY; y += gridSpacing) {
              const dx = woundX - x;
              const dy = adhesionLineY - y;
              const distanceSq = dx * dx + dy * dy;
              
              // Optimización: usar distancia al cuadrado para comparación
              if (distanceSq < suctionRadiusSq && distanceSq > 100) { // 100 = 10^2
                const distance = Math.sqrt(distanceSq);
                const angle = Math.atan2(dy, dx);
                const lineLength = Math.min(15, distance * 0.3);
                
                const endX_line = x + Math.cos(angle) * lineLength;
                const endY_line = y + Math.sin(angle) * lineLength;
                const opacity = 0.3 + (1 - distance / suctionRadius) * 0.3;
                
                cacheCtx.strokeStyle = `rgba(100, 150, 255, ${opacity})`;
                cacheCtx.beginPath();
                cacheCtx.moveTo(x, y);
                cacheCtx.lineTo(endX_line, endY_line);
                cacheCtx.stroke();
                
                // Flecha simplificada (solo si está cerca de la herida para mejor rendimiento)
                if (distance < suctionRadius * 0.5) {
                  const arrowLength = 4;
                  const arrowAngle = Math.PI / 6;
                  cacheCtx.beginPath();
                  cacheCtx.moveTo(endX_line, endY_line);
                  cacheCtx.lineTo(
                    endX_line - arrowLength * Math.cos(angle - arrowAngle),
                    endY_line - arrowLength * Math.sin(angle - arrowAngle)
                  );
                  cacheCtx.moveTo(endX_line, endY_line);
                  cacheCtx.lineTo(
                    endX_line - arrowLength * Math.cos(angle + arrowAngle),
                    endY_line - arrowLength * Math.sin(angle + arrowAngle)
                  );
                  cacheCtx.stroke();
                }
              }
            }
          }
          
          suctionFieldCache = cacheCanvas;
          suctionFieldCacheWidth = width;
          suctionFieldCacheHeight = height;
        }
        
        // Dibujar desde cache (muy rápido)
        ctx.drawImage(suctionFieldCache, 0, 0);
      }

      function renderFibrin(event) {
        const ctx = render.context;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const adhesionLineY = CONFIG.adhesionLineY; // Centro del área de adhesión (more down visually = higher Y in canvas coords)
        const adhesionZoneHalfWidth = 12; // Mitad del ancho del área de adhesión

        // Render ointment layer when treatment is applied - ultra simple for performance
        if (state.showOintment) {
          ctx.fillStyle = "rgba(117, 35, 120, 0.35)";
          ctx.fillRect(
            woundLeft,
            adhesionLineY - adhesionZoneHalfWidth,
            woundWidth,
            adhesionZoneHalfWidth * 2
          );
        }

        // Calcular opacidad de la malla morada basada en densidad de plaquetas pegadas en el área de adhesión
        const stuckPlateletsInWound = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          return (
            px >= woundLeft - 20 &&
            px <= woundRight + 20 &&
            py >= adhesionLineY - adhesionZoneHalfWidth &&
            py <= adhesionLineY + adhesionZoneHalfWidth
          );
        }).length;

        const maxPlatelets = 20; // Máximo esperado de plaquetas en la herida
        // La malla morada empieza muy transparente (0.05) y se opaca progresivamente hasta 0.9
        const meshOpacity = Math.min(
          0.9,
          0.05 + (stuckPlateletsInWound / maxPlatelets) * 0.85
        );

        // Área de la malla morada coincide con el área de adhesión
        const meshTopY = adhesionLineY - adhesionZoneHalfWidth;
        const meshHeight = adhesionZoneHalfWidth * 2; // Altura total del área de adhesión

        // Renderizar malla morada horizontal en la zona de adhesión que se opaca progresivamente
        // Solo esta área horizontal es morada - las cuerdas son verdes
        if (state.fibrinStarted && stuckPlateletsInWound > 0) {
          ctx.fillStyle = `rgba(117, 35, 120, ${meshOpacity})`; // Morado #752378
          ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
        }

        // Overlay verde cuando está sellada
        if (state.hemostasisAchieved) {
          ctx.fillStyle = "rgba(34, 197, 94, 0.3)"; // Verde semitransparente
          ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
        }

        // Render fibrin connections (cuerdas) - optimized for performance
        if (state.fibrinConstraints.length > 0) {
          ctx.save(); // Guardar estado del contexto antes de dibujar cuerdas verdes

          for (let i = 0; i < state.fibrinConstraints.length; i++) {
            const fibrin = state.fibrinConstraints[i];
            const pointA = fibrin.pointA.position;
            const pointB = fibrin.pointB.position;

            // Only draw if both points are still valid
            if (pointA && pointB) {
              const fibrinType = fibrin.fibrinType || "thin";
              let lineWidth, opacity;

              // Configurar grosor y opacidad según tipo de cuerda
              switch (fibrinType) {
                case "thick":
                  lineWidth = 7; // Aumentado de 5 a 7px
                  opacity = 0.9;
                  break;
                case "medium":
                  lineWidth = 4; // Aumentado de 3 a 4px
                  opacity = 0.6;
                  break;
                case "thin":
                default:
                  lineWidth = 2; // Aumentado de 1.5 a 2px
                  opacity = 0.4;
                  break;
              }

              // Ajustar opacidad según estabilidad
              opacity *= fibrin.stability || 1.0;

              // Color verde para las cuerdas (solo la malla horizontal es morada)
              ctx.strokeStyle = `rgba(34, 197, 94, ${opacity * 0.8})`; // Verde #22C55E con opacidad
              ctx.lineWidth = lineWidth;

              ctx.beginPath();
              ctx.moveTo(pointA.x, pointA.y);
              ctx.lineTo(pointB.x, pointB.y);
              ctx.stroke();
            }
          }

          ctx.restore(); // Restaurar estado del contexto después de dibujar cuerdas blancas
        }
      }

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16),
            }
          : { r: 0, g: 230, b: 118 };
      }

      function renderVWF(event) {
        const ctx = render.context;

        // Verificar si debe mostrar vWF (cemento entre plaquetas)
        const conditionConfig = CONFIG.conditions[state.condition];
        const shouldShowVWF =
          state.condition === "normal" ||
          state.treatmentApplied ||
          (state.condition === "vwd" && state.treatmentApplied);

        if (!shouldShowVWF || state.stuckPlatelets.length < 2) {
          return; // No mostrar vWF si no hay vWF o menos de 2 plaquetas
        }

        // Dibujar líneas verdes cortas (cemento) entre plaquetas pegadas que están cerca
        const maxVWFDistance = 12; // Distancia máxima para mostrar conexión vWF
        const maxVWFDistanceSq = maxVWFDistance * maxVWFDistance;

        // Asegurar que el color verde se aplique correctamente
        ctx.save(); // Guardar estado del contexto

        // Usar rgba para asegurar que el color verde se aplique correctamente
        ctx.strokeStyle = "rgba(34, 197, 94, 1.0)"; // Verde #22C55E en formato rgba
        ctx.lineWidth = 1.5;
        ctx.lineCap = "round";
        ctx.globalAlpha = 1.0; // Asegurar opacidad completa para el verde

        // Dibujar líneas entre plaquetas cercanas
        for (let i = 0; i < state.stuckPlatelets.length; i++) {
          const plateletA = state.stuckPlatelets[i];
          if (!plateletA.body) continue;

          const posA = plateletA.body.position;

          for (let j = i + 1; j < state.stuckPlatelets.length; j++) {
            const plateletB = state.stuckPlatelets[j];
            if (!plateletB.body) continue;

            const posB = plateletB.body.position;
            const dx = posB.x - posA.x;
            const dy = posB.y - posA.y;
            const distSq = dx * dx + dy * dy;

            // Solo dibujar si están cerca (como cemento entre piedras adyacentes)
            if (distSq < maxVWFDistanceSq && distSq > 4) {
              const dist = Math.sqrt(distSq);
              // Opacidad basada en distancia (más opaco cuanto más cerca)
              const opacity = 0.7 + (1.0 - dist / maxVWFDistance) * 0.3; // Entre 0.7 y 1.0

              // Re-establecer el color verde antes de cada línea para asegurar que siempre sea verde
              ctx.strokeStyle = `rgba(34, 197, 94, ${opacity})`; // Verde con opacidad variable
              ctx.beginPath();
              ctx.moveTo(posA.x, posA.y);
              ctx.lineTo(posB.x, posB.y);
              ctx.stroke();
            }
          }
        }

        ctx.restore(); // Restaurar estado del contexto
      }

      function renderParticlesCustom(event) {
        const ctx = render.context;

        // Renderizar todas las partículas con estilo personalizado (highlights, sombras, formas)
        // Renderizar solo plaquetas, glóbulos rojos y glóbulos blancos
        state.allBodies.forEach((body) => {
          if (
            !body.label ||
            (body.label !== "platelet" &&
              body.label !== "rbc" &&
              body.label !== "wbc")
          )
            return;

          const x = body.position.x;
          const y = body.position.y;
          const angle = body.angle;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);

          if (body.label === "rbc") {
            // Glóbulo rojo: ovalado con highlight y sombra
            const radiusX = BASE_CONFIG.particles.rbcRadius * scaleFactor;
            const radiusY = radiusX * 0.75; // Más ancho que alto para efecto ovalado

            // Sombra/contorno oscuro
            ctx.beginPath();
            ctx.ellipse(0, 0, radiusX + 0.5 * scaleFactor, radiusY + 0.5 * scaleFactor, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(139, 0, 0, 0.3)"; // Rojo muy oscuro para sombra
            ctx.fill();

            // Cuerpo principal rojo oscuro
            ctx.beginPath();
            ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
            ctx.fillStyle = "#B91C1C"; // Rojo oscuro
            ctx.fill();

            // Highlight pequeño cerca del centro (superior izquierda)
            // Mantener tamaño mínimo para visibilidad
            const highlightRadiusRBC = Math.max(1.0, 1.2 * scaleFactor);
            ctx.beginPath();
            ctx.arc(-1.5 * scaleFactor, -1 * scaleFactor, highlightRadiusRBC, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 200, 200, 0.8)"; // Rojo claro/rosa para highlight
            ctx.fill();
          } else if (body.label === "wbc") {
            // Glóbulo blanco: circular con highlight brillante y contorno azul oscuro
            const radius = BASE_CONFIG.particles.wbcRadius * scaleFactor;

            // Contorno azul oscuro para profundidad (mantener grosor mínimo)
            const outlineWidth = Math.max(1.0, 1.5 * scaleFactor);
            ctx.beginPath();
            ctx.arc(0, 0, radius + Math.max(0.5, 1 * scaleFactor), 0, Math.PI * 2);
            ctx.strokeStyle = "#4A90E2"; // Azul más oscuro para contorno
            ctx.lineWidth = outlineWidth;
            ctx.stroke();

            // Cuerpo principal azul claro
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#87CEEB"; // Azul claro
            ctx.fill();

            // Highlight brillante blanco en cuadrante superior izquierdo
            const highlightX = -3 * scaleFactor;
            const highlightY = -3 * scaleFactor;
            const highlightRadius = Math.max(3.0, 4 * scaleFactor); // Mantener tamaño mínimo
            const gradient = ctx.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, highlightRadius);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.95)"); // Blanco brillante en el centro
            gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.6)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)"); // Transparente hacia afuera

            ctx.beginPath();
            ctx.arc(highlightX, highlightY, highlightRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Punto de highlight más pequeño y brillante (mantener tamaño mínimo)
            const highlightDotRadius = Math.max(1.0, 1.5 * scaleFactor);
            ctx.beginPath();
            ctx.arc(highlightX, highlightY, highlightDotRadius, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 1)"; // Blanco sólido
            ctx.fill();
          } else if (body.label === "platelet") {
            // Plaqueta: circular gris con highlight sutil
            const radius = BASE_CONFIG.particles.plateletRadius * scaleFactor;

            // Sombra sutil (mantener grosor mínimo para visibilidad)
            const shadowOffsetPlatelet = Math.max(0.3, 0.3 * scaleFactor);
            ctx.beginPath();
            ctx.arc(0, 0, radius + shadowOffsetPlatelet, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(100, 100, 100, 0.2)"; // Gris oscuro para sombra
            ctx.fill();

            // Cuerpo principal gris
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#808080"; // Gris medio
            ctx.fill();

            // Highlight pequeño en cuadrante superior izquierdo (mantener tamaño mínimo)
            const highlightRadiusPlatelet = Math.max(0.6, 0.8 * scaleFactor);
            ctx.beginPath();
            ctx.arc(-1.2 * scaleFactor, -1.2 * scaleFactor, highlightRadiusPlatelet, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(220, 220, 220, 0.7)"; // Gris claro para highlight
            ctx.fill();
          }

          ctx.restore();
        });
      }

      function calculateClotPercentage() {
        // Si la herida está sellada (red de fibrina de izquierda a derecha y no pasan partículas), 100%
        if (state.hemostasisAchieved) {
          state.clotPercentage = 100;
          return;
        }

        const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
        const woundWidth = CONFIG.wound.width;
        const adhesionLineY = CONFIG.adhesionLineY; // Y position where platelets stick (herida)
        const woundCenterY = adhesionLineY; // Usar la posición real de la herida

        // Optimized coverage calculation
        const segments = 20; // Reduced from 30 for better performance
        const segmentWidth = woundWidth / segments;
        let coveredSegments = 0;
        const coverageThreshold = 15 * 15; // Squared distance for comparison

        // Pre-filter platelets that are actually in the wound area (exclude anchor platelets)
        const relevantPlatelets = state.stuckPlatelets.filter((p) => {
          // Excluir plaquetas anchor del cálculo
          if (p.isAnchor) return false;

          const px = p.body.position.x;
          const py = p.body.position.y;
          return (
            px >= woundLeft - 20 &&
            px <= woundLeft + woundWidth + 20 &&
            py >= woundCenterY - 15 &&
            py <= woundCenterY + 15
          );
        });

        for (let i = 0; i < segments; i++) {
          const segmentX = woundLeft + (i + 0.5) * segmentWidth;

          // Check if any stuck platelet covers this segment (optimized)
          const covered = relevantPlatelets.some((p) => {
            const dx = p.body.position.x - segmentX;
            const dy = p.body.position.y - woundCenterY;
            return dx * dx + dy * dy < coverageThreshold;
          });

          if (covered) coveredSegments++;
        }

        state.clotPercentage = Math.min(
          100,
          Math.round((coveredSegments / segments) * 100)
        );

        // Check if wound is sealed by fibrin network crossing left to right
        // Esto detecta cuando la red de fibrina va de izquierda a derecha
        checkWoundSealed();

        // Si está sellada, asegurar que el porcentaje sea 100%
        if (state.hemostasisAchieved) {
          state.clotPercentage = 100;
        }
      }

      function updateUI() {
        // Actualizar métricas con animación
        const bloodLossEl = document.getElementById("blood-loss");
        const clotPercentageEl = document.getElementById("clot-percentage");

        if (bloodLossEl) {
          const oldValue = parseInt(bloodLossEl.textContent) || 0;
          const newValue = state.bloodLoss;
          bloodLossEl.textContent = newValue;
          if (oldValue !== newValue) {
            bloodLossEl.classList.add("updated");
            setTimeout(() => bloodLossEl.classList.remove("updated"), 400);
          }
        }

        if (clotPercentageEl) {
          const oldValue = parseInt(clotPercentageEl.textContent) || 0;
          const newValue = state.clotPercentage;
          clotPercentageEl.textContent = newValue + "%";
          if (oldValue !== newValue) {
            clotPercentageEl.classList.add("updated");
            setTimeout(() => clotPercentageEl.classList.remove("updated"), 400);
          }
        }




      }


      // Controles de velocidad
      function setupSpeedControls() {
        const speedSlider = document.getElementById("speed-slider");
        const speedValue = document.getElementById("speed-value");

        if (speedSlider) {
          // Ajustar timeScale: cuando el slider está en 1.0, la velocidad real es 0.75
          // Esto hace que la velocidad "normal" (1x) sea más lenta
          const baseSpeed = 0.75;
          state.timeScale = baseSpeed;
          if (speedValue) speedValue.textContent = "1x";

          speedSlider.addEventListener("input", (e) => {
            const sliderValue = parseFloat(e.target.value);
            state.timeScale = baseSpeed * sliderValue;
            if (speedValue) speedValue.textContent = sliderValue + "x";

            // Reiniciar el spawn para aplicar el nuevo intervalo
            if (state.simulationRunning && !state.isPaused) {
              startParticleSpawning();
            }
          });
        }
      }

      // Tooltips
      function setupTooltips() {
        const triggers = document.querySelectorAll(".tooltip-trigger");

        triggers.forEach((trigger) => {
          const tooltip = trigger.parentElement.querySelector(".tooltip");

          trigger.addEventListener("mouseenter", () => {
            if (tooltip) tooltip.classList.add("visible");
          });

          trigger.addEventListener("mouseleave", () => {
            if (tooltip) tooltip.classList.remove("visible");
          });
        });
      }

      function applyTreatment() {
        // Verificar que la simulación se haya iniciado al menos una vez
        // (puede estar corriendo o pausada)
        if (!state.startTime) {
          return;
        }
        
        // Verificar que no se haya aplicado ya
        if (state.treatmentApplied) return;

        state.treatmentApplied = true;
        state.showOintment = true;


        // Show treatment indicator
        const indicator = document.getElementById("treatment-indicator");
        indicator.classList.add("visible");
        setTimeout(() => {
          indicator.classList.remove("visible");
        }, 2000);

        // Update button
        const btn = document.getElementById("treatment-btn");
        btn.classList.add("applied");
        btn.innerHTML = "Tratamiento Aplicado";
        btn.disabled = true;

        // Apply treatment effects based on condition
        const condition = CONFIG.conditions[state.condition];

        switch (state.condition) {
          case "hemophilia":
          case "hemophiliaSevere":
            // Factor VIII/IX replacement - enables fibrin formation
            applyFactorReplacement();
            break;

          case "vwd":
            // Desmopresina or vWF concentrate - improves platelet adhesion
            applyVWFReplacement();
            break;

          case "thrombocytopenia":
            // Platelet transfusion - increases platelet count
            applyPlateletTransfusion();
            break;

          case "thrombasthenia":
            // Platelet transfusion - provides functional platelets
            applyPlateletTransfusion();
            break;

          case "anticoagulated":
            // Vitamin K or PCC - reverses anticoagulation (similar a hemofilia)
            applyFactorReplacement();
            break;

          case "factorDeficiency":
            // Factor VII replacement - elimina el retraso de generación
            // Las plaquetas ya pegadas forman fibrina inmediatamente
            state.stuckPlatelets.forEach((plateletData) => {
              if (!plateletData.hasFibrin) {
                setTimeout(() => tryFormFibrin(plateletData), 50);
                setTimeout(() => tryFormFibrin(plateletData), 150);
              }
            });
            // Eliminar retraso para futuras formaciones
            condition.fibrinFormationDelay = 0;
            break;

          default:
            // Generic treatment - improves all parameters
            applyGenericTreatment();
        }

        // For all conditions, try to form additional fibrin connections
        // Con tratamiento, intentar formar fibrina más frecuentemente
        const retryInterval = state.treatmentApplied ? 100 : 200;
        const maxRetries = state.treatmentApplied ? 5 : 3;

        let retryCount = 0;
        const tryFormFibrinRepeatedly = () => {
          if (retryCount < maxRetries && !state.hemostasisAchieved) {
            state.stuckPlatelets.forEach((plateletData) => {
              tryFormFibrin(plateletData);
            });
            retryCount++;
            setTimeout(tryFormFibrinRepeatedly, retryInterval);
          }
        };

        setTimeout(tryFormFibrinRepeatedly, retryInterval);

        updateUI();
      }

      function applyFactorReplacement() {
        // Factor VIII/IX replacement for hemophilia/anticoagulated
        // Las plaquetas ya pegadas "disparan" instantáneamente hilos verdes fuertes
        const condition = CONFIG.conditions[state.condition];

        // Form fibrin on all existing stuck platelets immediately
        state.stuckPlatelets.forEach((plateletData) => {
          if (!plateletData.hasFibrin) {
            // Intentar formar fibrina múltiples veces para asegurar conexiones
            setTimeout(() => tryFormFibrin(plateletData), 50);
            setTimeout(() => tryFormFibrin(plateletData), 150);
            setTimeout(() => tryFormFibrin(plateletData), 300);
          }
        });

        // Make all existing fibrin stable and glowing (verde fuerte)
        state.fibrinConstraints.forEach((f) => {
          f.glowing = true;
          f.stability = 1.0; // Fibrina fuerte
          f.decayRate = 0;
          f.visualColor = "#00E676"; // Verde sólido
          f.opacity = 1.0;
          // Actualizar stiffness del constraint
          if (f.constraint) {
            f.constraint.stiffness = 0.9; // Stiffness fuerte
          }
        });
      }

      function applyVWFReplacement() {
        // Desmopresina or vWF concentrate for von Willebrand disease
        // Las plaquetas flotantes cambian sus propiedades físicas y empiezan a pegarse inmediatamente
        const condition = CONFIG.conditions[state.condition];

        // Cambiar propiedades físicas de todas las plaquetas flotantes
        state.allBodies.forEach((body) => {
          if (body.label === "platelet" && !body.isStuck) {
            // Cambiar restitución para que se peguen (reducir rebote)
            body.restitution = 0.5; // Rebote normal
            body.isSticky = true; // Permitir adhesión
            Body.setVelocity(body, {
              x: body.velocity.x * 0.8, // Reducir velocidad para facilitar adhesión
              y: body.velocity.y * 0.8,
            });
          }
        });

        // Update visual effects - platelets return to normal color
        state.stuckPlatelets.forEach((platelet) => {
          platelet.body.render.fillStyle = "#808080";
        });
      }

      function applyPlateletTransfusion() {
        // Platelet transfusion for thrombocytopenia/thrombasthenia
        const condition = CONFIG.conditions[state.condition];
        
        if (state.condition === "thrombocytopenia") {
          // Trombocitopenia: Inyecta una ráfaga ("bolus") de nuevas plaquetas al flujo
          const bolusCount = 20; // Ráfaga de 20 plaquetas
          for (let i = 0; i < bolusCount; i++) {
            setTimeout(() => {
              createParticle("platelet");
            }, i * 50); // Espaciar ligeramente la creación
          }
        } else if (state.condition === "thrombasthenia") {
          // Trombastenia: Las plaquetas flotantes cambian propiedades y empiezan a agregarse
          state.allBodies.forEach((body) => {
            if (body.label === "platelet" && !body.isStuck) {
              body.isSticky = true;
              // Permitir agregación ahora
            }
          });
          // También aumentar ratio temporalmente para nuevas plaquetas funcionales
          const originalRatio = condition.plateletRatio;
          condition.plateletRatio = 0.30; // Normal
          setTimeout(() => {
            condition.plateletRatio = originalRatio;
          }, 10000);
        }
      }

      function reverseAnticoagulation() {
        // Vitamin K or Prothrombin Complex Concentrate (PCC)
        // Improves fibrin stability and formation
        state.fibrinConstraints.forEach((f) => {
          f.stability = Math.min(1.0, f.stability + 0.3);
          f.decayRate = 0;
          f.visualColor = "#00E676";
          f.opacity = 1.0;
        });
      }

      function applyGenericTreatment() {
        // Generic treatment - improves all parameters slightly
        state.fibrinConstraints.forEach((f) => {
          f.stability = Math.min(1.0, f.stability + 0.2);
          f.glowing = true;
        });
      }

      function setCondition(condition) {
        state.condition = condition;
        state.treatmentApplied = false;
        state.simulationRunning = false;

        // Update UI
        document.querySelectorAll(".condition-btn").forEach((btn) => {
          const isActive = btn.dataset.condition === condition;
          btn.classList.toggle("active", isActive);
          btn.setAttribute("aria-checked", isActive ? "true" : "false");
        });

        // Actualizar ARIA
        updateConditionARIA();


        // Reset simulation
        initSimulation();


        // Habilitar botón de inicio
        const startBtn = document.getElementById("start-btn");
        const pauseBtn = document.getElementById("pause-btn");
        if (startBtn) {
          startBtn.disabled = false;
        }
        if (pauseBtn) {
          pauseBtn.disabled = true; // Deshabilitar pausa cuando no hay simulación corriendo
        }
        
        // Deshabilitar botón de tratamiento hasta que se inicie la simulación
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          treatmentBtn.disabled = true;
        }

      }

      function toggleSimulation() {
        if (!state.simulationRunning) {
          // Iniciar simulación
          state.simulationRunning = true;
          state.isPaused = false;
          state.startTime = Date.now();
          state.adhesionTime = null;
          state.closureTime = null;
          state.plateletsSpawned = 0;
          state.history = {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          };
          // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
          lastPhysicsTime = 0;
          accumulatedTime = 0;

          // Asegurar que timeScale tenga un valor válido
          if (!state.timeScale || state.timeScale <= 0) {
            state.timeScale = 1.0;
          }

          // Reiniciar el spawn para asegurar que funcione
          startParticleSpawning();
          
          // Mostrar el label "Lesión Activa" con efecto de pulso
          const woundLabel = document.getElementById("wound-label");
          if (woundLabel) {
            woundLabel.classList.remove("hidden");
            woundLabel.classList.add("active-pulse");
            woundLabel.classList.remove("healed");
            woundLabel.innerHTML = "Lesión Activa";
          }

          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitar botón de inicio cuando está corriendo
          }
          if (pauseBtn) {
            pauseBtn.disabled = false; // Habilitar botón de pausa cuando está corriendo
          }
          
          // Habilitar botón de tratamiento cuando la simulación está corriendo
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied) {
            treatmentBtn.disabled = false;
          }
        } else {
          // Pausar simulación
          state.simulationRunning = false;
          state.isPaused = true;
          // No usar Runner.stop() - usamos nuestro propio loop
          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = false; // Habilitar botón de inicio cuando está pausada
          }
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar botón de pausa cuando está pausada
          }
          
          // El botón de tratamiento permanece habilitado cuando la simulación está pausada
          // (siempre que se haya iniciado al menos una vez y no se haya aplicado ya)
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied && state.startTime) {
            treatmentBtn.disabled = false;
          }
        }
      }

      // Event Listeners
      // Variables globales para el sistema de resize simplificado
      let resizeInitialized = false;
      let resizeTimeout;
      let lastKnownScale = 1;

      // Función para detectar el zoom del navegador (global)
      function getBrowserZoom() {
        const testEl = document.createElement('div');
        testEl.style.width = '100px';
        testEl.style.height = '100px';
        testEl.style.position = 'absolute';
        testEl.style.visibility = 'hidden';
        testEl.style.top = '-9999px';
        document.body.appendChild(testEl);
        
        const logicalWidth = testEl.offsetWidth;
        const visualWidth = testEl.getBoundingClientRect().width;
        const zoom = visualWidth / logicalWidth;
        
        document.body.removeChild(testEl);
        return zoom;
      }

      // Función simplificada para actualizar el tamaño del canvas y UI
      function updateCanvasSizeGlobal() {
        const canvasEl = document.getElementById("simulation-canvas");
        if (!canvasEl) return;
        
        const container = canvasEl.parentElement;
        if (!container) return;
        
        const browserZoom = getBrowserZoom();
        const containerRect = container.getBoundingClientRect();
        const visualWidth = containerRect.width;
        const visualHeight = containerRect.height;
        const logicalWidth = container.clientWidth;
        const logicalHeight = container.clientHeight;
        
        // Calcular escala para el canvas (física)
        const scaleX = visualWidth / BASE_CONFIG.canvas.width;
        const scaleY = visualHeight / BASE_CONFIG.canvas.height;
        scaleFactor = Math.min(scaleX, scaleY);
        
        // El escalado de UI ahora se maneja completamente por CSS usando clamp()
        // Solo necesitamos actualizar la variable CSS si hay cambios significativos
        // El CSS ya tiene media queries para diferentes tamaños de pantalla
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const baseViewportWidth = 1920;
        const baseViewportHeight = 1080;
        
        // Calcular escala UI basada en el menor de los dos (ancho o alto)
        const uiScaleX = viewportWidth / baseViewportWidth;
        const uiScaleY = viewportHeight / baseViewportHeight;
        let uiScale = Math.min(uiScaleX, uiScaleY);
        
        // Para pantallas muy grandes, hacer el escalado más agresivo
        if (viewportWidth > 2560) {
          // Aumentar el escalado progresivamente para pantallas muy grandes
          const extraScale = Math.min((viewportWidth - 2560) / 1000, 1.5); // Hasta 1.5x adicional
          uiScale = uiScale * (1 + extraScale * 0.3); // Aumentar hasta 45% más
        }
        
        // Limitar el rango de escala UI (el CSS también tiene sus propios límites)
        // Aumentado el máximo a 4.5 para pantallas muy grandes
        const clampedUIScale = Math.max(0.5, Math.min(4.5, uiScale));
        
        // Solo actualizar si cambió significativamente
        if (Math.abs(clampedUIScale - lastKnownScale) > 0.01) {
          lastKnownScale = clampedUIScale;
          updateUIScaling(clampedUIScale);
        }
        
        // Actualizar canvas para física
        // Usar devicePixelRatio para aumentar resolución interna y mejorar calidad
        const dpr = window.devicePixelRatio || 1;
        const baseCanvasWidth = visualWidth / browserZoom;
        const baseCanvasHeight = visualHeight / browserZoom;
        
        // Resolución interna del canvas (más alta para mejor calidad)
        const internalWidth = Math.round(baseCanvasWidth * dpr);
        const internalHeight = Math.round(baseCanvasHeight * dpr);
        
        // Establecer tamaño interno del canvas (alta resolución)
        canvasEl.width = internalWidth;
        canvasEl.height = internalHeight;
        
        // Establecer tamaño visual del canvas (tamaño CSS)
        canvasEl.style.width = baseCanvasWidth + 'px';
        canvasEl.style.height = baseCanvasHeight + 'px';
        
        // Obtener el contexto y configurarlo para alta calidad
        // NO escalar aquí porque cada función de renderizado maneja su propio escalado
        const ctx = canvasEl.getContext("2d");
        if (ctx) {
          // Resetear la transformación para empezar limpio
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
        }
        
        CONFIG.canvas.width = baseCanvasWidth;
        CONFIG.canvas.height = baseCanvasHeight;
        CONFIG.wound.width = BASE_CONFIG.wound.width * scaleFactor;
        CONFIG.wound.height = BASE_CONFIG.wound.height * scaleFactor;
        CONFIG.wound.x = baseCanvasWidth / 2;
        CONFIG.wall.thickness = BASE_CONFIG.wall.thickness * scaleFactor;
        CONFIG.adhesionLineY = logicalHeight - (250 * scaleFactor);
        CONFIG.physics.suctionRadius = 2000 * scaleFactor;

        if (render) {
          render.options.width = baseCanvasWidth;
          render.options.height = baseCanvasHeight;
          render.canvas.width = internalWidth;
          render.canvas.height = internalHeight;
          render.context = ctx;
          
          // Asegurar que el contexto tenga la mejor calidad
          if (render.context) {
            render.context.imageSmoothingEnabled = true;
            render.context.imageSmoothingQuality = "high";
            // Asegurar que el contexto esté escalado correctamente
            render.context.setTransform(dpr, 0, 0, dpr, 0, 0);
          }
        }

        vesselBackgroundCache = null;
        suctionFieldCache = null;
      }

      // Función simplificada para inicializar el sistema de resize
      function initializeResizeHandlers() {
        if (resizeInitialized) return;
        resizeInitialized = true;
        
        // Handler de resize con debounce simple
        const handleResize = () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            updateCanvasSizeGlobal();
            
            // Solo reiniciar la simulación si está corriendo
            if (state.simulationRunning) {
              const wasRunning = state.simulationRunning;
              state.simulationRunning = false;
              initSimulation();
              if (wasRunning) {
                setTimeout(() => {
                  state.simulationRunning = true;
                  lastPhysicsTime = 0;
                  accumulatedTime = 0;
                }, 100);
              }
            }
          }, 150); // Debounce corto y simple
        };

        // Event listener de resize de ventana
        window.addEventListener("resize", handleResize);
        
        // ResizeObserver para detectar cambios de zoom
        const resizeObserver = new ResizeObserver(() => {
          handleResize();
        });
        
        const canvasEl = document.getElementById("simulation-canvas");
        if (canvasEl) {
          resizeObserver.observe(canvasEl);
          
          // Inicializar tamaño una vez
          setTimeout(() => {
            updateCanvasSizeGlobal();
          }, 100);
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        // Inicializar el sistema de resize primero
        initializeResizeHandlers();
        
        // Luego inicializar la simulación
        initSimulation();


        // Condition buttons
        document.querySelectorAll(".condition-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            setCondition(btn.dataset.condition);
          });
        });

        // Treatment button
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          treatmentBtn.addEventListener("click", applyTreatment);
          treatmentBtn.disabled = true; // Deshabilitado hasta iniciar simulación
        }

        // Start button
        const startBtn = document.getElementById("start-btn");
        if (startBtn) {
          startBtn.addEventListener("click", toggleSimulation);
          startBtn.disabled = true; // Deshabilitado hasta seleccionar condición
        }

        // Pause button
        const pauseBtn = document.getElementById("pause-btn");
        if (pauseBtn) {
          pauseBtn.addEventListener("click", toggleSimulation);
        }

        // Reset button
        document.getElementById("reset-btn").addEventListener("click", () => {
          state.simulationRunning = false;
          state.isPaused = false;
          state.condition = null;
          
          
          // No necesitamos detener el runner porque usamos nuestro propio loop
          initSimulation();
          
          // Desactivar todas las condiciones
          document.querySelectorAll(".condition-btn").forEach((btn) => {
            btn.classList.remove("active");
            btn.setAttribute("aria-checked", "false");
          });
          
          
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitado hasta seleccionar condición
          }
          
          const pauseBtn = document.getElementById("pause-btn");
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar pausa al resetear
          }
          
          // Resetear botón de tratamiento
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn) {
            treatmentBtn.classList.remove("applied");
            treatmentBtn.disabled = true; // Deshabilitado hasta iniciar simulación
            treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"
              />
            </svg>
            Administrar Tratamiento`;
          }
          
          // Remover efecto de pulsación del botón de reiniciar
          const resetBtn = document.getElementById("reset-btn");
          if (resetBtn) {
            resetBtn.classList.remove("hemostasis-pulse");
          }
          
          // Ocultar el label "Lesión Activa" al resetear
          const woundLabel = document.getElementById("wound-label");
          if (woundLabel) {
            woundLabel.classList.add("hidden");
            woundLabel.classList.remove("active-pulse", "healed");
          }
          
          state.treatmentApplied = false;
          
          // Actualizar UI inmediatamente para mostrar valores reseteados
          updateUI();
        });

        // Inicializar controles avanzados
        setupSpeedControls();
        setupTooltips();



        // No activar ninguna condición por defecto
        // El botón de inicio permanece deshabilitado hasta que se seleccione una condición

        // Actualizar ARIA inicial
        updateConditionARIA();
      });
    </script>
  </body>
</html>
