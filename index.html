<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual de Hemostasia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #F8FAFC;
            min-height: 100vh;
            color: #1E293B;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
            padding: 16px 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .header h1 {
            color: #F8FAFC;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #94A3B8;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #22C55E;
            animation: pulse 2s infinite;
        }

        .status-dot.bleeding {
            background: #EF4444;
            animation: pulse-red 1s infinite;
        }

        .status-dot.treated {
            background: #3B82F6;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }

        /* Main Container */
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Simulation Viewer */
        .viewer-section {
            margin-bottom: 24px;
        }

        .viewer-container {
            position: relative;
            background: #0F172A;
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 
                        0 0 0 1px rgba(255,255,255,0.05);
            overflow: hidden;
            max-width: 1100px;
            margin: 0 auto;
        }

        .viewer-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .label {
            position: absolute;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .label-lumen {
            bottom: 12px;
            left: 12px;
        }

        .label-wound {
            top: 12px;
            right: 12px;
            left: auto;
            transform: none;
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.3);
            color: #FCA5A5;
        }

        .label-wound.healed {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.3);
            color: #86EFAC;
        }

        .treatment-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.9);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 20;
        }

        .treatment-indicator.visible {
            opacity: 1;
            animation: treatment-flash 0.5s ease-out;
        }

        @keyframes treatment-flash {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        #simulation-canvas {
            display: block;
        }

        /* FPS Counter */
        .fps-counter {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #94A3B8;
            font-family: 'Courier New', monospace;
            z-index: 15;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .fps-counter.good {
            color: #22C55E;
        }

        .fps-counter.medium {
            color: #F59E0B;
        }

        .fps-counter.low {
            color: #EF4444;
        }

        /* Control Panel */
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            max-width: 1100px;
            margin: 0 auto;
        }

        .panel-card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid #E2E8F0;
        }

        .panel-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64748B;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title svg {
            width: 16px;
            height: 16px;
            fill: #64748B;
        }

        /* Condition Selector */
        .condition-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        @media (min-width: 1200px) {
            .condition-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .condition-btn {
            background: #F8FAFC;
            border: 2px solid #E2E8F0;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .condition-btn:hover {
            border-color: #CBD5E1;
            background: #F1F5F9;
        }

        .condition-btn.active {
            border-color: #3B82F6;
            background: #EFF6FF;
        }

        .condition-btn.active .condition-name {
            color: #1D4ED8;
        }

        .condition-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: #1E293B;
            margin-bottom: 4px;
        }

        .condition-desc {
            font-size: 0.75rem;
            color: #64748B;
            line-height: 1.4;
        }

        /* Metrics Panel */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .metric-box {
            background: #F8FAFC;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            border: 1px solid #E2E8F0;
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 800;
            line-height: 1;
            margin-bottom: 4px;
        }

        .metric-value.blood-loss {
            color: #DC2626;
        }

        .metric-value.clot-progress {
            color: #059669;
        }

        .metric-label {
            font-size: 0.75rem;
            color: #64748B;
            font-weight: 500;
        }

        /* Progress Bar */
        .clot-progress-bar {
            height: 8px;
            background: #E2E8F0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .clot-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #059669);
            border-radius: 4px;
            transition: width 0.3s;
            width: 0%;
        }

        /* Treatment Button */
        .treatment-btn {
            width: 100%;
            padding: 16px 24px;
            background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.4);
        }

        .treatment-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .treatment-btn:disabled {
            background: #94A3B8;
            cursor: not-allowed;
            box-shadow: none;
        }

        .treatment-btn.applied {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.4);
        }

        .treatment-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Reset Button */
        .reset-btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            color: #64748B;
            border: 2px solid #E2E8F0;
            border-radius: 10px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }

        .reset-btn:hover {
            border-color: #CBD5E1;
            background: #F8FAFC;
            color: #475569;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #64748B;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.platelet { background: #F1F5F9; border: 1px solid #CBD5E1; }
        .legend-dot.rbc { background: #EF4444; }
        .legend-dot.wbc { background: #E3F2FD; border: 1px solid #90CAF9; }
        .legend-dot.fibrin { background: #00E676; box-shadow: 0 0 6px #00E676; }

        /* Hemostasis Achieved Overlay */
        .hemostasis-achieved {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(16, 185, 129, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            display: none;
            align-items: center;
            gap: 6px;
            animation: fadeIn 0.5s;
        }

        .hemostasis-achieved.visible {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .control-panel {
                grid-template-columns: 1fr;
            }
            
            .header {
                padding: 12px 16px;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .main-container {
                padding: 16px;
            }
        }

        /* Fibrin glow effect when treatment applied */
        .fibrin-glow {
            filter: drop-shadow(0 0 8px #00E676) drop-shadow(0 0 16px #00E676);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-title">
            <div class="header-icon">
                <svg viewBox="0 0 24 24"><path d="M12 2C13.1 2 14 2.9 14 4C14 4.74 13.6 5.39 13 5.73V7H14C17.31 7 20 9.69 20 13V20C20 21.1 19.1 22 18 22H6C4.9 22 4 21.1 4 20V13C4 9.69 6.69 7 10 7H11V5.73C10.4 5.39 10 4.74 10 4C10 2.9 10.9 2 12 2M7.5 13C6.67 13 6 13.67 6 14.5C6 15.33 6.67 16 7.5 16C8.33 16 9 15.33 9 14.5C9 13.67 8.33 13 7.5 13M16.5 13C15.67 13 15 13.67 15 14.5C15 15.33 15.67 16 16.5 16C17.33 16 18 15.33 18 14.5C18 13.67 17.33 13 16.5 13M12 9C10.34 9 9 10.34 9 12H15C15 10.34 13.66 9 12 9Z"/></svg>
            </div>
            <h1>Laboratorio Virtual de Hemostasia</h1>
        </div>
        <div class="header-status">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Simulaci√≥n activa</span>
            </div>
        </div>
    </header>

    <main class="main-container">
        <section class="viewer-section">
            <div class="viewer-container">
                <div class="viewer-labels">
                    <div class="label label-wound" id="wound-label">‚ö†Ô∏è Lesi√≥n Activa</div>
                </div>
                <div class="treatment-indicator" id="treatment-indicator">
                    üíâ Tratamiento Administrado
                </div>
                <div class="hemostasis-achieved" id="hemostasis-indicator">
                    ‚úì Hemostasia Lograda
                </div>
                <div class="fps-counter" id="fps-counter">FPS: --</div>
                <canvas id="simulation-canvas"></canvas>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot platelet"></div> Plaquetas</div>
                <div class="legend-item"><div class="legend-dot rbc"></div> Gl√≥bulos Rojos</div>
                <div class="legend-item"><div class="legend-dot wbc"></div> Gl√≥bulos Blancos</div>
                <div class="legend-item"><div class="legend-dot fibrin"></div> Red de Fibrina</div>
            </div>
        </section>

        <section class="control-panel">
            <div class="panel-card">
                <div class="panel-title">
                    <svg viewBox="0 0 24 24"><path d="M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"/></svg>
                    Condici√≥n Cl√≠nica
                </div>
                <div class="condition-grid">
                    <button class="condition-btn active" data-condition="normal">
                        <div class="condition-name">Normal</div>
                        <div class="condition-desc">Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente</div>
                    </button>
                    <button class="condition-btn" data-condition="hemophilia">
                        <div class="condition-name">Hemofilia A/B</div>
                        <div class="condition-desc">D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable</div>
                    </button>
                    <button class="condition-btn" data-condition="vwd">
                        <div class="condition-name">Von Willebrand</div>
                        <div class="condition-desc">D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida</div>
                    </button>
                    <button class="condition-btn" data-condition="thrombocytopenia">
                        <div class="condition-name">Trombocitopenia</div>
                        <div class="condition-desc">Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo</div>
                    </button>
                    <button class="condition-btn" data-condition="hemophiliaSevere">
                        <div class="condition-name">Hemofilia Severa</div>
                        <div class="condition-desc">D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado</div>
                    </button>
                    <button class="condition-btn" data-condition="thrombasthenia">
                        <div class="condition-name">Trombastenia</div>
                        <div class="condition-desc">D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠</div>
                    </button>
                    <button class="condition-btn" data-condition="factorDeficiency">
                        <div class="condition-name">D√©ficit Factor VII</div>
                        <div class="condition-desc">V√≠a extr√≠nseca defectuosa - Formaci√≥n de fibrina reducida</div>
                    </button>
                    <button class="condition-btn" data-condition="anticoagulated">
                        <div class="condition-name">Anticoagulado</div>
                        <div class="condition-desc">Warfarina - Factores dependientes de vitamina K reducidos, fibrina inestable</div>
                    </button>
                </div>
            </div>

            <div class="panel-card">
                <div class="panel-title">
                    <svg viewBox="0 0 24 24"><path d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"/></svg>
                    M√©tricas en Tiempo Real
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-value blood-loss" id="blood-loss">0</div>
                        <div class="metric-label">P√©rdida Sangu√≠nea</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-value clot-progress" id="clot-percentage">0%</div>
                        <div class="metric-label">Formaci√≥n Co√°gulo</div>
                    </div>
                </div>
                <div class="clot-progress-bar">
                    <div class="clot-progress-fill" id="clot-bar"></div>
                </div>
                <button class="treatment-btn" id="treatment-btn">
                    <svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg>
                    Administrar Tratamiento
                </button>
                <button class="reset-btn" id="reset-btn">‚Üª Reiniciar Simulaci√≥n</button>
            </div>
        </section>
    </main>

    <script>
        // Matter.js modules
        const { Engine, Render, Runner, Bodies, Body, Composite, Constraint, Events, Vector } = Matter;

        // Simulation Configuration
        const CONFIG = {
            canvas: {
                width: 1100,
                height: 300
            },
            wound: {
                x: 550, // Center
                width: 300,
                height: 20
            },
            wall: {
                thickness: 30, // Increased thickness to prevent particles from passing through
                color: '#FDA4AF'
            },
            physics: {
                flowForce: 0.0003,
                suctionForce: 0.0012,
                suctionRadius: 180
            },
            particles: {
                maxCount: 150, // Reduced for better performance
                spawnRate: 3, // Reduced for better performance
                plateletRatio: 0.35,
                rbcRatio: 0.60,
                wbcRatio: 0.05
            },
            fibrin: {
                maxConnections: 200, // Limit fibrin connections to prevent performance issues
                maxConnectionsPerPlatelet: 8 // Limit connections per platelet
            },
            conditions: {
                normal: {
                    name: "Normal",
                    description: "Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 1.0,
                    fibrinStability: 1.0,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    bleedingTime: 3,
                    visualEffects: {
                        plateletColor: '#F1F5F9',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                hemophilia: {
                    name: "Hemofilia A/B",
                    description: "D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.15,
                    fibrinStability: 0.3,
                    fibrinDecayRate: 0.03,
                    fibrinFormationDelay: 1500,
                    bleedingTime: 30,
                    visualEffects: {
                        plateletColor: '#F1F5F9',
                        fibrinColor: '#FF6B6B',
                        fibrinGlow: false,
                        fibrinOpacity: 0.6
                    }
                },
                vwd: {
                    name: "Enfermedad de Von Willebrand",
                    description: "D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.2,
                    plateletFunction: 0.4,
                    adhesionStrength: 0.25,
                    aggregationRate: 0.3,
                    fibrinFormationRate: 0.7,
                    fibrinStability: 0.85,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    plateletBounceFactor: 0.7,
                    adhesionRetryChance: 0.4,
                    bleedingTime: 15,
                    visualEffects: {
                        plateletColor: '#FFE5B4',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                thrombocytopenia: {
                    name: "Trombocitopenia",
                    description: "Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo",
                    plateletRatio: 0.08,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.6,
                    fibrinStability: 0.8,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    spawnRateMultiplier: 0.3,
                    bleedingTime: 20,
                    visualEffects: {
                        plateletColor: '#F1F5F9',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                hemophiliaSevere: {
                    name: "Hemofilia Severa",
                    description: "D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: false,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.0,
                    fibrinStability: 0.0,
                    fibrinDecayRate: 0.2,
                    fibrinFormationDelay: 0,
                    bleedingTime: 60,
                    visualEffects: {
                        plateletColor: '#F1F5F9',
                        fibrinColor: '#FF0000',
                        fibrinGlow: false,
                        fibrinOpacity: 0.3
                    }
                },
                thrombasthenia: {
                    name: "Trombastenia de Glanzmann",
                    description: "D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.9,
                    plateletFunction: 0.2,
                    adhesionStrength: 0.85,
                    aggregationRate: 0.1,
                    fibrinFormationRate: 0.4,
                    fibrinStability: 0.6,
                    fibrinDecayRate: 0.01,
                    fibrinFormationDelay: 500,
                    maxPlateletClusterSize: 2,
                    bleedingTime: 25,
                    visualEffects: {
                        plateletColor: '#FFB6C1',
                        fibrinColor: '#FFA500',
                        fibrinGlow: false,
                        fibrinOpacity: 0.8
                    }
                },
                factorDeficiency: {
                    name: "D√©ficit Factor VII",
                    description: "D√©ficit Factor VII - V√≠a extr√≠nseca defectuosa, formaci√≥n de fibrina reducida",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.5,
                    fibrinStability: 0.75,
                    fibrinDecayRate: 0.01,
                    fibrinFormationDelay: 1000,
                    bleedingTime: 12,
                    visualEffects: {
                        plateletColor: '#F1F5F9',
                        fibrinColor: '#FFD700',
                        fibrinGlow: false,
                        fibrinOpacity: 0.9
                    }
                },
                anticoagulated: {
                    name: "Anticoagulado (Warfarina)",
                    description: "Anticoagulaci√≥n oral - Factores dependientes de vitamina K reducidos, fibrina inestable",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.4,
                    fibrinStability: 0.5,
                    fibrinDecayRate: 0.05,
                    fibrinFormationDelay: 800,
                    bleedingTime: 8,
                    visualEffects: {
                        plateletColor: '#F1F5F9',
                        fibrinColor: '#FF6347',
                        fibrinGlow: false,
                        fibrinOpacity: 0.7
                    }
                }
            }
        };

        // Game State
        let state = {
            condition: 'normal',
            treatmentApplied: false,
            bloodLoss: 0,
            clotPercentage: 0,
            hemostasisAchieved: false,
            stuckPlatelets: [],
            fibrinConstraints: [],
            fibrinBodies: [], // Physical bodies for fibrin network
            allBodies: [],
            showOintment: false
        };

        // Spawn timing for fixed interval
        let spawnInterval = null;
        let lastSpawnTime = 0;
        const SPAWN_INTERVAL_MS = 100; // Fixed spawn interval in milliseconds
        
        // Performance optimization: frame counters for throttling
        let frameCount = 0;
        const CLEANUP_INTERVAL = 10; // Cleanup every 10 frames
        const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames

        // Matter.js Setup
        let engine, render, runner;

        function initSimulation() {
            // Clear spawn interval
            if (spawnInterval) {
                cancelAnimationFrame(spawnInterval);
                spawnInterval = null;
            }
            lastSpawnTime = 0;

            // Reset state
            state = {
                condition: state.condition,
                treatmentApplied: false,
                bloodLoss: 0,
                clotPercentage: 0,
                hemostasisAchieved: false,
                stuckPlatelets: [],
                fibrinConstraints: [],
                fibrinBodies: [],
                allBodies: [],
                showOintment: false
            };

            // Stop FPS counter
            stopFPSCounter();
            
            // Clear previous engine events
            if (engine) {
                Events.off(engine, 'beforeUpdate');
                Events.off(engine, 'afterUpdate');
                Events.off(engine, 'collisionStart');
                // Remove anchor platelets before clearing world
                if (state.stuckPlatelets) {
                    state.stuckPlatelets.forEach(plateletData => {
                        if (plateletData.isAnchor && plateletData.body) {
                            Composite.remove(engine.world, plateletData.body);
                        }
                    });
                }
                Composite.clear(engine.world);
                Engine.clear(engine);
            }
            if (render) {
                Events.off(render, 'afterRender');
                Render.stop(render);
            }
            if (runner) {
                Runner.stop(runner);
            }
            
            // Reset canvas
            const canvas = document.getElementById('simulation-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset UI elements
            document.getElementById('hemostasis-indicator').classList.remove('visible');
            document.getElementById('wound-label').classList.remove('healed');
            document.getElementById('wound-label').innerHTML = '‚ö†Ô∏è Lesi√≥n Activa';
            
            const treatmentBtn = document.getElementById('treatment-btn');
            treatmentBtn.classList.remove('applied');
            treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg> Administrar Tratamiento`;
            treatmentBtn.disabled = false;

            // Create engine with zero gravity
            engine = Engine.create();
            engine.world.gravity.x = 0;
            engine.world.gravity.y = 0;

            // Create renderer using existing canvas
            const canvasEl = document.getElementById('simulation-canvas');
            canvasEl.width = CONFIG.canvas.width;
            canvasEl.height = CONFIG.canvas.height;
            
            render = Render.create({
                canvas: canvasEl,
                engine: engine,
                options: {
                    width: CONFIG.canvas.width,
                    height: CONFIG.canvas.height,
                    wireframes: false,
                    background: '#0F172A'
                }
            });

            // Create vessel walls
            createVesselWalls();

            // Start engine and renderer with fixed timestep
            runner = Runner.create({
                delta: 1000 / 60, // Fixed timestep: 60 FPS equivalent
                isFixed: true
            });
            Runner.run(runner, engine);
            Render.run(render);

            // Setup collision events
            setupCollisionEvents();

            // Start particle spawning
            startParticleSpawning();

            // Reset frame counter
            frameCount = 0;
            
            // Update loop for forces
            Events.on(engine, 'beforeUpdate', () => {
                frameCount++;
                applyForces();
                
                // Update fibrin barrier positions to follow platelets (every 3 frames for performance)
                if (frameCount % 3 === 0 && state.fibrinConstraints.length > 0) {
                    state.fibrinConstraints.forEach(fibrin => {
                        if (fibrin.body && fibrin.pointA && fibrin.pointB) {
                            const midX = (fibrin.pointA.position.x + fibrin.pointB.position.x) / 2;
                            const midY = (fibrin.pointA.position.y + fibrin.pointB.position.y) / 2;
                            const dist = Vector.magnitude(Vector.sub(fibrin.pointB.position, fibrin.pointA.position));
                            const angle = Math.atan2(
                                fibrin.pointB.position.y - fibrin.pointA.position.y,
                                fibrin.pointB.position.x - fibrin.pointA.position.x
                            );
                            
                            Body.setPosition(fibrin.body, { x: midX, y: midY });
                            Body.setAngle(fibrin.body, angle);
                            // Update width to match distance
                            const currentWidth = fibrin.body.bounds.max.x - fibrin.body.bounds.min.x;
                            if (Math.abs(currentWidth - dist) > 1) {
                                Body.scale(fibrin.body, dist / currentWidth, 1);
                            }
                        }
                    });
                }
                
                // Throttle expensive operations
                if (frameCount % CLEANUP_INTERVAL === 0) {
                    cleanupParticles();
                }
                if (frameCount % UI_UPDATE_INTERVAL === 0) {
                    calculateClotPercentage();
                    updateUI();
                }
            });

            // Custom render for fibrin
            Events.on(render, 'afterRender', renderFibrin);
            
            // Start FPS counter
            startFPSCounter();

            // Update UI
            updateUI();
        }
        
        // FPS Counter variables
        let fpsValue = 0;
        let fpsLastTime = performance.now();
        let fpsFrameCount = 0;
        let fpsUpdateInterval = 0;
        let fpsAnimationFrame = null;
        
        function startFPSCounter() {
            // Cancel any existing FPS counter loop
            if (fpsAnimationFrame !== null) {
                cancelAnimationFrame(fpsAnimationFrame);
                fpsAnimationFrame = null;
            }
            
            fpsValue = 0;
            fpsLastTime = performance.now();
            fpsFrameCount = 0;
            fpsUpdateInterval = 0;
            updateFPS();
        }
        
        function stopFPSCounter() {
            if (fpsAnimationFrame !== null) {
                cancelAnimationFrame(fpsAnimationFrame);
                fpsAnimationFrame = null;
            }
        }
        
        function updateFPS() {
            fpsAnimationFrame = requestAnimationFrame(() => {
                const currentTime = performance.now();
                fpsFrameCount++;
                fpsUpdateInterval += currentTime - fpsLastTime;
                fpsLastTime = currentTime;
                
                // Update FPS display every 500ms
                if (fpsUpdateInterval >= 500) {
                    fpsValue = Math.round((fpsFrameCount * 1000) / fpsUpdateInterval);
                    fpsFrameCount = 0;
                    fpsUpdateInterval = 0;
                    
                    const fpsElement = document.getElementById('fps-counter');
                    if (fpsElement) {
                        fpsElement.textContent = `FPS: ${fpsValue}`;
                        
                        // Color coding based on FPS
                        fpsElement.classList.remove('good', 'medium', 'low');
                        if (fpsValue >= 55) {
                            fpsElement.classList.add('good');
                        } else if (fpsValue >= 30) {
                            fpsElement.classList.add('medium');
                        } else {
                            fpsElement.classList.add('low');
                        }
                    }
                }
                
                updateFPS();
            });
        }

        function createVesselWalls() {
            const { width, height } = CONFIG.canvas;
            const { thickness, color } = CONFIG.wall;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;

            // Bottom wall (solid) - with bounce and collision filter
            const bottomWall = Bodies.rectangle(width / 2, height - thickness / 2, width, thickness, {
                isStatic: true,
                render: { fillStyle: color },
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Top wall - Left segment - with bounce and collision filter
            const leftWallWidth = woundX - woundWidth / 2;
            const topWallLeft = Bodies.rectangle(leftWallWidth / 2, thickness / 2, leftWallWidth, thickness, {
                isStatic: true,
                render: { fillStyle: color },
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Top wall - Right segment - with bounce and collision filter
            const rightWallStart = woundX + woundWidth / 2;
            const rightWallWidth = width - rightWallStart;
            const topWallRight = Bodies.rectangle(rightWallStart + rightWallWidth / 2, thickness / 2, rightWallWidth, thickness, {
                isStatic: true,
                render: { fillStyle: color },
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Wound edge markers (left and right edges of wound)
            const woundEdgeLeft = Bodies.rectangle(woundX - woundWidth / 2, thickness / 2, 6, thickness + 10, {
                isStatic: true,
                render: { fillStyle: '#F87171' },
                label: 'woundEdge',
                isSensor: false,
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            const woundEdgeRight = Bodies.rectangle(woundX + woundWidth / 2, thickness / 2, 6, thickness + 10, {
                isStatic: true,
                render: { fillStyle: '#F87171' },
                label: 'woundEdge',
                isSensor: false,
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            Composite.add(engine.world, [bottomWall, topWallLeft, topWallRight, woundEdgeLeft, woundEdgeRight]);
            
            // Create invisible anchor platelets on each side of the wound
            createInvisibleAnchorPlatelets(woundX, woundWidth, thickness);
        }
        
        function createInvisibleAnchorPlatelets(woundX, woundWidth, wallThickness) {
            const adhesionLineY = 18; // Same Y position as the adhesion line
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            // Left anchor platelet - positioned just outside the left edge of the wound
            const leftAnchorX = woundLeft - 15;
            const leftAnchor = Bodies.circle(leftAnchorX, adhesionLineY + 6, 4, {
                isStatic: true,
                render: { fillStyle: 'transparent', visible: false },
                label: 'platelet',
                isStuck: true,
                isAnchor: true // Mark as anchor platelet
            });
            
            // Right anchor platelet - positioned just outside the right edge of the wound
            const rightAnchorX = woundRight + 15;
            const rightAnchor = Bodies.circle(rightAnchorX, adhesionLineY + 6, 4, {
                isStatic: true,
                render: { fillStyle: 'transparent', visible: false },
                label: 'platelet',
                isStuck: true,
                isAnchor: true // Mark as anchor platelet
            });
            
            Composite.add(engine.world, [leftAnchor, rightAnchor]);
            
            // Add to stuck platelets list so they can form fibrin connections
            const leftAnchorData = {
                body: leftAnchor,
                constraint: null,
                hasFibrin: false,
                fibrinConnections: [],
                isAnchor: true
            };
            
            const rightAnchorData = {
                body: rightAnchor,
                constraint: null,
                hasFibrin: false,
                fibrinConnections: [],
                isAnchor: true
            };
            
            state.stuckPlatelets.push(leftAnchorData, rightAnchorData);
            
            // Try to form fibrin connections from anchor platelets after a delay
            setTimeout(() => {
                if (state.stuckPlatelets.includes(leftAnchorData)) {
                    tryFormFibrin(leftAnchorData);
                }
                if (state.stuckPlatelets.includes(rightAnchorData)) {
                    tryFormFibrin(rightAnchorData);
                }
            }, 200);
        }

        function createParticle(type) {
            const y = 50 + Math.random() * 200;
            const x = -10;

            let body;

            switch (type) {
                case 'platelet':
                    body = Bodies.circle(x, y, 4, {
                        render: { fillStyle: '#F1F5F9' },
                        label: 'platelet',
                        restitution: 0.5, // Increased for better wall bounce
                        friction: 0.1,
                        frictionAir: 0.02,
                        density: 0.001,
                        isSticky: true,
                        isStuck: false,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001,
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;

                case 'rbc':
                    body = Bodies.circle(x, y, 6, {
                        render: { fillStyle: '#EF4444' },
                        label: 'rbc',
                        restitution: 0.8, // Higher restitution for better bounce
                        friction: 0.05,
                        frictionAir: 0.01,
                        density: 0.0008,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001, // RBC category
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;

                case 'wbc':
                    body = Bodies.circle(x, y, 10, {
                        render: { fillStyle: '#E3F2FD' },
                        label: 'wbc',
                        restitution: 0.7, // Higher restitution for better bounce
                        friction: 0.1,
                        frictionAir: 0.03,
                        density: 0.002,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001, // WBC category
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;
            }

            if (body) {
                Composite.add(engine.world, body);
                state.allBodies.push(body);
            }

            return body;
        }

        function startParticleSpawning() {
            // Clear any existing interval
            if (spawnInterval) {
                cancelAnimationFrame(spawnInterval);
            }
            
            lastSpawnTime = performance.now();
            
            // Use requestAnimationFrame with time-based spawning for consistent rate
            function spawnLoop(currentTime) {
                if (state.allBodies.length < CONFIG.particles.maxCount) {
                    const elapsed = currentTime - lastSpawnTime;
                    
                    // Spawn particles at fixed interval regardless of FPS
                    if (elapsed >= SPAWN_INTERVAL_MS) {
                        const conditionConfig = CONFIG.conditions[state.condition];
                        const plateletRatio = conditionConfig.plateletRatio;
                        
                        // Apply spawn rate multiplier for conditions like thrombocytopenia
                        const spawnMultiplier = conditionConfig.spawnRateMultiplier || 1.0;
                        const spawnCount = Math.max(1, Math.floor(CONFIG.particles.spawnRate * spawnMultiplier));

                        for (let i = 0; i < spawnCount; i++) {
                            if (state.allBodies.length >= CONFIG.particles.maxCount) break;
                            
                            const rand = Math.random();
                            
                            if (rand < plateletRatio) {
                                createParticle('platelet');
                            } else if (rand < plateletRatio + CONFIG.particles.rbcRatio) {
                                createParticle('rbc');
                            } else {
                                createParticle('wbc');
                            }
                        }
                        
                        lastSpawnTime = currentTime;
                    }
                }
                
                spawnInterval = requestAnimationFrame(spawnLoop);
            }
            
            spawnInterval = requestAnimationFrame(spawnLoop);
        }

        function applyForces() {
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            // Invisible adhesion line parameters - positioned at wound opening
            const adhesionLineY = 18; // Y position of the invisible line (at top of wound)
            const adhesionLineThreshold = 14; // How close to trigger adhesion check

            state.allBodies.forEach(body => {
                // Skip stuck platelets and static bodies
                if (body.isStuck || body.isStatic) return;

                // Prevent particles from passing through walls by checking bounds
                const { width, height } = CONFIG.canvas;
                const wallThickness = CONFIG.wall.thickness;
                const particleRadius = body.circleRadius || (body.label === 'rbc' ? 6 : body.label === 'wbc' ? 10 : 4);
                
                // Check bottom wall
                if (body.position.y > height - wallThickness - particleRadius) {
                    Body.setPosition(body, {
                        x: body.position.x,
                        y: height - wallThickness - particleRadius - 0.1
                    });
                    Body.setVelocity(body, {
                        x: body.velocity.x,
                        y: Math.min(0, body.velocity.y * -0.8) // Bounce up
                    });
                }
                
                // Check top walls (left and right segments)
                const woundX = CONFIG.wound.x;
                const woundWidth = CONFIG.wound.width;
                const woundLeft = woundX - woundWidth / 2;
                const woundRight = woundX + woundWidth / 2;
                
                if (body.position.y < wallThickness + particleRadius) {
                    // Check if particle is in wound area
                    if (body.position.x < woundLeft || body.position.x > woundRight) {
                        // Outside wound - push back from top wall
                        Body.setPosition(body, {
                            x: body.position.x,
                            y: wallThickness + particleRadius + 0.1
                        });
                        Body.setVelocity(body, {
                            x: body.velocity.x,
                            y: Math.max(0, body.velocity.y * -0.8) // Bounce down
                        });
                    }
                }

                // Laminar flow force (right)
                Body.applyForce(body, body.position, {
                    x: CONFIG.physics.flowForce * body.mass,
                    y: 0
                });

                // Suction force (only under the wound)
                if (body.position.x > woundLeft - 50 && body.position.x < woundRight + 50) {
                    const distanceToWound = Math.abs(body.position.y - 20);

                    if (body.position.x > woundLeft && body.position.x < woundRight && body.position.y < 150) {
                        // Direct suction upward
                        const suctionStrength = CONFIG.physics.suctionForce * (1 - distanceToWound / 150);
                        Body.applyForce(body, body.position, {
                            x: 0,
                            y: -suctionStrength * body.mass
                        });
                    }
                }

                // FIBRIN NET BOUNCE - Make RBCs and WBCs bounce off fibrin network
                if ((body.label === 'rbc' || body.label === 'wbc') && state.fibrinConstraints.length > 0) {
                    const cellRadius = body.label === 'rbc' ? 6 : 10;
                    const bounceThreshold = cellRadius + 6; // Increased detection threshold
                    const bounceStrength = body.label === 'rbc' ? 0.008 : 0.012; // Much stronger bounce force
                    const cellPos = body.position;
                    
                    // Only check fibrin near the wound area for performance
                    const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2 - 30;
                    const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2 + 30;
                    
                    if (cellPos.x >= woundLeft && cellPos.x <= woundRight && cellPos.y < 120) {
                        for (let i = 0; i < state.fibrinConstraints.length; i++) {
                            const fibrin = state.fibrinConstraints[i];
                            const pointA = fibrin.pointA.position;
                            const pointB = fibrin.pointB.position;
                            
                            if (!pointA || !pointB) continue;
                            
                            // Quick bounds check - skip if fibrin line is far from cell
                            const minX = Math.min(pointA.x, pointB.x);
                            const maxX = Math.max(pointA.x, pointB.x);
                            const minY = Math.min(pointA.y, pointB.y);
                            const maxY = Math.max(pointA.y, pointB.y);
                            
                            if (cellPos.x < minX - bounceThreshold || cellPos.x > maxX + bounceThreshold ||
                                cellPos.y < minY - bounceThreshold || cellPos.y > maxY + bounceThreshold) {
                                continue;
                            }
                            
                            // Calculate distance from cell to fibrin line segment
                            const lineVec = Vector.sub(pointB, pointA);
                            const lineLength = Vector.magnitude(lineVec);
                            
                            if (lineLength < 0.1) continue; // Skip very short lines
                            
                            const toCell = Vector.sub(cellPos, pointA);
                            const lineLengthSq = lineLength * lineLength;
                            const t = Math.max(0, Math.min(1, Vector.dot(toCell, lineVec) / lineLengthSq));
                            const closestPoint = Vector.add(pointA, Vector.mult(lineVec, t));
                            const distVec = Vector.sub(cellPos, closestPoint);
                            const distance = Vector.magnitude(distVec);
                            const bounceThresholdSq = bounceThreshold * bounceThreshold;
                            const distanceSq = distance * distance;
                            
                            // If cell is close to fibrin line, apply strong bounce force
                            if (distanceSq < bounceThresholdSq && distance > 0.1) {
                                // Normalize distance vector to get bounce direction
                                const bounceDir = {
                                    x: distVec.x / distance,
                                    y: distVec.y / distance
                                };
                                
                                // Calculate velocity component towards the line
                                const velocityDot = body.velocity.x * bounceDir.x + body.velocity.y * bounceDir.y;
                                
                                // Only apply bounce if moving towards the line
                                if (velocityDot < 0) {
                                    // Strong bounce force - much stronger when very close
                                    const proximityFactor = 1 - (distance / bounceThreshold);
                                    const bounceForce = bounceStrength * proximityFactor * proximityFactor; // Quadratic for stronger effect
                                    
                                    Body.applyForce(body, body.position, {
                                        x: bounceDir.x * bounceForce * body.mass * 10,
                                        y: bounceDir.y * bounceForce * body.mass * 10
                                    });
                                    
                                    // Invert velocity component towards the line (strong bounce)
                                    const bounceFactor = 0.8 + (proximityFactor * 0.2); // 0.8 to 1.0
                                    Body.setVelocity(body, {
                                        x: body.velocity.x - bounceDir.x * velocityDot * bounceFactor,
                                        y: body.velocity.y - bounceDir.y * velocityDot * bounceFactor
                                    });
                                    
                                    // Push cell away from the line
                                    const pushDistance = (bounceThreshold - distance) * 0.3;
                                    Body.setPosition(body, {
                                        x: body.position.x + bounceDir.x * pushDistance,
                                        y: body.position.y + bounceDir.y * pushDistance
                                    });
                                }
                            }
                        }
                    }
                }

                // INVISIBLE ADHESION LINE - Check if platelet crosses the invisible line
                if (body.label === 'platelet' && !body.isStuck) {
                    const inWoundZone = body.position.x > woundLeft && body.position.x < woundRight;
                    const nearAdhesionLine = Math.abs(body.position.y - adhesionLineY) < adhesionLineThreshold;

                    if (inWoundZone && nearAdhesionLine) {
                        const conditionConfig = CONFIG.conditions[state.condition];
                        const canStick = state.treatmentApplied ? true : conditionConfig.canStick;
                        const stickProb = state.treatmentApplied ? 0.85 : conditionConfig.stickProbability * 0.4;

                        // Check platelet function first
                        if (!state.treatmentApplied && Math.random() > conditionConfig.plateletFunction) {
                            // Platelet dysfunction - bounce off
                            const bounceFactor = conditionConfig.plateletBounceFactor || 0.7;
                            body.restitution = 0.9;
                            Body.setVelocity(body, {
                                x: body.velocity.x * bounceFactor,
                                y: Math.abs(body.velocity.y) * 1.5 + 1
                            });
                            return;
                        }
                        
                        const adhesionStrength = state.treatmentApplied ? 0.85 : conditionConfig.adhesionStrength * 0.4;
                        
                        if (canStick && Math.random() < adhesionStrength) {
                            // Stick to the invisible line
                            stickPlateletToLine(body, adhesionLineY, conditionConfig);
                        } else if (!state.treatmentApplied && conditionConfig.adhesionRetryChance) {
                            // Retry adhesion chance
                            setTimeout(() => {
                                if (!body.isStuck && Math.random() < conditionConfig.adhesionRetryChance) {
                                    if (canStick && Math.random() < adhesionStrength) {
                                        stickPlateletToLine(body, adhesionLineY, conditionConfig);
                                    }
                                }
                            }, 100);
                        } else {
                            // Platelet bounces off
                            const bounceFactor = conditionConfig.plateletBounceFactor || 0.7;
                            body.restitution = 0.9;
                            Body.setVelocity(body, {
                                x: body.velocity.x * bounceFactor,
                                y: Math.abs(body.velocity.y) * 1.5 + 1
                            });
                        }
                    }
                }
            });

            // For hemophilia and conditions with unstable fibrin - apply extra force to dislodge weakly attached platelets
            const conditionConfig = CONFIG.conditions[state.condition];
            if ((state.condition === 'hemophilia' || state.condition === 'hemophiliaSevere' || 
                 conditionConfig.fibrinStability < 0.5) && !state.treatmentApplied) {
                state.stuckPlatelets.forEach(platelet => {
                    if (!platelet.hasFibrin || platelet.fibrinConnections.length === 0) {
                        // Gradually increase dislodge force for platelets without fibrin support
                        const dislodgeForce = 0.00015 * (1 - conditionConfig.fibrinStability);
                        Body.applyForce(platelet.body, platelet.body.position, {
                            x: 0,
                            y: -dislodgeForce * platelet.body.mass * (1 + Math.random())
                        });
                    }
                });
            }
        }

        function stickPlateletToLine(platelet, lineY, conditionConfig) {
            if (platelet.isStuck) return;
            
            platelet.isStuck = true;
            
            // Apply visual effects based on condition
            const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
            platelet.render.fillStyle = visualEffects.plateletColor || '#E2E8F0';
            
            // Stop movement and position at the line
            Body.setVelocity(platelet, { x: 0, y: 0 });
            const stickY = lineY + 6;
            Body.setPosition(platelet, { x: platelet.position.x, y: stickY });
            
            // Make platelet completely static so it doesn't move
            Body.setStatic(platelet, true);
            
            // Create constraint to the line (static point) - maximum stiffness
            const constraint = Constraint.create({
                bodyA: platelet,
                pointB: { x: platelet.position.x, y: stickY },
                stiffness: 1.0, // Maximum stiffness
                damping: 1.0, // Maximum damping
                length: 0,
                render: { visible: false }
            });

            Composite.add(engine.world, constraint);

            const plateletData = {
                body: platelet,
                constraint: constraint,
                hasFibrin: false,
                fibrinConnections: [],
                condition: state.condition
            };

            state.stuckPlatelets.push(plateletData);

            // Try to form fibrin after delay if specified
            const delay = conditionConfig.fibrinFormationDelay || 150;
            setTimeout(() => {
                if (state.stuckPlatelets.includes(plateletData)) {
                    tryFormFibrin(plateletData);
                    
                    // Also try to form fibrin from nearby anchor platelets
                    state.stuckPlatelets.forEach(other => {
                        if (other.isAnchor && other.body) {
                            const dist = Vector.magnitude(Vector.sub(plateletData.body.position, other.body.position));
                            if (dist < 80) {
                                tryFormFibrin(other);
                            }
                        }
                    });
                }
            }, delay);
        }

        function cleanupParticles() {
            const toRemove = [];
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;

            // Optimized cleanup: iterate backwards for better performance when removing
            for (let i = state.allBodies.length - 1; i >= 0; i--) {
                const body = state.allBodies[i];
                const px = body.position.x;
                const py = body.position.y;
                
                // Remove particles that exit right or top (blood loss)
                if (px > CONFIG.canvas.width + 20 || py < -30) {
                    toRemove.push(body);
                    if (py < -30) state.bloodLoss++;
                }
                // Remove particles that exit through the wound (upward)
                else if (py < 10 && px >= woundLeft - 5 && px <= woundRight + 5) {
                    toRemove.push(body);
                    state.bloodLoss++;
                }
                // Remove particles way off screen
                else if (py > CONFIG.canvas.height + 50 || px < -100) {
                    toRemove.push(body);
                }
            }

            // Optimized removal: use Map for faster lookups
            const bodySet = new Set(toRemove);
            
            toRemove.forEach(body => {
                // Remove associated constraints if it's a stuck platelet
                const plateletIndex = state.stuckPlatelets.findIndex(p => p.body === body);
                if (plateletIndex !== -1) {
                    const plateletData = state.stuckPlatelets[plateletIndex];
                    
                    // Remove fibrin constraints connected to this platelet (iterate backwards)
                    for (let i = state.fibrinConstraints.length - 1; i >= 0; i--) {
                        const fibrin = state.fibrinConstraints[i];
                        if (fibrin.pointA === body || fibrin.pointB === body) {
                            removeFibrinConnection(fibrin);
                        }
                    }
                    
                    // Remove platelet constraint
                    if (plateletData.constraint) {
                        Composite.remove(engine.world, plateletData.constraint);
                    }
                    
                    // Remove from stuck platelets list (but not anchor platelets)
                    if (!plateletData.isAnchor) {
                        state.stuckPlatelets.splice(plateletIndex, 1);
                    }
                }
                
                Composite.remove(engine.world, body);
            });
            
            // Remove from allBodies array (more efficient)
            state.allBodies = state.allBodies.filter(b => !bodySet.has(b));
        }

        function setupCollisionEvents() {
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    
                    // Check for platelet collision with wound edges or stuck platelets
                    handlePlateletCollision(bodyA, bodyB);
                    handlePlateletCollision(bodyB, bodyA);
                });
            });
        }

        function handlePlateletCollision(platelet, other) {
            if (platelet.label !== 'platelet' || platelet.isStuck) return;

            const conditionConfig = CONFIG.conditions[state.condition];
            
            // Check platelet function first
            if (!state.treatmentApplied && Math.random() > conditionConfig.plateletFunction) {
                // Platelet dysfunction - bounce off
                const bounceFactor = conditionConfig.plateletBounceFactor || 0.7;
                platelet.restitution = 0.9;
                Body.setVelocity(platelet, {
                    x: platelet.velocity.x * bounceFactor,
                    y: Math.abs(platelet.velocity.y) * 1.5 + 2
                });
                return;
            }

            const canStick = state.treatmentApplied ? true : conditionConfig.canStick;
            const adhesionStrength = state.treatmentApplied ? 0.95 : conditionConfig.adhesionStrength;

            // Check if collision is with wound edge or stuck platelet
            const isWoundEdge = other.label === 'woundEdge';
            const isStuckPlatelet = other.label === 'platelet' && other.isStuck;

            if (isWoundEdge || isStuckPlatelet) {
                // Check if in wound zone
                const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
                const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;
                
                if (platelet.position.x >= woundLeft - 20 && platelet.position.x <= woundRight + 20 && platelet.position.y < 45) {
                    // Check aggregation rate for platelet-to-platelet adhesion
                    if (isStuckPlatelet) {
                        const aggregationRate = state.treatmentApplied ? 0.9 : conditionConfig.aggregationRate;
                        if (Math.random() > aggregationRate) {
                            // Failed aggregation
                            platelet.restitution = 0.9;
                            Body.setVelocity(platelet, {
                                x: platelet.velocity.x * 0.8,
                                y: Math.abs(platelet.velocity.y) * 1.2 + 1
                            });
                            return;
                        }
                    }
                    
                    if (canStick && Math.random() < adhesionStrength) {
                        stickPlatelet(platelet, other, conditionConfig);
                    } else if (!state.treatmentApplied && conditionConfig.adhesionRetryChance) {
                        // Retry adhesion chance
                        setTimeout(() => {
                            if (!platelet.isStuck && Math.random() < conditionConfig.adhesionRetryChance) {
                                if (canStick && Math.random() < adhesionStrength) {
                                    stickPlatelet(platelet, other, conditionConfig);
                                }
                            }
                        }, 100);
                    } else {
                        // Platelet bounces off
                        const bounceFactor = conditionConfig.plateletBounceFactor || 0.7;
                        platelet.restitution = 0.9;
                        Body.setVelocity(platelet, {
                            x: platelet.velocity.x * bounceFactor,
                            y: Math.abs(platelet.velocity.y) * 2 + 2
                        });
                    }
                }
            }
        }

        function stickPlatelet(platelet, anchor, conditionConfig) {
            if (platelet.isStuck) return;
            
            platelet.isStuck = true;
            
            // Apply visual effects based on condition
            const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
            platelet.render.fillStyle = visualEffects.plateletColor || '#E2E8F0';
            
            // Stop movement completely
            Body.setVelocity(platelet, { x: 0, y: 0 });
            
            // Make platelet completely static so it doesn't move
            Body.setStatic(platelet, true);
            
            // Create constraint to anchor point - maximum stiffness
            const constraint = Constraint.create({
                bodyA: platelet,
                pointB: anchor.isStatic ? { x: anchor.position.x, y: anchor.position.y } : null,
                bodyB: anchor.isStatic ? null : anchor,
                stiffness: 1.0, // Maximum stiffness
                damping: 1.0, // Maximum damping
                length: 0,
                render: { visible: false }
            });

            Composite.add(engine.world, constraint);

            const plateletData = {
                body: platelet,
                constraint: constraint,
                hasFibrin: false,
                fibrinConnections: [],
                condition: state.condition
            };

            state.stuckPlatelets.push(plateletData);

            // Try to form fibrin with delay if specified
            const delay = conditionConfig.fibrinFormationDelay || 100;
            setTimeout(() => {
                if (state.stuckPlatelets.includes(plateletData)) {
                    tryFormFibrin(plateletData);
                }
            }, delay);
        }

        function tryFormFibrin(plateletData) {
            const conditionConfig = CONFIG.conditions[state.condition];
            const canFormFibrin = state.treatmentApplied ? true : conditionConfig.canFormFibrin;

            if (!canFormFibrin) return;
            
            // Check fibrin formation rate
            const fibrinFormationRate = state.treatmentApplied ? 1.0 : conditionConfig.fibrinFormationRate;
            if (Math.random() > fibrinFormationRate) {
                return; // Failed to form fibrin this time
            }
            
            // Limit total fibrin connections
            if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections) return;
            
            // Limit connections per platelet
            if (plateletData.fibrinConnections.length >= CONFIG.fibrin.maxConnectionsPerPlatelet) return;
            
            // Check max cluster size for thrombasthenia
            if (conditionConfig.maxPlateletClusterSize) {
                const nearbyCount = state.stuckPlatelets.filter(p => {
                    const dx = p.body.position.x - plateletData.body.position.x;
                    const dy = p.body.position.y - plateletData.body.position.y;
                    return (dx * dx + dy * dy) < 400 && p.fibrinConnections.length > 0;
                }).length;
                if (nearbyCount >= conditionConfig.maxPlateletClusterSize) {
                    return; // Cannot form larger clusters
                }
            }

            const platelet = plateletData.body;
            const searchRadius = 90; // Increased search radius for more separated connections
            const plateletX = platelet.position.x;
            const plateletY = platelet.position.y;

            // Find nearby stuck platelets (optimized with early exit)
            for (let i = 0; i < state.stuckPlatelets.length; i++) {
                const other = state.stuckPlatelets[i];
                if (other.body === platelet) continue;
                if (plateletData.fibrinConnections.includes(other.body.id)) continue;
                
                // Limit connections per other platelet too
                if (other.fibrinConnections.length >= CONFIG.fibrin.maxConnectionsPerPlatelet) continue;

                // Quick distance check using squared distance (avoid sqrt)
                const dx = other.body.position.x - plateletX;
                const dy = other.body.position.y - plateletY;
                const distSq = dx * dx + dy * dy;
                const searchRadiusSq = searchRadius * searchRadius;
                const minDistanceSq = 400; // Increased minimum distance: 20^2 = 400 (was 5^2 = 25)

                if (distSq < searchRadiusSq && distSq > minDistanceSq) {
                    const dist = Math.sqrt(distSq);
                    
                    // Get fibrin stability from condition
                    const fibrinStability = state.treatmentApplied ? 1.0 : conditionConfig.fibrinStability;
                    const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
                    
                    // Create fibrin constraint with stability-based properties
                    const fibrinConstraint = Constraint.create({
                        bodyA: platelet,
                        bodyB: other.body,
                        stiffness: 0.9 * fibrinStability,
                        damping: 0.3 * (2 - fibrinStability),
                        length: dist * 0.8,
                        render: { visible: false }
                    });

                    Composite.add(engine.world, fibrinConstraint);

                    // Create physical body for fibrin barrier (thin rectangle)
                    const midX = (platelet.position.x + other.body.position.x) / 2;
                    const midY = (platelet.position.y + other.body.position.y) / 2;
                    const angle = Math.atan2(
                        other.body.position.y - platelet.position.y,
                        other.body.position.x - platelet.position.x
                    );
                    
                    // Create a thin rectangular body as barrier
                    const fibrinBody = Bodies.rectangle(midX, midY, dist, 4, {
                        isStatic: true, // Static so it acts as a solid barrier
                        render: { 
                            fillStyle: 'transparent', // Invisible, we render it separately
                            visible: false
                        },
                        label: 'fibrinBarrier',
                        restitution: 0.9 * fibrinStability, // Stability affects bounce
                        friction: 0.1,
                        collisionFilter: {
                            group: 0,
                            category: 0x0002, // Separate category for fibrin
                            mask: 0x0001 // Only collide with RBCs and WBCs
                        }
                    });
                    
                    Body.setAngle(fibrinBody, angle);
                    Composite.add(engine.world, fibrinBody);

                    const fibrinData = {
                        constraint: fibrinConstraint,
                        pointA: platelet,
                        pointB: other.body,
                        body: fibrinBody,
                        glowing: state.treatmentApplied,
                        stability: fibrinStability,
                        decayRate: conditionConfig.fibrinDecayRate || 0,
                        visualColor: visualEffects.fibrinColor,
                        opacity: visualEffects.fibrinOpacity || 1.0,
                        createdAt: Date.now()
                    };
                    
                    state.fibrinConstraints.push(fibrinData);
                    state.fibrinBodies.push(fibrinBody);

                    plateletData.fibrinConnections.push(other.body.id);
                    plateletData.hasFibrin = true;
                    other.fibrinConnections.push(platelet.id);
                    other.hasFibrin = true;
                    
                    // Schedule fibrin decay if condition has decay rate
                    if (conditionConfig.fibrinDecayRate > 0 && !state.treatmentApplied) {
                        scheduleFibrinDecay(fibrinData, conditionConfig.fibrinDecayRate);
                    }
                    
                    // Stop if we've reached the limit
                    if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections) break;
                }
            }
            
            // Check if wound is sealed after forming new fibrin connection
            checkWoundSealed();
        }
        
        function scheduleFibrinDecay(fibrinData, decayRate) {
            // Decay fibrin over time based on decay rate
            const decayInterval = setInterval(() => {
                if (!state.fibrinConstraints.includes(fibrinData)) {
                    clearInterval(decayInterval);
                    return;
                }
                
                // Reduce stability over time
                fibrinData.stability -= decayRate * 0.1;
                
                if (fibrinData.stability <= 0.1 || Math.random() < decayRate) {
                    // Remove unstable fibrin
                    removeFibrinConnection(fibrinData);
                    clearInterval(decayInterval);
                } else {
                    // Update constraint properties based on stability
                    fibrinData.constraint.stiffness = 0.9 * fibrinData.stability;
                    fibrinData.constraint.damping = 0.3 * (2 - fibrinData.stability);
                }
            }, 2000); // Check every 2 seconds
        }
        
        function removeFibrinConnection(fibrinData) {
            // Remove from world
            Composite.remove(engine.world, fibrinData.constraint);
            if (fibrinData.body) {
                Composite.remove(engine.world, fibrinData.body);
                state.fibrinBodies = state.fibrinBodies.filter(b => b !== fibrinData.body);
            }
            
            // Remove from arrays
            state.fibrinConstraints = state.fibrinConstraints.filter(f => f !== fibrinData);
            
            // Update platelet connections
            const plateletA = state.stuckPlatelets.find(p => p.body === fibrinData.pointA);
            const plateletB = state.stuckPlatelets.find(p => p.body === fibrinData.pointB);
            
            if (plateletA) {
                plateletA.fibrinConnections = plateletA.fibrinConnections.filter(id => id !== fibrinData.pointB.id);
                plateletA.hasFibrin = plateletA.fibrinConnections.length > 0;
            }
            if (plateletB) {
                plateletB.fibrinConnections = plateletB.fibrinConnections.filter(id => id !== fibrinData.pointA.id);
                plateletB.hasFibrin = plateletB.fibrinConnections.length > 0;
            }
        }
        
        function checkWoundSealed() {
            if (state.hemostasisAchieved) return; // Already sealed
            
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const woundCenterY = 24; // Y position where platelets stick
            
            // Find platelets on the left side of the wound (including anchor platelets)
            const leftSidePlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                // Include anchor platelets or platelets near left edge
                return (p.isAnchor && px < woundLeft) || (px < woundLeft + 30 && Math.abs(py - woundCenterY) < 20);
            });
            
            // Find platelets on the right side of the wound (including anchor platelets)
            const rightSidePlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                // Include anchor platelets or platelets near right edge
                return (p.isAnchor && px > woundRight) || (px > woundRight - 30 && Math.abs(py - woundCenterY) < 20);
            });
            
            if (leftSidePlatelets.length === 0 || rightSidePlatelets.length === 0) {
                return; // Need platelets on both sides
            }
            
            // Check if there's a path from left to right through fibrin connections
            for (let i = 0; i < leftSidePlatelets.length; i++) {
                const leftPlatelet = leftSidePlatelets[i];
                if (hasPathToRight(leftPlatelet, rightSidePlatelets, new Set())) {
                    // Wound is sealed!
                    state.hemostasisAchieved = true;
                    state.clotPercentage = 100;
                    document.getElementById('hemostasis-indicator').classList.add('visible');
                    document.getElementById('wound-label').classList.add('healed');
                    document.getElementById('wound-label').innerHTML = '‚úì Lesi√≥n Sellada';
                    updateUI();
                    return;
                }
            }
        }
        
        function hasPathToRight(currentPlatelet, rightSidePlatelets, visited) {
            // Check if current platelet is on the right side
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;
            
            if (currentPlatelet.body.position.x > woundRight - 20) {
                return true; // Reached right side
            }
            
            // Mark as visited
            visited.add(currentPlatelet.body.id);
            
            // Check all fibrin connections from this platelet
            for (let i = 0; i < state.fibrinConstraints.length; i++) {
                const fibrin = state.fibrinConstraints[i];
                let connectedPlatelet = null;
                
                // Find which platelet is connected to current one
                if (fibrin.pointA === currentPlatelet.body) {
                    connectedPlatelet = state.stuckPlatelets.find(p => p.body === fibrin.pointB);
                } else if (fibrin.pointB === currentPlatelet.body) {
                    connectedPlatelet = state.stuckPlatelets.find(p => p.body === fibrin.pointA);
                }
                
                if (connectedPlatelet && !visited.has(connectedPlatelet.body.id)) {
                    // Check if this connection crosses the wound area
                    const px1 = currentPlatelet.body.position.x;
                    const px2 = connectedPlatelet.body.position.x;
                    const woundLeft = woundX - woundWidth / 2;
                    const woundRight = woundX + woundWidth / 2;
                    
                    // Connection crosses wound if one point is left and other is right
                    if ((px1 < woundLeft && px2 > woundRight) || (px2 < woundLeft && px1 > woundRight)) {
                        // Direct crossing found
                        return true;
                    }
                    
                    // Continue searching through this connection
                    if (hasPathToRight(connectedPlatelet, rightSidePlatelets, visited)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function renderFibrin(event) {
            const ctx = render.context;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            
            // Render ointment layer when treatment is applied - ultra simple for performance
            if (state.showOintment) {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.35)';
                ctx.fillRect(woundLeft, 0, woundWidth, 22);
            }
            
            // Render fibrin connections - optimized for performance with condition-based colors
            if (state.fibrinConstraints.length > 0) {
                for (let i = 0; i < state.fibrinConstraints.length; i++) {
                    const fibrin = state.fibrinConstraints[i];
                    const pointA = fibrin.pointA.position;
                    const pointB = fibrin.pointB.position;
                    
                    // Only draw if both points are still valid
                    if (pointA && pointB) {
                        // Use condition-specific color and opacity
                        const color = fibrin.visualColor || (state.treatmentApplied ? '#39FF14' : '#00E676');
                        const opacity = fibrin.opacity !== undefined ? fibrin.opacity : 1.0;
                        const lineWidth = fibrin.glowing ? 2.5 : (state.treatmentApplied ? 2 : 1.5);
                        
                        // Set color with opacity
                        const rgb = hexToRgb(color);
                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        ctx.lineWidth = lineWidth * (fibrin.stability || 1.0); // Thinner if unstable
                        
                        ctx.beginPath();
                        ctx.moveTo(pointA.x, pointA.y);
                        ctx.lineTo(pointB.x, pointB.y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 230, b: 118 };
        }

        function calculateClotPercentage() {
            const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
            const woundWidth = CONFIG.wound.width;

            // Optimized coverage calculation
            const segments = 20; // Reduced from 30 for better performance
            const segmentWidth = woundWidth / segments;
            let coveredSegments = 0;
            const coverageThreshold = 15 * 15; // Squared distance for comparison

            // Pre-filter platelets that are actually in the wound area
            const relevantPlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                return px >= woundLeft - 20 && px <= woundLeft + woundWidth + 20 && py < 35;
            });

            for (let i = 0; i < segments; i++) {
                const segmentX = woundLeft + (i + 0.5) * segmentWidth;
                
                // Check if any stuck platelet covers this segment (optimized)
                const covered = relevantPlatelets.some(p => {
                    const dx = p.body.position.x - segmentX;
                    const dy = p.body.position.y - 18; // Center Y of wound
                    return (dx * dx + dy * dy) < coverageThreshold;
                });

                if (covered) coveredSegments++;
            }

            state.clotPercentage = Math.min(100, Math.round((coveredSegments / segments) * 100));

            // Check if wound is sealed by fibrin network crossing left to right
            if (!state.hemostasisAchieved) {
                checkWoundSealed();
            }
            
            // Fallback: Check for hemostasis by coverage percentage
            if (state.clotPercentage >= 85 && !state.hemostasisAchieved) {
                state.hemostasisAchieved = true;
                document.getElementById('hemostasis-indicator').classList.add('visible');
                document.getElementById('wound-label').classList.add('healed');
                document.getElementById('wound-label').innerHTML = '‚úì Lesi√≥n Sellada';
            }
        }

        function updateUI() {
            document.getElementById('blood-loss').textContent = state.bloodLoss;
            document.getElementById('clot-percentage').textContent = state.clotPercentage + '%';
            document.getElementById('clot-bar').style.width = state.clotPercentage + '%';

            // Status indicator
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            if (state.hemostasisAchieved) {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Hemostasia lograda';
            } else if (state.treatmentApplied) {
                statusDot.className = 'status-dot treated';
                statusText.textContent = 'Tratamiento activo';
            } else if (state.bloodLoss > 20) {
                statusDot.className = 'status-dot bleeding';
                statusText.textContent = 'Sangrado activo';
            } else {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Simulaci√≥n activa';
            }
        }

        function applyTreatment() {
            if (state.treatmentApplied) return;

            state.treatmentApplied = true;
            state.showOintment = true;

            // Show treatment indicator
            const indicator = document.getElementById('treatment-indicator');
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 2000);

            // Update button
            const btn = document.getElementById('treatment-btn');
            btn.classList.add('applied');
            btn.innerHTML = '‚úì Tratamiento Aplicado';
            btn.disabled = true;

            // Apply treatment effects based on condition
            const condition = CONFIG.conditions[state.condition];
            
            switch(state.condition) {
                case 'hemophilia':
                case 'hemophiliaSevere':
                    // Factor VIII/IX replacement - enables fibrin formation
                    applyFactorReplacement();
                    break;
                    
                case 'vwd':
                    // Desmopresina or vWF concentrate - improves platelet adhesion
                    applyVWFReplacement();
                    break;
                    
                case 'thrombocytopenia':
                    // Platelet transfusion - increases platelet count
                    applyPlateletTransfusion();
                    break;
                    
                case 'thrombasthenia':
                    // Platelet transfusion - provides functional platelets
                    applyPlateletTransfusion();
                    break;
                    
                case 'anticoagulated':
                    // Vitamin K or PCC - reverses anticoagulation
                    reverseAnticoagulation();
                    break;
                    
                default:
                    // Generic treatment - improves all parameters
                    applyGenericTreatment();
            }

            // For all conditions, try to form additional fibrin connections
            setTimeout(() => {
                state.stuckPlatelets.forEach(plateletData => {
                    tryFormFibrin(plateletData);
                });
            }, 200);

            updateUI();
        }
        
        function applyFactorReplacement() {
            // Factor VIII/IX replacement for hemophilia
            // Gradually improves fibrin formation rate
            const condition = CONFIG.conditions[state.condition];
            const targetRate = 0.9;
            
            // Form fibrin on all existing stuck platelets immediately
            state.stuckPlatelets.forEach(plateletData => {
                if (!plateletData.hasFibrin) {
                    tryFormFibrin(plateletData);
                }
            });
            
            // Make all fibrin stable and glowing
            state.fibrinConstraints.forEach(f => {
                f.glowing = true;
                f.stability = 1.0;
                f.decayRate = 0;
                f.visualColor = '#39FF14';
                f.opacity = 1.0;
            });
        }
        
        function applyVWFReplacement() {
            // Desmopresina or vWF concentrate for von Willebrand disease
            // Improves platelet adhesion and function
            const condition = CONFIG.conditions[state.condition];
            
            // Update visual effects - platelets return to normal color
            state.stuckPlatelets.forEach(platelet => {
                platelet.body.render.fillStyle = '#F1F5F9';
            });
            
            // Improve adhesion for new platelets (handled by canStick check)
        }
        
        function applyPlateletTransfusion() {
            // Platelet transfusion for thrombocytopenia/thrombasthenia
            // Temporarily increases platelet spawn rate
            const condition = CONFIG.conditions[state.condition];
            const originalRatio = condition.plateletRatio;
            
            // Increase platelet ratio temporarily
            condition.plateletRatio = Math.min(0.35, originalRatio * 3);
            
            // Spawn extra platelets immediately
            for (let i = 0; i < 25; i++) {
                if (state.allBodies.length < CONFIG.particles.maxCount) {
                    createParticle('platelet');
                }
            }
            
            // Restore after 10 seconds
            setTimeout(() => {
                condition.plateletRatio = originalRatio;
            }, 10000);
        }
        
        function reverseAnticoagulation() {
            // Vitamin K or Prothrombin Complex Concentrate (PCC)
            // Improves fibrin stability and formation
            state.fibrinConstraints.forEach(f => {
                f.stability = Math.min(1.0, f.stability + 0.3);
                f.decayRate = 0;
                f.visualColor = '#00E676';
                f.opacity = 1.0;
            });
        }
        
        function applyGenericTreatment() {
            // Generic treatment - improves all parameters slightly
            state.fibrinConstraints.forEach(f => {
                f.stability = Math.min(1.0, f.stability + 0.2);
                f.glowing = true;
            });
        }

        function setCondition(condition) {
            state.condition = condition;
            
            // Update UI
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.condition === condition);
            });

            // Reset simulation
            initSimulation();
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initSimulation();

            // Condition buttons
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setCondition(btn.dataset.condition);
                });
            });

            // Treatment button
            document.getElementById('treatment-btn').addEventListener('click', applyTreatment);

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', () => {
                initSimulation();
            });
        });
    </script>
</body>
</html>

