<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual de Hemostasia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #F8FAFC;
            min-height: 100vh;
            color: #1E293B;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
            padding: 16px 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .header h1 {
            color: #F8FAFC;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #94A3B8;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #22C55E;
            animation: pulse 2s infinite;
        }

        .status-dot.bleeding {
            background: #EF4444;
            animation: pulse-red 1s infinite;
        }

        .status-dot.treated {
            background: #3B82F6;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Simulation Viewer */
        .viewer-section {
            margin-bottom: 24px;
        }

        .viewer-container {
            position: relative;
            background: #0F172A;
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 
                        0 0 0 1px rgba(255,255,255,0.05);
            overflow: hidden;
            max-width: 1300px;
            margin: 0 auto;
        }

        .viewer-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .label {
            position: absolute;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .label-lumen {
            bottom: 12px;
            left: 12px;
        }

        .label-wound {
            top: auto;
            bottom: 28px;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.3);
            color: #FCA5A5;
        }

        .label-wound.healed {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.3);
            color: #86EFAC;
        }

        .treatment-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.9);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 20;
        }

        .treatment-indicator.visible {
            opacity: 1;
            animation: treatment-flash 0.5s ease-out;
        }

        @keyframes treatment-flash {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        #simulation-canvas {
            display: block;
            width: 100%;
            height: 300px;
            max-width: 100%;
        }

        /* FPS Counter removido */

        /* Control Panel */
        .control-panel {
            display: grid;
            grid-template-columns: 0.6fr 1.4fr;
            gap: 16px;
            max-width: 1300px;
            margin: 0 auto;
        }

        .panel-card {
            background: white;
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid #E2E8F0;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }
        
        .panel-card:first-child {
            padding: 10px;
        }
        
        .panel-card:last-child {
            display: flex;
            flex-direction: column;
        }
        
        .controls-metrics-container {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            margin-top: 8px;
        }
        
        .controls-section {
            flex: 0 0 280px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .metrics-section {
            flex: 1;
            min-width: 0;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .panel-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64748B;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .panel-card:first-child .panel-title {
            margin-bottom: 8px;
        }

        .panel-title svg {
            width: 16px;
            height: 16px;
            fill: #64748B;
        }

        /* Condition Selector */
        .condition-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        @media (min-width: 1200px) {
            .condition-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .condition-btn {
            background: #F8FAFC;
            border: 2px solid #E2E8F0;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .condition-btn:hover {
            border-color: #CBD5E1;
            background: #F1F5F9;
        }

        .condition-btn.active {
            border-color: #3B82F6;
            background: #EFF6FF;
        }

        .condition-btn.active .condition-name {
            color: #1D4ED8;
        }

        .condition-name {
            font-weight: 600;
            font-size: 0.8rem;
            color: #1E293B;
            margin-bottom: 3px;
        }

        .condition-desc {
            font-size: 0.65rem;
            color: #64748B;
            line-height: 1.3;
        }

        /* Metrics Panel */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .metric-box {
            background: #F8FAFC;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            border: 1px solid #E2E8F0;
        }

        .metric-value {
            font-size: 1.75rem;
            font-weight: 800;
            line-height: 1;
            margin-bottom: 2px;
        }

        .metric-value.blood-loss {
            color: #DC2626;
        }

        .metric-value.clot-progress {
            color: #059669;
        }

        .metric-label {
            font-size: 0.7rem;
            color: #64748B;
            font-weight: 500;
        }

        /* Progress Bar */
        .clot-progress-bar {
            height: 5px;
            background: #E2E8F0;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .clot-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #059669);
            border-radius: 4px;
            transition: width 0.3s;
            width: 0%;
        }

        /* Gr√°ficos en tiempo real */
        .charts-container {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .chart-panel {
            background: white;
            border-radius: 6px;
            padding: 6px;
            border: 1px solid #E2E8F0;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .chart-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: #1E293B;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chart-canvas {
            width: 100%;
            height: 70px;
            border-radius: 4px;
        }

        /* M√©tricas avanzadas expandidas */
        .advanced-metrics {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .advanced-metric {
            background: #F8FAFC;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #E2E8F0;
        }

        .advanced-metric-label {
            font-size: 0.6rem;
            color: #64748B;
            margin-bottom: 2px;
        }

        .advanced-metric-value {
            font-size: 0.875rem;
            font-weight: 700;
            color: #1E293B;
        }

        /* Controles de velocidad */
        .simulation-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: #F8FAFC;
            border-radius: 6px;
            border: 1px solid #E2E8F0;
        }

        .speed-control label {
            font-size: 0.7rem;
            color: #64748B;
            font-weight: 500;
        }

        .speed-slider {
            width: 80px;
            height: 3px;
            border-radius: 2px;
            background: #E2E8F0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3B82F6;
            cursor: pointer;
        }

        .speed-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3B82F6;
            cursor: pointer;
            border: none;
        }

        /* Tooltips educativos */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }

        .tooltip-trigger {
            cursor: help;
            color: #3B82F6;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 12px 16px;
            background: #1E293B;
            color: white;
            border-radius: 8px;
            font-size: 0.875rem;
            line-height: 1.5;
            max-width: 300px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1E293B;
        }

        .tooltip.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Panel educativo expandible */
        .educational-panel {
            margin-top: 8px;
            background: #F8FAFC;
            border-radius: 6px;
            border: 1px solid #E2E8F0;
            overflow: hidden;
        }

        .educational-panel-header {
            padding: 6px 8px;
            background: #EFF6FF;
            border-bottom: 1px solid #E2E8F0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .educational-panel-header:hover {
            background: #DBEAFE;
        }

        .educational-panel-title {
            font-weight: 600;
            font-size: 0.7rem;
            color: #1E293B;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .educational-panel-content {
            padding: 8px;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .educational-panel.expanded .educational-panel-content {
            display: block;
        }

        .educational-section {
            margin-bottom: 8px;
        }

        .educational-section h4 {
            font-size: 0.75rem;
            font-weight: 600;
            color: #1E293B;
            margin-bottom: 4px;
        }

        .educational-section p {
            font-size: 0.65rem;
            color: #475569;
            line-height: 1.4;
            margin-bottom: 4px;
        }

        .coagulation-cascade {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 6px;
            margin-top: 6px;
        }

        .cascade-step {
            background: white;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #E2E8F0;
            font-size: 0.65rem;
        }

        .cascade-step-title {
            font-weight: 600;
            color: #3B82F6;
            margin-bottom: 2px;
            font-size: 0.7rem;
        }

        /* Treatment Button */
        .treatment-btn {
            width: 100%;
            padding: 16px 24px;
            background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.4);
        }

        .treatment-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .treatment-btn:disabled {
            background: #94A3B8;
            cursor: not-allowed;
            box-shadow: none;
        }

        .treatment-btn.applied {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.4);
        }

        .treatment-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Simulation Wizard */
        .simulation-wizard {
            width: 100%;
            padding: 8px;
            background: #F8FAFC;
            border-radius: 6px;
            border: 1px solid #E2E8F0;
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .wizard-step {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 4px;
            opacity: 0.5;
            transition: all 0.2s;
        }

        .wizard-step.active {
            opacity: 1;
            background: #E0F2FE;
            border: 1px solid #0EA5E9;
        }

        .wizard-step.completed {
            opacity: 0.7;
            background: #D1FAE5;
        }

        .step-number {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #CBD5E1;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.6rem;
            flex-shrink: 0;
        }

        .wizard-step.active .step-number {
            background: #0EA5E9;
        }

        .wizard-step.completed .step-number {
            background: #10B981;
        }

        .step-content {
            flex: 1;
            min-width: 0;
        }

        .step-title {
            font-weight: 600;
            color: #1E293B;
            font-size: 0.7rem;
            margin-bottom: 1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .step-desc {
            font-size: 0.6rem;
            color: #64748B;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Start Button */
        .start-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .start-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .start-btn.paused {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
        }

        /* Reset Button */
        .reset-btn {
            width: 100%;
            padding: 10px;
            background: transparent;
            color: #64748B;
            border: 2px solid #E2E8F0;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .reset-btn:hover {
            border-color: #CBD5E1;
            background: #F8FAFC;
            color: #475569;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #64748B;
        }

        .legend-dot {
            position: relative;
            display: inline-block;
        }

        /* Plaqueta: circular gris con highlight */
        .legend-dot.platelet {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #808080;
            box-shadow: 
                0 0 2px rgba(100, 100, 100, 0.3),
                inset -2px -2px 2px rgba(220, 220, 220, 0.4);
            position: relative;
        }
        
        .legend-dot.platelet::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(220, 220, 220, 0.7);
        }

        /* Gl√≥bulo rojo: ovalado con highlight */
        .legend-dot.rbc {
            width: 14px;
            height: 10px;
            border-radius: 50%;
            background: #B91C1C;
            box-shadow: 
                0 0 3px rgba(139, 0, 0, 0.4),
                inset -2px -1px 2px rgba(139, 0, 0, 0.2);
            position: relative;
        }
        
        .legend-dot.rbc::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 3px;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 200, 200, 0.8);
        }

        /* Gl√≥bulo blanco: circular con highlight brillante y contorno */
        .legend-dot.wbc {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #87CEEB;
            border: 1.5px solid #4A90E2;
            box-shadow: 
                0 0 2px rgba(74, 144, 226, 0.3),
                inset -4px -4px 6px rgba(255, 255, 255, 0.6);
            position: relative;
        }
        
        .legend-dot.wbc::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.6) 50%, rgba(255, 255, 255, 0) 100%);
        }
        
        .legend-dot.wbc::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 1);
        }

        /* Fibrina: morada con efecto de brillo */
        .legend-dot.fibrin {
            width: 24px;
            height: 3px;
            border-radius: 2px;
            background: #9D4EDD;
            box-shadow: 0 0 4px rgba(157, 78, 221, 0.6);
        }
        
        .legend-dot.vwf {
            width: 20px;
            height: 2px;
            border-radius: 1px;
            background: #22C55E;
            box-shadow: 0 0 3px rgba(34, 197, 94, 0.5);
        }

        /* Hemostasis Achieved Overlay */
        .hemostasis-achieved {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(16, 185, 129, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            display: none;
            align-items: center;
            gap: 6px;
            animation: fadeIn 0.5s;
        }

        .hemostasis-achieved.visible {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                max-width: 100%;
                padding: 16px;
            }
            
            .viewer-container {
                max-width: 100%;
            }
            
            .control-panel {
                max-width: 100%;
                grid-template-columns: 1fr;
            }
            
            .controls-metrics-container {
                flex-direction: column;
                gap: 20px;
            }
            
            .metrics-section {
                min-width: auto;
            }
        }
        
        @media (max-width: 768px) {
            .main-container {
                padding: 12px;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .controls-metrics-container {
                flex-direction: column;
                gap: 20px;
            }
            
            .metrics-section {
                min-width: auto;
            }
            
            .header {
                padding: 12px 16px;
                flex-direction: column;
                gap: 12px;
            }
            
            .header-title h1 {
                font-size: 1.1rem;
            }
            
            .header-icon {
                width: 32px;
                height: 32px;
            }
            
            .viewer-container {
                border-radius: 12px;
            }
            
            .panel-card {
                padding: 16px;
            }
            
            .panel-title {
                font-size: 0.7rem;
                margin-bottom: 12px;
            }
            
            .condition-btn, .treatment-btn, .start-btn, .reset-btn {
                padding: 10px 16px;
                font-size: 0.875rem;
            }
            
            /* Contadores removidos */
            
            .label-wound {
                font-size: 0.65rem;
                padding: 4px 8px;
                top: auto;
                bottom: 20px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
            }
            
            .treatment-indicator, .hemostasis-achieved {
                font-size: 0.875rem;
                padding: 8px 16px;
            }
            
            .legend {
                flex-wrap: wrap;
                gap: 8px;
                padding: 12px;
            }
            
            .legend-item {
                font-size: 0.75rem;
            }
            
            .wizard-step {
                padding: 8px 12px;
                font-size: 0.875rem;
            }
        }
        
        @media (max-width: 480px) {
            .main-container {
                padding: 8px;
            }
            
            .header {
                padding: 8px 12px;
            }
            
            .header-title h1 {
                font-size: 1rem;
            }
            
            .viewer-container {
                border-radius: 8px;
            }
            
            .panel-card {
                padding: 12px;
            }
            
            .condition-btn, .treatment-btn, .start-btn, .reset-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            /* Contadores removidos */
            
            .label-wound {
                font-size: 0.6rem;
                padding: 3px 6px;
                bottom: 16px;
            }
            
            .legend {
                padding: 8px;
                gap: 6px;
            }
            
            .legend-item {
                font-size: 0.7rem;
            }
            
            .wizard-step {
                padding: 6px 10px;
                font-size: 0.8rem;
            }
        }

        /* Fibrin glow effect when treatment applied */
        .fibrin-glow {
            filter: drop-shadow(0 0 8px #00E676) drop-shadow(0 0 16px #00E676);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-title">
            <div class="header-icon">
                <svg viewBox="0 0 24 24"><path d="M12 2C13.1 2 14 2.9 14 4C14 4.74 13.6 5.39 13 5.73V7H14C17.31 7 20 9.69 20 13V20C20 21.1 19.1 22 18 22H6C4.9 22 4 21.1 4 20V13C4 9.69 6.69 7 10 7H11V5.73C10.4 5.39 10 4.74 10 4C10 2.9 10.9 2 12 2M7.5 13C6.67 13 6 13.67 6 14.5C6 15.33 6.67 16 7.5 16C8.33 16 9 15.33 9 14.5C9 13.67 8.33 13 7.5 13M16.5 13C15.67 13 15 13.67 15 14.5C15 15.33 15.67 16 16.5 16C17.33 16 18 15.33 18 14.5C18 13.67 17.33 13 16.5 13M12 9C10.34 9 9 10.34 9 12H15C15 10.34 13.66 9 12 9Z"/></svg>
            </div>
            <h1>Laboratorio Virtual de Hemostasia</h1>
        </div>
        <div class="header-status">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Simulaci√≥n activa</span>
            </div>
        </div>
    </header>

    <main class="main-container">
        <section class="viewer-section">
            <div class="viewer-container">
                <div class="viewer-labels">
                    <div class="label label-wound" id="wound-label">‚ö†Ô∏è Lesi√≥n Activa</div>
                </div>
                <div class="treatment-indicator" id="treatment-indicator">
                    üíâ Tratamiento Administrado
                </div>
                <div class="hemostasis-achieved" id="hemostasis-indicator">
                    ‚úì Hemostasia Lograda
                </div>
                <canvas id="simulation-canvas"></canvas>
            </div>
            <div class="legend">
                <div class="legend-item tooltip-container">
                    <div class="legend-dot platelet"></div> 
                    <span class="tooltip-trigger">Plaquetas</span>
                    <div class="tooltip">C√©lulas sangu√≠neas peque√±as que se adhieren a la herida y forman el tap√≥n inicial. Se activan al contacto con el col√°geno expuesto.</div>
                </div>
                <div class="legend-item tooltip-container">
                    <div class="legend-dot rbc"></div> 
                    <span class="tooltip-trigger">Gl√≥bulos Rojos</span>
                    <div class="tooltip">Eritrocitos que transportan ox√≠geno. No participan directamente en la coagulaci√≥n pero pueden quedar atrapados en el co√°gulo.</div>
                </div>
                <div class="legend-item tooltip-container">
                    <div class="legend-dot wbc"></div> 
                    <span class="tooltip-trigger">Gl√≥bulos Blancos</span>
                    <div class="tooltip">Leucocitos que participan en la respuesta inmune. Pueden ayudar en la limpieza de la herida.</div>
                </div>
                <div class="legend-item tooltip-container">
                    <div class="legend-dot fibrin"></div> 
                    <span class="tooltip-trigger">Red de Fibrina</span>
                    <div class="tooltip">Prote√≠na formada a partir del fibrin√≥geno por acci√≥n de la trombina. Crea una malla que refuerza el tap√≥n plaquetario.</div>
                </div>
                <div class="legend-item tooltip-container">
                    <div class="legend-dot vwf"></div> 
                    <span class="tooltip-trigger">Factor von Willebrand</span>
                    <div class="tooltip">Prote√≠na que media la adhesi√≥n de las plaquetas al col√°geno expuesto. Esencial para el inicio de la hemostasia.</div>
                </div>
            </div>
        </section>

        <section class="control-panel">
            <div class="panel-card">
                <div class="panel-title">
                    <svg viewBox="0 0 24 24"><path d="M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"/></svg>
                    Condici√≥n Cl√≠nica
                </div>
                <div class="condition-grid">
                    <button class="condition-btn active" data-condition="normal">
                        <div class="condition-name">Normal</div>
                        <div class="condition-desc">Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente</div>
                    </button>
                    <button class="condition-btn" data-condition="hemophilia">
                        <div class="condition-name">Hemofilia A/B</div>
                        <div class="condition-desc">D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable</div>
                    </button>
                    <button class="condition-btn" data-condition="vwd">
                        <div class="condition-name">Von Willebrand</div>
                        <div class="condition-desc">D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida</div>
                    </button>
                    <button class="condition-btn" data-condition="thrombocytopenia">
                        <div class="condition-name">Trombocitopenia</div>
                        <div class="condition-desc">Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo</div>
                    </button>
                    <button class="condition-btn" data-condition="hemophiliaSevere">
                        <div class="condition-name">Hemofilia Severa</div>
                        <div class="condition-desc">D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado</div>
                    </button>
                    <button class="condition-btn" data-condition="thrombasthenia">
                        <div class="condition-name">Trombastenia</div>
                        <div class="condition-desc">D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠</div>
                    </button>
                    <button class="condition-btn" data-condition="factorDeficiency">
                        <div class="condition-name">D√©ficit Factor VII</div>
                        <div class="condition-desc">V√≠a extr√≠nseca defectuosa - Formaci√≥n de fibrina reducida</div>
                    </button>
                    <button class="condition-btn" data-condition="anticoagulated">
                        <div class="condition-name">Anticoagulado</div>
                        <div class="condition-desc">Warfarina - Factores dependientes de vitamina K reducidos, fibrina inestable</div>
                    </button>
                </div>
            </div>

            <div class="panel-card">
                <!-- Botones y M√©tricas en layout horizontal -->
                <div class="controls-metrics-container">
                    <div class="controls-section">
                        <!-- Simulation Wizard -->
                        <div class="simulation-wizard">
                            <div class="wizard-step active" data-step="1">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <div class="step-title">Selecciona condici√≥n</div>
                                    <div class="step-desc">Elige una condici√≥n cl√≠nica arriba</div>
                                </div>
                            </div>
                            <div class="wizard-step" data-step="2">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <div class="step-title">Configura par√°metros</div>
                                    <div class="step-desc">Opcional: ajusta tratamiento</div>
                                </div>
                            </div>
                            <div class="wizard-step" data-step="3">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <div class="step-title">Inicia simulaci√≥n</div>
                                    <div class="step-desc">Presiona el bot√≥n Iniciar</div>
                                </div>
                            </div>
                        </div>
                        <button class="start-btn" id="start-btn">‚ñ∂ Iniciar Simulaci√≥n</button>
                        <button class="treatment-btn" id="treatment-btn">
                            <svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg>
                            Administrar Tratamiento
                        </button>
                        <button class="reset-btn" id="reset-btn">‚Üª Reiniciar Simulaci√≥n</button>
                    </div>
                    
                    <div class="metrics-section">
                <div class="panel-title">
                    <svg viewBox="0 0 24 24"><path d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"/></svg>
                    M√©tricas en Tiempo Real
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-value blood-loss" id="blood-loss">0</div>
                        <div class="metric-label">P√©rdida Sangu√≠nea</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-value clot-progress" id="clot-percentage">0%</div>
                                <div class="metric-label">Cierre de la Herida</div>
                    </div>
                </div>
                <div class="clot-progress-bar">
                    <div class="clot-progress-fill" id="clot-bar"></div>
                </div>
                
                <!-- Controles de velocidad -->
                <div class="simulation-controls">
                    <div class="speed-control">
                        <label>Velocidad:</label>
                        <input type="range" class="speed-slider" id="speed-slider" min="0.25" max="2" step="0.25" value="1">
                        <span id="speed-value">1x</span>
                    </div>
                </div>
                
                <!-- M√©tricas avanzadas -->
                <div class="advanced-metrics">
                    <div class="advanced-metric">
                        <div class="advanced-metric-label">Tiempo hasta cierre de herida</div>
                        <div class="advanced-metric-value" id="first-adhesion-time">--</div>
                    </div>
                    <div class="advanced-metric">
                        <div class="advanced-metric-label">Velocidad formaci√≥n fibrina</div>
                        <div class="advanced-metric-value" id="fibrin-rate">0/min</div>
                    </div>
                    <div class="advanced-metric">
                        <div class="advanced-metric-label">Densidad del co√°gulo</div>
                        <div class="advanced-metric-value" id="clot-density">0</div>
                    </div>
                    <div class="advanced-metric">
                        <div class="advanced-metric-label">Tasa de agregaci√≥n</div>
                        <div class="advanced-metric-value" id="aggregation-rate">0%</div>
                    </div>
                </div>
                
                <!-- Gr√°ficos en tiempo real -->
                <div class="charts-container">
                    <div class="chart-panel">
                        <div class="chart-title">
                            <span>üìà</span> Evoluci√≥n del Cierre de la Herida
                        </div>
                        <canvas class="chart-canvas" id="clot-chart"></canvas>
                    </div>
                    <div class="chart-panel">
                        <div class="chart-title">
                            <span>ü©∏</span> P√©rdida Sangu√≠nea Acumulada
                        </div>
                        <canvas class="chart-canvas" id="blood-loss-chart"></canvas>
                    </div>
                    <div class="chart-panel">
                        <div class="chart-title">
                            <span>üï∏Ô∏è</span> Formaci√≥n de Red de Fibrina
                        </div>
                        <canvas class="chart-canvas" id="fibrin-chart"></canvas>
                    </div>
                </div>
                
                <!-- Panel educativo expandible -->
                <div class="educational-panel" id="educational-panel">
                    <div class="educational-panel-header" id="educational-toggle">
                        <div class="educational-panel-title">
                            <span>üìö</span> Informaci√≥n Educativa
                        </div>
                        <span id="educational-arrow">‚ñº</span>
                    </div>
                    <div class="educational-panel-content">
                        <div class="educational-section">
                            <h4>Condici√≥n Actual: <span id="current-condition-name">Normal</span></h4>
                            <p id="current-condition-desc">Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente</p>
                        </div>
                        <div class="educational-section">
                            <h4>Cascada de Coagulaci√≥n</h4>
                            <p>La coagulaci√≥n sangu√≠nea es un proceso complejo que involucra m√∫ltiples factores:</p>
                            <div class="coagulation-cascade">
                                <div class="cascade-step">
                                    <div class="cascade-step-title">V√≠a Intr√≠nseca</div>
                                    <div>Factores XII, XI, IX, VIII</div>
                                </div>
                                <div class="cascade-step">
                                    <div class="cascade-step-title">V√≠a Extr√≠nseca</div>
                                    <div>Factor VII + Factor Tisular</div>
                                </div>
                                <div class="cascade-step">
                                    <div class="cascade-step-title">V√≠a Com√∫n</div>
                                    <div>Factores X, V, II (Trombina)</div>
                                </div>
                                <div class="cascade-step">
                                    <div class="cascade-step-title">Formaci√≥n de Fibrina</div>
                                    <div>Fibrin√≥geno ‚Üí Fibrina</div>
                                </div>
                            </div>
                        </div>
                        <div class="educational-section">
                            <h4>Proceso de Hemostasia</h4>
                            <p><strong>1. Vasoconstricci√≥n:</strong> Los vasos se contraen para reducir el flujo sangu√≠neo.</p>
                            <p><strong>2. Adhesi√≥n Plaquetaria:</strong> Las plaquetas se adhieren al col√°geno expuesto usando el factor von Willebrand.</p>
                            <p><strong>3. Agregaci√≥n Plaquetaria:</strong> Las plaquetas se unen entre s√≠ formando un tap√≥n primario.</p>
                            <p><strong>4. Coagulaci√≥n:</strong> La cascada de coagulaci√≥n forma fibrina que refuerza el tap√≥n.</p>
                            <p><strong>5. Retracci√≥n:</strong> El co√°gulo se contrae y estabiliza.</p>
                        </div>
                    </div>
                </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // Matter.js modules
        const { Engine, Render, Runner, Bodies, Body, Composite, Constraint, Events, Vector } = Matter;

        // Simulation Configuration
        const CONFIG = {
            canvas: {
                width: 1300,
                height: 300
            },
            wound: {
                x: 550, // Center
                width: 300,
                height: 20
            },
            wall: {
                thickness: 30, // Increased thickness to prevent particles from passing through
                color: '#FDA4AF'
            },
            physics: {
                flowForce: 0.0004,
                suctionForce: 0.0015, // Aumentado para hacer la succi√≥n m√°s fuerte
                suctionRadius: 180
            },
            particles: {
                maxCount: 150, // Reduced for better performance
                spawnRate: 3, // Reduced for better performance
                plateletRatio: 0.35,
                rbcRatio: 0.60,
                wbcRatio: 0.05
            },
            fibrin: {
                maxConnections: 200, // Limit fibrin connections to prevent performance issues
                maxConnectionsPerPlatelet: 8 // Limit connections per platelet
            },
            stuckPlatelets: {
                maxCount: 80 // L√≠mite m√°ximo de plaquetas pegadas para mantener rendimiento
            },
            conditions: {
                normal: {
                    name: "Normal",
                    description: "Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 1.0,
                    fibrinStability: 1.0,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    bleedingTime: 3,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: false, // Puede sellarse autom√°ticamente
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                hemophilia: {
                    name: "Hemofilia A/B",
                    description: "D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.15,
                    fibrinStability: 0.3,
                    fibrinDecayRate: 0.03,
                    fibrinFormationDelay: 1500,
                    bleedingTime: 30,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FF6B6B',
                        fibrinGlow: false,
                        fibrinOpacity: 0.6
                    }
                },
                vwd: {
                    name: "Enfermedad de Von Willebrand",
                    description: "D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.2,
                    plateletFunction: 0.4,
                    adhesionStrength: 0.25,
                    aggregationRate: 0.3,
                    fibrinFormationRate: 0.7,
                    fibrinStability: 0.85,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    plateletBounceFactor: 0.7,
                    adhesionRetryChance: 0.4,
                    bleedingTime: 15,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: true, // Requiere tratamiento para sellado completo
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                thrombocytopenia: {
                    name: "Trombocitopenia",
                    description: "Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo",
                    plateletRatio: 0.08,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.6,
                    fibrinStability: 0.8,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    spawnRateMultiplier: 0.3,
                    bleedingTime: 20,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: false,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                hemophiliaSevere: {
                    name: "Hemofilia Severa",
                    description: "D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: false,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.0,
                    fibrinStability: 0.0,
                    fibrinDecayRate: 0.2,
                    fibrinFormationDelay: 0,
                    bleedingTime: 60,
                    blockThickCords: true, // Bloquear todas las cuerdas gruesas
                    blockMediumCords: true, // Solo cuerdas peque√±as permitidas
                    blockThinCords: false,
                    requiresTreatment: true,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FF0000',
                        fibrinGlow: false,
                        fibrinOpacity: 0.3
                    }
                },
                thrombasthenia: {
                    name: "Trombastenia de Glanzmann",
                    description: "D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.9,
                    plateletFunction: 0.2,
                    adhesionStrength: 0.85,
                    aggregationRate: 0.1,
                    fibrinFormationRate: 0.4,
                    fibrinStability: 0.6,
                    fibrinDecayRate: 0.01,
                    fibrinFormationDelay: 500,
                    maxPlateletClusterSize: 2,
                    bleedingTime: 25,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: true,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FFA500',
                        fibrinGlow: false,
                        fibrinOpacity: 0.8
                    }
                },
                factorDeficiency: {
                    name: "D√©ficit Factor VII",
                    description: "D√©ficit Factor VII - V√≠a extr√≠nseca defectuosa, formaci√≥n de fibrina reducida",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.5,
                    fibrinStability: 0.75,
                    fibrinDecayRate: 0.01,
                    fibrinFormationDelay: 1000,
                    bleedingTime: 12,
                    blockThickCords: false,
                    blockMediumCords: true, // Bloquear cuerdas medianas y peque√±as
                    blockThinCords: true, // Solo cuerdas gruesas (pero d√©biles)
                    requiresTreatment: false,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FFD700',
                        fibrinGlow: false,
                        fibrinOpacity: 0.9
                    }
                },
                anticoagulated: {
                    name: "Anticoagulado (Warfarina)",
                    description: "Anticoagulaci√≥n oral - Factores dependientes de vitamina K reducidos, fibrina inestable",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.4,
                    fibrinStability: 0.5,
                    fibrinDecayRate: 0.05,
                    fibrinFormationDelay: 800,
                    bleedingTime: 8,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FF6347',
                        fibrinGlow: false,
                        fibrinOpacity: 0.7
                    }
                }
            }
        };

        // Game State
        let state = {
            condition: 'normal',
            treatmentApplied: false,
            bloodLoss: 0,
            clotPercentage: 0,
            hemostasisAchieved: false,
            stuckPlatelets: [],
            fibrinConstraints: [],
            fibrinBodies: [], // Physical bodies for fibrin network
            allBodies: [],
            showOintment: false,
            fibrinFormationStarted: false, // Secuencia: plaquetas primero, luego malla
            simulationRunning: false, // Control manual de simulaci√≥n
            currentStep: 1, // Paso actual del wizard
            // M√©tricas avanzadas
            startTime: null,
            firstAdhesionTime: null,
            woundClosureTime: null,
            fibrinFormationRate: 0,
            clotDensity: 0,
            totalPlateletsSpawned: 0,
            failedAdhesions: 0,
            aggregationRate: 0,
            // Datos hist√≥ricos para gr√°ficos
            history: {
                time: [],
                clotPercentage: [],
                bloodLoss: [],
                fibrinConnections: [],
                stuckPlatelets: []
            },
            // Controles de velocidad
            timeScale: 1.0,
            isPaused: false
        };

        // Spawn timing for fixed interval
        let spawnInterval = null;
        let lastSpawnTime = 0;
        // spawnIntervalCounter removido
        let actualSpawnIntervals = []; // Array para calcular el intervalo promedio
        const SPAWN_INTERVAL_MS = 100; // Fixed spawn interval in milliseconds
        
        // Performance optimization: frame counters for throttling
        let frameCount = 0;
        const CLEANUP_INTERVAL = 5; // Cleanup every 5 frames (m√°s frecuente para mejor limpieza)
        const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames
        
        // Fixed timestep loop variables - garantizar velocidad constante independiente del FPS
        let physicsLoopId = null;
        let renderLoopId = null;
        let lastPhysicsTime = 0;
        const FIXED_TIMESTEP = 1000 / 60; // 16.67ms = 60 FPS fijo para f√≠sica
        let accumulatedTime = 0;
        let accumulatedSimulationTime = 0; // Tiempo de simulaci√≥n acumulado (ajustado por timeScale)
        let lastSimulationTimeUpdate = 0; // √öltima vez que se actualiz√≥ el tiempo de simulaci√≥n

        // Matter.js Setup
        let engine, render, runner;

        function initSimulation() {
            // Clear spawn timeout
            if (spawnInterval !== null) {
                clearTimeout(spawnInterval);
                spawnInterval = null;
            }
            // spawnIntervalCounter removido
            
            lastSpawnTime = 0;
            actualSpawnIntervals = [];
            spawnStats = {
                lastSpawnCount: 0,
                totalSpawned: 0,
                spawnHistory: []
            };

            // Reset state (preservar propiedades nuevas)
            state = {
                condition: state.condition,
                treatmentApplied: false,
                bloodLoss: 0,
                clotPercentage: 0,
                hemostasisAchieved: false,
                stuckPlatelets: [],
                fibrinConstraints: [],
                fibrinBodies: [],
                allBodies: [],
                showOintment: false,
                fibrinFormationStarted: false,
                simulationRunning: false,
                currentStep: state.currentStep || 1,
                // M√©tricas avanzadas
                startTime: null,
                firstAdhesionTime: null,
                woundClosureTime: null,
                fibrinFormationRate: 0,
                clotDensity: 0,
                totalPlateletsSpawned: 0,
                failedAdhesions: 0,
                aggregationRate: 0,
                // Datos hist√≥ricos para gr√°ficos
                history: {
                    time: [],
                    clotPercentage: [],
                    bloodLoss: [],
                    fibrinConnections: [],
                    stuckPlatelets: []
                },
                // Controles de velocidad
                timeScale: state.timeScale || 1.0,
                isPaused: false
            };

            // FPS counter removed

            // Clear previous engine events
            if (engine) {
                Events.off(engine, 'beforeUpdate');
                Events.off(engine, 'afterUpdate');
                Events.off(engine, 'collisionStart');
                // Remove anchor platelets before clearing world
                if (state.stuckPlatelets) {
                    state.stuckPlatelets.forEach(plateletData => {
                        if (plateletData.isAnchor && plateletData.body) {
                            Composite.remove(engine.world, plateletData.body);
                        }
                    });
                }
                Composite.clear(engine.world);
                Engine.clear(engine);
            }
            if (render) {
                Events.off(render, 'afterRender');
                Render.stop(render);
            }
            // No necesitamos detener el runner porque usamos nuestro propio loop
            // if (runner) {
            //     Runner.stop(runner);
            // }
            
            // Reset canvas
            const canvas = document.getElementById('simulation-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset state
            state.fibrinFormationStarted = false;
            state.simulationRunning = false;
            state.currentStep = 1;

            // Reset UI elements
            document.getElementById('hemostasis-indicator').classList.remove('visible');
            const woundLabel = document.getElementById('wound-label');
            woundLabel.classList.remove('healed', 'hidden');
            woundLabel.innerHTML = '‚ö†Ô∏è Lesi√≥n Activa';
            
            const treatmentBtn = document.getElementById('treatment-btn');
            treatmentBtn.classList.remove('applied');
            treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg> Administrar Tratamiento`;
            treatmentBtn.disabled = false;

            // Create engine with zero gravity
            engine = Engine.create();
            engine.world.gravity.x = 0;
            engine.world.gravity.y = 0;

            // Create renderer using existing canvas
            const canvasEl = document.getElementById('simulation-canvas');
            
            // Guardar el ancho original del canvas
            const originalCanvasWidth = CONFIG.canvas.width;
            const fixedCanvasHeight = CONFIG.canvas.height; // 300px fijo
            
            // Ajustar tama√±o del canvas seg√∫n el tama√±o de la pantalla
            // Mantener altura fija, solo ajustar ancho
            const updateCanvasSize = () => {
                const container = canvasEl.parentElement;
                const containerWidth = container.clientWidth;
                const maxWidth = Math.min(originalCanvasWidth, containerWidth - 32); // 32px de padding
                
                // Mantener altura fija, solo ajustar ancho
                canvasEl.width = maxWidth;
                canvasEl.height = fixedCanvasHeight;
                
                // Actualizar CONFIG para que la f√≠sica use el nuevo tama√±o
                CONFIG.canvas.width = maxWidth;
                CONFIG.canvas.height = fixedCanvasHeight;
                
                // Mantener la herida siempre centrada
                CONFIG.wound.x = maxWidth / 2;
                
                // Si el engine ya existe, necesitamos recrear las paredes con el nuevo tama√±o
                if (engine && state.simulationRunning === false) {
                    // Solo recrear si la simulaci√≥n no est√° corriendo
                    // Las paredes se recrear√°n en el siguiente initSimulation
                }
            };
            
            updateCanvasSize();
            
            // Actualizar tama√±o cuando cambia el tama√±o de la ventana
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateCanvasSize();
                    // Si la simulaci√≥n est√° corriendo, reiniciar para aplicar los cambios
                    if (state.simulationRunning) {
                        const wasRunning = state.simulationRunning;
                        state.simulationRunning = false;
                        initSimulation();
                        if (wasRunning) {
                            setTimeout(() => {
                                state.simulationRunning = true;
                                lastPhysicsTime = 0;
                                accumulatedTime = 0;
                            }, 100);
                        }
                    }
                }, 250);
            });
            
            render = Render.create({
                canvas: canvasEl,
                engine: engine,
                options: {
                    width: canvasEl.width,
                    height: canvasEl.height,
                    wireframes: false,
                    background: 'transparent', // Fondo transparente - dibujamos nosotros
                    // Desacoplar el renderer del timestep de la f√≠sica
                    // El renderer se actualiza a su propio ritmo, pero la f√≠sica siempre usa timestep fijo
                    pixelRatio: window.devicePixelRatio || 1
                }
            });
            
            // Asegurar que el engine siempre use timestep fijo
            engine.timing.timeScale = 1.0;
            engine.timing.timestamp = 0;

            // Create vessel walls
            createVesselWalls();

            // Start engine and renderer with fixed timestep
            // Configurar el engine para usar timestep fijo
            engine.timing.timeScale = 1.0; // Asegurar que el timeScale sea 1.0
            
            // Crear Runner pero NO ejecutarlo autom√°ticamente
            // Usaremos nuestro propio loop con timestep fijo garantizado
            runner = Runner.create({
                delta: FIXED_TIMESTEP,
                isFixed: true,
                enabled: false // Deshabilitar el loop autom√°tico
            });
            
            // Loop de renderizado independiente (puede ejecutarse a cualquier FPS)
            function renderLoop() {
                if (render) {
                    Render.world(render);
                }
                renderLoopId = requestAnimationFrame(renderLoop);
            }
            
            // Iniciar el loop de renderizado (siempre activo)
            renderLoop();
            
            // Loop de f√≠sica con timestep fijo (solo se ejecuta cuando simulationRunning = true)
            function physicsLoop(currentTime) {
                if (!state.simulationRunning) {
                    physicsLoopId = requestAnimationFrame(physicsLoop);
                    return;
                }
                
                // Calcular tiempo transcurrido desde el √∫ltimo frame
                if (lastPhysicsTime === 0) {
                    lastPhysicsTime = currentTime;
                }
                
                const deltaTime = currentTime - lastPhysicsTime;
                lastPhysicsTime = currentTime;
                
                // Acumular tiempo y ejecutar pasos de f√≠sica a intervalos fijos
                accumulatedTime += deltaTime;
                
                // Acumular tiempo de simulaci√≥n ajustado por timeScale (solo cuando est√° corriendo y no pausada)
                if (!state.isPaused && state.simulationRunning) {
                    const timeScale = state.timeScale || 1.0;
                    accumulatedSimulationTime += deltaTime * timeScale;
                }
                
                // Ejecutar tantos pasos de f√≠sica como sean necesarios para mantener timestep fijo
                // Ajustar el n√∫mero de pasos seg√∫n timeScale para acelerar la simulaci√≥n
                const timeScale = state.timeScale || 1.0;
                const maxSteps = 5; // Limitar pasos por frame para evitar "spiral of death"
                let stepsExecuted = 0;
                
                // Ejecutar m√∫ltiples pasos seg√∫n timeScale, pero mantener timestep fijo
                // Esto acelera la simulaci√≥n sin afectar la estabilidad f√≠sica
                const stepsToExecute = Math.max(1, Math.ceil(timeScale));
                
                while (accumulatedTime >= FIXED_TIMESTEP && stepsExecuted < maxSteps) {
                    // Solo ejecutar f√≠sica si no est√° pausada
                    if (!state.isPaused && state.simulationRunning) {
                        // Ejecutar m√∫ltiples pasos de f√≠sica con timestep fijo para acelerar la simulaci√≥n
                        // En lugar de escalar el timestep, ejecutamos m√°s pasos por iteraci√≥n
                        // Esto mantiene la f√≠sica estable pero acelera la simulaci√≥n
                        for (let i = 0; i < stepsToExecute; i++) {
                            Engine.update(engine, FIXED_TIMESTEP);
                        }
                    }
                    // Restar el tiempo correspondiente a los pasos ejecutados
                    accumulatedTime -= FIXED_TIMESTEP;
                    stepsExecuted++;
                }
                
                // Si acumulamos demasiado tiempo, resetear para evitar lag
                if (accumulatedTime > FIXED_TIMESTEP * 5) {
                    accumulatedTime = 0;
                }
                
                physicsLoopId = requestAnimationFrame(physicsLoop);
            }
            
            // Iniciar el loop de f√≠sica (siempre activo, pero solo procesa cuando simulationRunning = true)
            // Resetear variables de tiempo
            lastPhysicsTime = 0;
            accumulatedTime = 0;
            
            // Iniciar el loop de f√≠sica
            if (!physicsLoopId) {
                physicsLoopId = requestAnimationFrame(physicsLoop);
            }
            
            // Estado inicial: simulaci√≥n no corriendo
            state.simulationRunning = false;

            // Setup collision events
            setupCollisionEvents();

            // Start particle spawning
            startParticleSpawning();

            // Reset frame counter
            frameCount = 0;
            
            // Update loop for forces - use fixed timestep for frame-independent forces
            // Con isFixed: true, el Runner ejecuta pasos de f√≠sica a intervalos fijos
            // Cada paso siempre es de 16.67ms, independientemente del FPS del renderer
            Events.on(engine, 'beforeUpdate', () => {
                // Solo actualizar si la simulaci√≥n est√° corriendo y no est√° pausada
                if (!state.simulationRunning || state.isPaused) return;
                
                frameCount++;
                // Aplicar fuerzas con timestep fijo (el timeScale se maneja ejecutando m√∫ltiples pasos de f√≠sica)
                // Esto asegura que las fuerzas de adhesi√≥n funcionen correctamente independientemente de la velocidad
                applyForces(runner.delta);
                
                // Update fibrin barrier positions to follow platelets (every 3 frames for performance)
                if (frameCount % 3 === 0 && state.fibrinConstraints.length > 0) {
                    state.fibrinConstraints.forEach(fibrin => {
                        if (fibrin.body && fibrin.pointA && fibrin.pointB) {
                            const midX = (fibrin.pointA.position.x + fibrin.pointB.position.x) / 2;
                            const midY = (fibrin.pointA.position.y + fibrin.pointB.position.y) / 2;
                            const dist = Vector.magnitude(Vector.sub(fibrin.pointB.position, fibrin.pointA.position));
                            const angle = Math.atan2(
                                fibrin.pointB.position.y - fibrin.pointA.position.y,
                                fibrin.pointB.position.x - fibrin.pointA.position.x
                            );
                            
                            Body.setPosition(fibrin.body, { x: midX, y: midY });
                            Body.setAngle(fibrin.body, angle);
                            // Update width to match distance
                            const currentWidth = fibrin.body.bounds.max.x - fibrin.body.bounds.min.x;
                            if (Math.abs(currentWidth - dist) > 1) {
                                Body.scale(fibrin.body, dist / currentWidth, 1);
                            }
                        }
                    });
                }
                
                // Throttle expensive operations
                if (frameCount % CLEANUP_INTERVAL === 0) {
                    cleanupParticles();
                    // Tambi√©n limpiar plaquetas pegadas antiguas peri√≥dicamente
                    cleanupOldStuckPlatelets();
                }
                if (frameCount % UI_UPDATE_INTERVAL === 0) {
                    calculateClotPercentage();
                    updateUI();
                }
                
                // vWF se renderiza como l√≠neas entre plaquetas (no necesita actualizaci√≥n)
            });

            // Custom render - todo en afterRender, en orden: fondo, paredes, fibrina, vWF, part√≠culas
            Events.on(render, 'afterRender', renderVesselBackground);
            Events.on(render, 'afterRender', renderVesselWalls);
            Events.on(render, 'afterRender', renderFibrin);
            Events.on(render, 'afterRender', renderVWF); // vWF se renderiza despu√©s de las cuerdas
            Events.on(render, 'afterRender', renderParticlesCustom);

            // Update UI
            updateUI();
        }
        
        // FPS Counter removido

        function createVesselWalls() {
            const { width, height } = CONFIG.canvas;
            const { thickness, color } = CONFIG.wall;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;

            // Bottom wall (solid) - with bounce and collision filter
            const bottomWall = Bodies.rectangle(width / 2, height - thickness / 2, width, thickness, {
                isStatic: true,
                render: { visible: false }, // Renderizado personalizado
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Top wall - Left segment - with bounce and collision filter
            const leftWallWidth = woundX - woundWidth / 2;
            const topWallLeft = Bodies.rectangle(leftWallWidth / 2, thickness / 2, leftWallWidth, thickness, {
                isStatic: true,
                render: { visible: false }, // Renderizado personalizado
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Top wall - Right segment - with bounce and collision filter
            const rightWallStart = woundX + woundWidth / 2;
            const rightWallWidth = width - rightWallStart;
            const topWallRight = Bodies.rectangle(rightWallStart + rightWallWidth / 2, thickness / 2, rightWallWidth, thickness, {
                isStatic: true,
                render: { visible: false }, // Renderizado personalizado
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Wound edge markers (left and right edges of wound)
            const woundEdgeLeft = Bodies.rectangle(woundX - woundWidth / 2, thickness / 2, 6, thickness + 10, {
                isStatic: true,
                render: { visible: false }, // Renderizado personalizado
                label: 'woundEdge',
                isSensor: false,
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            const woundEdgeRight = Bodies.rectangle(woundX + woundWidth / 2, thickness / 2, 6, thickness + 10, {
                isStatic: true,
                render: { visible: false }, // Renderizado personalizado
                label: 'woundEdge',
                isSensor: false,
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            Composite.add(engine.world, [bottomWall, topWallLeft, topWallRight, woundEdgeLeft, woundEdgeRight]);
            
            // Create invisible anchor platelets on each side of the wound
            createInvisibleAnchorPlatelets(woundX, woundWidth, thickness);
        }
        
        function createInvisibleAnchorPlatelets(woundX, woundWidth, wallThickness) {
            const adhesionLineY = 23; // Same Y position as the adhesion line
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            // Left anchor platelet - positioned just inside the left edge of the wound
            const leftAnchorX = woundLeft + 2;
            const leftAnchor = Bodies.circle(leftAnchorX, adhesionLineY + 6, 4, {
                isStatic: true,
                render: { fillStyle: 'transparent', visible: false },
                label: 'platelet',
                isStuck: true,
                isAnchor: true // Mark as anchor platelet
            });
            
            // Right anchor platelet - positioned just inside the right edge of the wound
            const rightAnchorX = woundRight - 10;
            const rightAnchor = Bodies.circle(rightAnchorX, adhesionLineY + 6, 4, {
                isStatic: true,
                render: { fillStyle: 'transparent', visible: false },
                label: 'platelet',
                isStuck: true,
                isAnchor: true // Mark as anchor platelet
            });
            
            Composite.add(engine.world, [leftAnchor, rightAnchor]);
            
            // Add to stuck platelets list so they can form fibrin connections
            const leftAnchorData = {
                body: leftAnchor,
                constraint: null,
                hasFibrin: false,
                fibrinConnections: [],
                isAnchor: true
            };
            
            const rightAnchorData = {
                body: rightAnchor,
                constraint: null,
                hasFibrin: false,
                fibrinConnections: [],
                isAnchor: true
            };
            
            state.stuckPlatelets.push(leftAnchorData, rightAnchorData);
            
            // Try to form fibrin connections from anchor platelets after a delay
            setTimeout(() => {
                if (state.stuckPlatelets.includes(leftAnchorData)) {
                    tryFormFibrin(leftAnchorData);
                }
                if (state.stuckPlatelets.includes(rightAnchorData)) {
                    tryFormFibrin(rightAnchorData);
                }
            }, 200);
        }

        function createParticle(type) {
            const y = 50 + Math.random() * 200;
            const x = -10;

            let body;

            switch (type) {
                case 'platelet':
                    body = Bodies.circle(x, y, 4, {
                        render: { 
                            fillStyle: 'transparent',
                            strokeStyle: 'transparent',
                            visible: false // No renderizar con Matter.js - solo custom
                        },
                        label: 'platelet',
                        restitution: 0.5, // Increased for better wall bounce
                        friction: 0.1,
                        frictionAir: 0.02,
                        density: 0.001,
                        isSticky: true,
                        isStuck: false,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001,
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    // Rastrear plaquetas spawnadas
                    state.totalPlateletsSpawned++;
                    break;

                case 'rbc':
                    // Gl√≥bulos rojos: usar c√≠rculo pero renderizar como elipse en custom render
                    body = Bodies.circle(x, y, 6, {
                        render: { 
                            fillStyle: 'transparent',
                            strokeStyle: 'transparent',
                            visible: false // No renderizar con Matter.js - solo custom
                        },
                        label: 'rbc',
                        restitution: 0.8, // Higher restitution for better bounce
                        friction: 0.05,
                        frictionAir: 0.01,
                        density: 0.0008,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001, // RBC category
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;

                case 'wbc':
                    body = Bodies.circle(x, y, 10, {
                        render: { 
                            fillStyle: 'transparent',
                            strokeStyle: 'transparent',
                            visible: false // No renderizar con Matter.js - solo custom
                        },
                        label: 'wbc',
                        restitution: 0.7, // Higher restitution for better bounce
                        friction: 0.1,
                        frictionAir: 0.03,
                        density: 0.002,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001, // WBC category
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;
            }

            if (body) {
                Composite.add(engine.world, body);
                state.allBodies.push(body);
            }

            return body;
        }

        // Variables para tracking de spawn
        let spawnStats = {
            lastSpawnCount: 0,
            totalSpawned: 0,
            spawnHistory: [] // √öltimos 10 conteos de spawn
        };

        function startParticleSpawning() {
            // Clear any existing timeout
            if (spawnInterval !== null) {
                clearTimeout(spawnInterval);
                spawnInterval = null;
            }
            // spawnIntervalCounter removido
            
            lastSpawnTime = performance.now();
            actualSpawnIntervals = [];
            spawnStats = {
                lastSpawnCount: 0,
                totalSpawned: 0,
                spawnHistory: []
            };
            
            // Funci√≥n para spawnear part√≠culas
            const spawnParticles = () => {
                // Solo spawnear si la simulaci√≥n est√° corriendo
                if (!state.simulationRunning) {
                    return;
                }
                
                const currentTime = performance.now();
                const actualInterval = currentTime - lastSpawnTime;
                
                // Registrar el intervalo real para el contador
                actualSpawnIntervals.push(actualInterval);
                if (actualSpawnIntervals.length > 20) {
                    actualSpawnIntervals.shift(); // Mantener solo los √∫ltimos 20
                }
                
                let spawnedThisCycle = 0;
                
                // Contar solo part√≠culas m√≥viles (no pegadas) para el l√≠mite de spawn
                const mobileBodies = state.allBodies.filter(b => {
                    return !state.stuckPlatelets.some(p => p.body === b);
                });
                
                if (mobileBodies.length < CONFIG.particles.maxCount) {
                const conditionConfig = CONFIG.conditions[state.condition];
                const plateletRatio = conditionConfig.plateletRatio;

                    // Apply spawn rate multiplier for conditions like thrombocytopenia
                    const spawnMultiplier = conditionConfig.spawnRateMultiplier || 1.0;
                    const spawnCount = Math.max(1, Math.floor(CONFIG.particles.spawnRate * spawnMultiplier));

                    for (let i = 0; i < spawnCount; i++) {
                        // Verificar l√≠mite con part√≠culas m√≥viles actualizadas
                        const currentMobileCount = state.allBodies.filter(b => {
                            return !state.stuckPlatelets.some(p => p.body === b);
                        }).length;
                        if (currentMobileCount >= CONFIG.particles.maxCount) break;
                        
                    const rand = Math.random();
                    
                    if (rand < plateletRatio) {
                        createParticle('platelet');
                            spawnedThisCycle++;
                    } else if (rand < plateletRatio + CONFIG.particles.rbcRatio) {
                        createParticle('rbc');
                            spawnedThisCycle++;
                    } else {
                        createParticle('wbc');
                            spawnedThisCycle++;
                        }
                    }
                }
                
                // Registrar estad√≠sticas de spawn
                spawnStats.lastSpawnCount = spawnedThisCycle;
                spawnStats.totalSpawned += spawnedThisCycle;
                spawnStats.spawnHistory.push(spawnedThisCycle);
                if (spawnStats.spawnHistory.length > 10) {
                    spawnStats.spawnHistory.shift();
                }
                
                lastSpawnTime = currentTime;
            };
            
            // Funci√≥n recursiva que ajusta el intervalo seg√∫n timeScale
            const scheduleNextSpawn = () => {
                if (!state.simulationRunning) return;
                
                // Asegurar que timeScale tenga un valor v√°lido (por defecto 1.0)
                const timeScale = state.timeScale && state.timeScale > 0 ? state.timeScale : 1.0;
                
                // Calcular intervalo ajustado seg√∫n velocidad (mayor velocidad = menor intervalo)
                const adjustedInterval = SPAWN_INTERVAL_MS / timeScale;
                
                spawnInterval = setTimeout(() => {
                    spawnParticles();
                    scheduleNextSpawn(); // Programar siguiente spawn con nuevo intervalo
                }, adjustedInterval);
            };
            
            // Iniciar el ciclo de spawn solo si la simulaci√≥n est√° corriendo
            if (state.simulationRunning) {
                scheduleNextSpawn();
            }
            
            // Contador de spawn removido
        }
        
        function toggleSimulation() {
            if (!state.simulationRunning) {
                // Iniciar simulaci√≥n
                state.simulationRunning = true;
                state.isPaused = false;
                state.startTime = Date.now();
                state.firstAdhesionTime = null;
                state.woundClosureTime = null;
                state.totalPlateletsSpawned = 0;
                state.history = { time: [], clotPercentage: [], bloodLoss: [], fibrinConnections: [], stuckPlatelets: [] };
                // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
                lastPhysicsTime = 0;
                accumulatedTime = 0;
                
                // Asegurar que timeScale tenga un valor v√°lido
                if (!state.timeScale || state.timeScale <= 0) {
                    state.timeScale = 1.0;
                }
                
                // Reiniciar el spawn para asegurar que funcione
                startParticleSpawning();
                
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.textContent = '‚è∏ Pausar Simulaci√≥n';
                    startBtn.classList.add('paused');
                }
                updateWizardStep(3);
            } else {
                // Pausar simulaci√≥n
                state.simulationRunning = false;
                // No usar Runner.stop() - usamos nuestro propio loop
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.textContent = '‚ñ∂ Reanudar Simulaci√≥n';
                    startBtn.classList.remove('paused');
                }
            }
        }
        
        function updateWizardStep(step) {
            state.currentStep = step;
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');
                if (stepNum < step) {
                    el.classList.add('completed');
                } else if (stepNum === step) {
                    el.classList.add('active');
                }
            });
        }

        function applyForces(timestep = 16.67) {
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            // Invisible adhesion line parameters - positioned at wound opening
            const adhesionLineY = 23; // Y position center of the adhesion zone
            const adhesionLineThreshold = 25; // Width of adhesion zone (m√°s ancho para efecto de profundidad)
            const adhesionDetectionThreshold = 8; // Umbral m√°s estricto para detectar adhesi√≥n (solo cuando est√° muy cerca)
            
            // IMPORTANTE: Con Runner.isFixed = true y delta = 16.67ms,
            // el timestep siempre es constante independientemente del FPS del renderer.
            // El Runner ejecuta pasos de f√≠sica a intervalos fijos, y cada paso siempre es de 16.67ms.
            // Por lo tanto, timeScale siempre debe ser 1.0 para mantener velocidad constante.
            // NO escalamos por el timestep real porque ya est√° fijo en 16.67ms.
            const timeScale = 1.0; // Siempre 1.0 porque el timestep es fijo

            state.allBodies.forEach(body => {
                // Skip stuck platelets and static bodies
                if (body.isStuck || body.isStatic) return;

                // Prevent particles from passing through walls by checking bounds
                const { width, height } = CONFIG.canvas;
                const wallThickness = CONFIG.wall.thickness;
                const particleRadius = body.circleRadius || (body.label === 'rbc' ? 6 : body.label === 'wbc' ? 10 : 4);
                
                // Check bottom wall
                if (body.position.y > height - wallThickness - particleRadius) {
                    Body.setPosition(body, {
                        x: body.position.x,
                        y: height - wallThickness - particleRadius - 0.1
                    });
                    Body.setVelocity(body, {
                        x: body.velocity.x,
                        y: Math.min(0, body.velocity.y * -0.8) // Bounce up
                    });
                }
                
                // Check top walls (left and right segments)
                const woundX = CONFIG.wound.x;
                const woundWidth = CONFIG.wound.width;
                const woundLeft = woundX - woundWidth / 2;
                const woundRight = woundX + woundWidth / 2;
                
                if (body.position.y < wallThickness + particleRadius) {
                    // Check if particle is in wound area
                    if (body.position.x < woundLeft || body.position.x > woundRight) {
                        // Outside wound - push back from top wall
                        Body.setPosition(body, {
                            x: body.position.x,
                            y: wallThickness + particleRadius + 0.1
                        });
                        Body.setVelocity(body, {
                            x: body.velocity.x,
                            y: Math.max(0, body.velocity.y * -0.8) // Bounce down
                        });
                    }
                }

                // Laminar flow force (right) - scaled by timestep for frame independence
                Body.applyForce(body, body.position, {
                    x: CONFIG.physics.flowForce * body.mass * timeScale,
                    y: 0
                });

                // Suction force (only under the wound) - scaled by timestep
                // Desactivar succi√≥n cuando la herida est√° cerrada
                if (!state.hemostasisAchieved) {
                    // Desplazar la succi√≥n hacia la izquierda
                    const suctionOffset = -15; // Desplazamiento hacia la izquierda
                    const suctionLeft = woundLeft + suctionOffset;
                    const suctionRight = woundRight + suctionOffset;
                    
                    if (body.position.x > suctionLeft - 50 && body.position.x < suctionRight + 50) {
                    const distanceToWound = Math.abs(body.position.y - 20);

                        if (body.position.x > suctionLeft && body.position.x < suctionRight && body.position.y < 250) {
                        // Direct suction upward
                            const suctionStrength = CONFIG.physics.suctionForce * (1 - distanceToWound / 230);
                            
                            // A√±adir componente horizontal hacia la izquierda
                            // M√°s fuerte cuanto m√°s arriba y m√°s a la izquierda est√© la part√≠cula
                            const normalizedY = (body.position.y - 20) / 230; // 0 = arriba, 1 = abajo
                            const normalizedX = (body.position.x - suctionLeft) / woundWidth; // 0 = izquierda, 1 = derecha
                            
                            // Componente horizontal hacia la izquierda (m√°s fuerte arriba y a la izquierda)
                            // Invertimos normalizedY y normalizedX para que sea m√°s fuerte arriba e izquierda
                            const horizontalSuction = (1 - normalizedY) * (1 - normalizedX) * CONFIG.physics.suctionForce * 0.3;
                            
                        Body.applyForce(body, body.position, {
                                x: -horizontalSuction * body.mass * timeScale, // Hacia la izquierda
                                y: -suctionStrength * body.mass * timeScale
                            });
                        }
                    }
                }

                // FIBRIN NET BOUNCE - Make RBCs and WBCs bounce off fibrin network
                if ((body.label === 'rbc' || body.label === 'wbc') && state.fibrinConstraints.length > 0) {
                    const cellRadius = body.label === 'rbc' ? 6 : 10;
                    const bounceThreshold = cellRadius + 6; // Increased detection threshold
                    const bounceStrength = body.label === 'rbc' ? 0.008 : 0.012; // Much stronger bounce force
                    const cellPos = body.position;
                    
                    // Only check fibrin near the wound area for performance
                    const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2 - 30;
                    const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2 + 30;
                    
                    if (cellPos.x >= woundLeft && cellPos.x <= woundRight && cellPos.y < 120) {
                        for (let i = 0; i < state.fibrinConstraints.length; i++) {
                            const fibrin = state.fibrinConstraints[i];
                            const pointA = fibrin.pointA.position;
                            const pointB = fibrin.pointB.position;
                            
                            if (!pointA || !pointB) continue;
                            
                            // Quick bounds check - skip if fibrin line is far from cell
                            const minX = Math.min(pointA.x, pointB.x);
                            const maxX = Math.max(pointA.x, pointB.x);
                            const minY = Math.min(pointA.y, pointB.y);
                            const maxY = Math.max(pointA.y, pointB.y);
                            
                            if (cellPos.x < minX - bounceThreshold || cellPos.x > maxX + bounceThreshold ||
                                cellPos.y < minY - bounceThreshold || cellPos.y > maxY + bounceThreshold) {
                                continue;
                            }
                            
                            // Calculate distance from cell to fibrin line segment
                            const lineVec = Vector.sub(pointB, pointA);
                            const lineLength = Vector.magnitude(lineVec);
                            
                            if (lineLength < 0.1) continue; // Skip very short lines
                            
                            const toCell = Vector.sub(cellPos, pointA);
                            const lineLengthSq = lineLength * lineLength;
                            const t = Math.max(0, Math.min(1, Vector.dot(toCell, lineVec) / lineLengthSq));
                            const closestPoint = Vector.add(pointA, Vector.mult(lineVec, t));
                            const distVec = Vector.sub(cellPos, closestPoint);
                            const distance = Vector.magnitude(distVec);
                            const bounceThresholdSq = bounceThreshold * bounceThreshold;
                            const distanceSq = distance * distance;
                            
                            // If cell is close to fibrin line, apply bounce force (or allow passage if weak)
                            if (distanceSq < bounceThresholdSq && distance > 0.1) {
                                // Get fibrin stability - affects barrier effectiveness
                                const fibrinStability = fibrin.stability || 1.0;
                                
                                // Si est√° sellado, bloquear completamente el paso
                                const passThroughChance = state.hemostasisAchieved ? 0 : (1 - fibrinStability) * 0.3; // Up to 30% chance for very weak fibrin
                                
                                if (Math.random() < passThroughChance) {
                                    // Cell passes through weak fibrin - reduce velocity slightly
                                    Body.setVelocity(body, {
                                        x: body.velocity.x * 0.9,
                                        y: body.velocity.y * 0.9
                                    });
                                    continue; // Skip bounce for this fibrin connection
                                }
                                
                                // Normalize distance vector to get bounce direction
                                const bounceDir = {
                                    x: distVec.x / distance,
                                    y: distVec.y / distance
                                };
                                
                                // Calculate velocity component towards the line
                                const velocityDot = body.velocity.x * bounceDir.x + body.velocity.y * bounceDir.y;
                                
                                // Only apply bounce if moving towards the line
                                if (velocityDot < 0) {
                                    // Bounce force reduced by stability - weaker fibrin = weaker bounce
                                    const proximityFactor = 1 - (distance / bounceThreshold);
                                    const stabilityMultiplier = 0.3 + (fibrinStability * 0.7); // 0.3-1.0 range
                                    const bounceForce = bounceStrength * proximityFactor * proximityFactor * stabilityMultiplier;
                                    
                                    // Scale bounce force by timestep for frame independence (use timeScale from function scope)
                                    Body.applyForce(body, body.position, {
                                        x: bounceDir.x * bounceForce * body.mass * 10 * timeScale,
                                        y: bounceDir.y * bounceForce * body.mass * 10 * timeScale
                                    });
                                    
                                    // Invert velocity component - effectiveness depends on stability
                                    const bounceFactor = (0.5 + fibrinStability * 0.3) + (proximityFactor * 0.2); // 0.5-1.0 range
                                    Body.setVelocity(body, {
                                        x: body.velocity.x - bounceDir.x * velocityDot * bounceFactor,
                                        y: body.velocity.y - bounceDir.y * velocityDot * bounceFactor
                                    });
                                    
                                    // Push cell away from the line - less effective for weak fibrin
                                    const pushDistance = (bounceThreshold - distance) * 0.3 * fibrinStability;
                                    Body.setPosition(body, {
                                        x: body.position.x + bounceDir.x * pushDistance,
                                        y: body.position.y + bounceDir.y * pushDistance
                                    });
                                }
                            }
                        }
                    }
                }

                // INVISIBLE ADHESION LINE - Check if platelet crosses the invisible line
                if (body.label === 'platelet' && !body.isStuck) {
                    const inWoundZone = body.position.x > woundLeft && body.position.x < woundRight;
                    // Usar umbral m√°s estricto para detectar adhesi√≥n (solo cuando est√° muy cerca del centro)
                    const distanceFromCenter = Math.abs(body.position.y - adhesionLineY);
                    const nearAdhesionLine = distanceFromCenter < adhesionLineThreshold; // √Årea amplia para variaci√≥n
                    const veryCloseToCenter = distanceFromCenter < 8; // Solo adherir cuando est√° muy cerca del centro

                    if (inWoundZone && nearAdhesionLine && veryCloseToCenter) {
                        const conditionConfig = CONFIG.conditions[state.condition];
                        const canStick = state.treatmentApplied ? true : conditionConfig.canStick;
                        // Reducir probabilidad base de adhesi√≥n
                        const stickProb = state.treatmentApplied ? 0.7 : conditionConfig.stickProbability * 0.3;

                        // Check platelet function first
                        if (!state.treatmentApplied && Math.random() > conditionConfig.plateletFunction) {
                            // Platelet dysfunction - let it pass through fibrin network instead of bouncing
                            // Reduce restitution to prevent bouncing and allow passage
                            body.restitution = 0;
                            Body.setVelocity(body, {
                                x: body.velocity.x * 0.95,
                                y: body.velocity.y * 0.95
                            });
                            return;
                        }
                        
                        // Fuerza de adhesi√≥n ajustada (un poco m√°s alta que antes)
                        const baseAdhesionStrength = state.treatmentApplied ? 0.5 : conditionConfig.adhesionStrength * 0.2;
                        
                        // A√±adir factor de distancia: m√°s cerca del centro = mayor probabilidad
                        // Solo adherir si est√° muy cerca del centro (dentro de 6px)
                        const distanceFactor = Math.max(0.3, 1 - (distanceFromCenter / 6)); // Factor moderado
                        const finalAdhesionStrength = baseAdhesionStrength * distanceFactor;
                        
                        // A√±adir factor de velocidad: plaquetas m√°s lentas tienen mayor probabilidad
                        const speed = Math.sqrt(body.velocity.x * body.velocity.x + body.velocity.y * body.velocity.y);
                        const speedFactor = Math.max(0.5, 1 - (speed / 0.4)); // Factor de velocidad moderado
                        const finalAdhesionWithSpeed = finalAdhesionStrength * speedFactor;
                        
                        if (canStick && Math.random() < finalAdhesionWithSpeed) {
                            // Stick to the invisible line
                            stickPlateletToLine(body, adhesionLineY, conditionConfig);
                        } else if (!state.treatmentApplied && conditionConfig.adhesionRetryChance) {
                            // Retry adhesion chance
                            setTimeout(() => {
                                if (!body.isStuck && Math.random() < conditionConfig.adhesionRetryChance) {
                                    if (canStick && Math.random() < adhesionStrength) {
                                        stickPlateletToLine(body, adhesionLineY, conditionConfig);
                                    }
                                }
                            }, 100);
                        } else {
                            // Las plaquetas que no se adhieren atraviesan la malla en lugar de rebotar
                            // Reducir restitution para evitar rebotes y permitir paso
                            body.restitution = 0;
                            Body.setVelocity(body, {
                                x: body.velocity.x * 0.95,
                                y: body.velocity.y * 0.95
                            });
                        }
                    }
                }
            });

            // For hemophilia and conditions with unstable fibrin - apply extra force to dislodge weakly attached platelets
            const conditionConfig = CONFIG.conditions[state.condition];
            if ((state.condition === 'hemophilia' || state.condition === 'hemophiliaSevere' || 
                 conditionConfig.fibrinStability < 0.5) && !state.treatmentApplied) {
                state.stuckPlatelets.forEach(platelet => {
                    if (!platelet.hasFibrin || platelet.fibrinConnections.length === 0) {
                        // Gradually increase dislodge force for platelets without fibrin support - scaled by timestep
                        const dislodgeForce = 0.00015 * (1 - conditionConfig.fibrinStability);
                        Body.applyForce(platelet.body, platelet.body.position, {
                            x: 0,
                            y: -dislodgeForce * platelet.body.mass * (1 + Math.random()) * timeScale
                        });
                    }
                });
            }
        }

        function stickPlateletToLine(platelet, lineY, conditionConfig) {
            if (platelet.isStuck) return;
            
            platelet.isStuck = true;
            
            // Apply visual effects based on condition
            const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
            platelet.render.fillStyle = visualEffects.plateletColor || '#808080';
            
            // Stop movement and position within the adhesion zone (efecto de profundidad)
            Body.setVelocity(platelet, { x: 0, y: 0 });
            // Variar la posici√≥n Y dentro del √°rea de adhesi√≥n para crear profundidad
            // Las plaquetas pueden adherirse en un rango sim√©trico alrededor de la l√≠nea central
            const adhesionZoneHalfWidth = 12; // Mitad del ancho del √°rea de adhesi√≥n
            const adhesionZoneTop = lineY - adhesionZoneHalfWidth;
            const adhesionZoneBottom = lineY + adhesionZoneHalfWidth;
            // Posici√≥n aleatoria dentro del √°rea de adhesi√≥n, con distribuci√≥n normal centrada
            // Usar la posici√≥n actual de la plaqueta como referencia, pero limitada al √°rea de adhesi√≥n
            const currentY = platelet.position.y;
            const targetY = Math.max(adhesionZoneTop, Math.min(adhesionZoneBottom, currentY));
            // A√±adir peque√±a variaci√≥n aleatoria para efecto de profundidad
            const randomVariation = (Math.random() - 0.5) * 4; // Variaci√≥n de ¬±2 p√≠xeles
            const stickY = Math.max(adhesionZoneTop, Math.min(adhesionZoneBottom, targetY + randomVariation));
            Body.setPosition(platelet, { x: platelet.position.x, y: stickY });
            
            // Make platelet completely static so it doesn't move
            Body.setStatic(platelet, true);
            
            // Create constraint to the adhesion point - maximum stiffness
            const constraint = Constraint.create({
                bodyA: platelet,
                pointB: { x: platelet.position.x, y: stickY },
                stiffness: 1.0, // Maximum stiffness
                damping: 1.0, // Maximum damping
                length: 0,
                render: { visible: false }
            });

            Composite.add(engine.world, constraint);

            const plateletData = {
                body: platelet,
                constraint: constraint,
                hasFibrin: false,
                fibrinConnections: [],
                condition: state.condition,
                stuckAt: Date.now(), // Timestamp para identificar las m√°s antiguas
                isAnchor: false
            };

            state.stuckPlatelets.push(plateletData);

            // Rastrear primera adhesi√≥n
            if (!state.firstAdhesionTime && state.startTime) {
                state.firstAdhesionTime = Date.now();
            }

            // Limitar el n√∫mero de plaquetas pegadas para mantener rendimiento
            cleanupOldStuckPlatelets();
            
            // Ocultar cartel cuando hay plaquetas pegadas
            const woundLabel = document.getElementById('wound-label');
            if (state.stuckPlatelets.length > 0) {
                woundLabel.classList.add('hidden');
            }

            // Secuencia: plaquetas primero, luego malla
            // Activar formaci√≥n de fibrina solo despu√©s de umbral de plaquetas
            // Con tratamiento, reducir el umbral m√≠nimo de plaquetas
            const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
            if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
                state.fibrinFormationStarted = true;
                
                // Try to form fibrin after delay if specified
                // Con tratamiento, reducir significativamente el delay
                const baseDelay = conditionConfig.fibrinFormationDelay || 150;
                const delay = state.treatmentApplied ? Math.max(50, baseDelay * 0.3) : baseDelay;
            setTimeout(() => {
                if (state.stuckPlatelets.includes(plateletData)) {
                    tryFormFibrin(plateletData);
                        
                        // Also try to form fibrin from nearby anchor platelets
                        state.stuckPlatelets.forEach(other => {
                            if (other.isAnchor && other.body) {
                                const dist = Vector.magnitude(Vector.sub(plateletData.body.position, other.body.position));
                                if (dist < 80) {
                                    tryFormFibrin(other);
                                }
                            }
                        });
                    }
                }, delay);
            }
        }

        function cleanupOldStuckPlatelets() {
            const maxStuckPlatelets = CONFIG.stuckPlatelets.maxCount;
            
            // Si no excedemos el l√≠mite, no hacer nada
            if (state.stuckPlatelets.length <= maxStuckPlatelets) {
                return;
            }
            
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const woundAreaMargin = 100; // Margen alrededor de la herida para considerar "relevante"
            
            // Ordenar plaquetas pegadas por timestamp (m√°s antiguas primero)
            // Pero excluir las anchor platelets y las que est√°n cerca de la herida
            const plateletsToConsider = state.stuckPlatelets
                .filter(p => !p.isAnchor) // No eliminar anchor platelets
                .map(p => ({
                    data: p,
                    distance: Math.abs(p.body.position.x - woundX),
                    isNearWound: p.body.position.x >= woundLeft - woundAreaMargin && 
                                p.body.position.x <= woundRight + woundAreaMargin &&
                                p.body.position.y >= 20 && p.body.position.y <= 100
                }))
                .sort((a, b) => {
                    // Priorizar eliminar las que est√°n lejos de la herida
                    if (a.isNearWound && !b.isNearWound) return 1;
                    if (!a.isNearWound && b.isNearWound) return -1;
                    // Si ambas est√°n cerca o lejos, ordenar por timestamp (m√°s antiguas primero)
                    return (a.data.stuckAt || 0) - (b.data.stuckAt || 0);
                });
            
            // Calcular cu√°ntas necesitamos eliminar
            const toRemove = state.stuckPlatelets.length - maxStuckPlatelets;
            
            // Eliminar las m√°s antiguas que est√°n lejos de la herida
            for (let i = 0; i < toRemove && i < plateletsToConsider.length; i++) {
                const plateletData = plateletsToConsider[i].data;
                
                // Eliminar constraints de fibrina conectados
                for (let j = state.fibrinConstraints.length - 1; j >= 0; j--) {
                    const fibrin = state.fibrinConstraints[j];
                    if (fibrin.pointA === plateletData.body || fibrin.pointB === plateletData.body) {
                        removeFibrinConnection(fibrin);
                    }
                }
                
                // Eliminar constraint de la plaqueta
                if (plateletData.constraint) {
                    Composite.remove(engine.world, plateletData.constraint);
                }
                
                // Eliminar el body
                Composite.remove(engine.world, plateletData.body);
                
                // Eliminar de la lista
                const index = state.stuckPlatelets.indexOf(plateletData);
                if (index > -1) {
                    state.stuckPlatelets.splice(index, 1);
                }
                
                // Eliminar de allBodies
                const bodyIndex = state.allBodies.indexOf(plateletData.body);
                if (bodyIndex > -1) {
                    state.allBodies.splice(bodyIndex, 1);
                }
            }
        }

        function cleanupParticles() {
            const toRemove = [];
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;

            // Optimized cleanup: iterate backwards for better performance when removing
            for (let i = state.allBodies.length - 1; i >= 0; i--) {
                const body = state.allBodies[i];
                const px = body.position.x;
                const py = body.position.y;
                
                // Solo eliminar part√≠culas m√≥viles (no pegadas) en la limpieza b√°sica
                const isStuck = state.stuckPlatelets.some(p => p.body === body);
                
                if (!isStuck) {
                    // Remove particles that exit right (eliminar cuando salen completamente del canvas)
                    if (px > CONFIG.canvas.width + 20) {
                        toRemove.push(body);
                    }
                    // Remove particles that exit top (blood loss)
                    else if (py < -20) {
                        toRemove.push(body);
                        state.bloodLoss++;
                    }
                    // Remove particles that exit through the wound (upward)
                    else if (py < 10 && px >= woundLeft - 5 && px <= woundRight + 5) {
                        toRemove.push(body);
                        state.bloodLoss++;
                }
                    // Remove particles way off screen (bottom or left)
                    else if (py > CONFIG.canvas.height + 20 || px < -30) {
                    toRemove.push(body);
                }
                }
            }

            // Optimized removal: use Map for faster lookups
            const bodySet = new Set(toRemove);

            toRemove.forEach(body => {
                // Remove associated constraints if it's a stuck platelet
                const plateletIndex = state.stuckPlatelets.findIndex(p => p.body === body);
                if (plateletIndex !== -1) {
                    const plateletData = state.stuckPlatelets[plateletIndex];
                    
                    // Remove fibrin constraints connected to this platelet (iterate backwards)
                    for (let i = state.fibrinConstraints.length - 1; i >= 0; i--) {
                        const fibrin = state.fibrinConstraints[i];
                        if (fibrin.pointA === body || fibrin.pointB === body) {
                            removeFibrinConnection(fibrin);
                        }
                    }
                    
                    // Remove platelet constraint
                    if (plateletData.constraint) {
                        Composite.remove(engine.world, plateletData.constraint);
                    }
                    
                    // Remove from stuck platelets list (but not anchor platelets)
                    if (!plateletData.isAnchor) {
                        state.stuckPlatelets.splice(plateletIndex, 1);
                    }
                }
                
                Composite.remove(engine.world, body);
            });
            
            // Remove from allBodies array (more efficient)
            state.allBodies = state.allBodies.filter(b => !bodySet.has(b));
            
            // Limpieza agresiva: eliminar part√≠culas que est√°n cerca del borde derecho
            // Esto asegura que las part√≠culas se eliminen antes de llegar al l√≠mite m√°ximo
            const aggressiveCleanupThreshold = CONFIG.particles.maxCount * 0.7; // 70% del l√≠mite (105 part√≠culas)
            if (state.allBodies.length > aggressiveCleanupThreshold) {
                const additionalToRemove = [];
                
                for (let i = state.allBodies.length - 1; i >= 0; i--) {
                    const body = state.allBodies[i];
                    if (!body || !body.position) continue;
                    
                    const px = body.position.x;
                    const py = body.position.y;
                    
                    // Solo eliminar part√≠culas m√≥viles (no pegadas)
                    const isStuck = state.stuckPlatelets.some(p => p.body === body);
                    if (isStuck) continue;
                    
                    // Eliminar part√≠culas que est√°n muy cerca del borde derecho (dentro de 30px del final)
                    if (px > CONFIG.canvas.width - 30) {
                        additionalToRemove.push(body);
                    }
                    // Tambi√©n eliminar part√≠culas que est√°n muy abajo (fuera de la vista √∫til)
                    else if (py > CONFIG.canvas.height - 10) {
                        additionalToRemove.push(body);
                    }
                }
                
                // Eliminar las part√≠culas adicionales encontradas
                additionalToRemove.forEach(body => {
                    try {
                        Composite.remove(engine.world, body);
                        const index = state.allBodies.indexOf(body);
                        if (index > -1) {
                            state.allBodies.splice(index, 1);
                        }
                    } catch (e) {
                        // Ignorar errores si el body ya fue eliminado
                    }
                });
            }
        }

        function setupCollisionEvents() {
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    
                    // Check for platelet collision with wound edges or stuck platelets
                    handlePlateletCollision(bodyA, bodyB);
                    handlePlateletCollision(bodyB, bodyA);
                    
                    // Handle weak fibrin barrier collisions - allow occasional passage
                    handleFibrinBarrierCollision(bodyA, bodyB);
                    handleFibrinBarrierCollision(bodyB, bodyA);
                });
            });
        }
        
        function handleFibrinBarrierCollision(cell, barrier) {
            // Check if cell (RBC/WBC) collides with fibrin barrier
            if ((cell.label !== 'rbc' && cell.label !== 'wbc') || barrier.label !== 'fibrinBarrier') {
                return;
            }
            
            // Get fibrin stability from barrier
            const fibrinStability = barrier.fibrinStability || 1.0;
            
            // Si est√° sellado, bloquear completamente el paso
            if (state.hemostasisAchieved) {
                return; // No permitir paso cuando est√° sellado
            }
            
            // Weak fibrin occasionally allows cells to pass through
            if (fibrinStability < 0.6) {
                const passThroughChance = (1 - fibrinStability) * 0.4; // Up to 40% chance for very weak fibrin
                
                if (Math.random() < passThroughChance) {
                    // Allow cell to pass through - make barrier temporarily non-collidable
                    barrier.collisionFilter.mask = 0x0000; // No collisions
                    
                    // Restore collision after a short time
                    setTimeout(() => {
                        if (barrier.label === 'fibrinBarrier') {
                            barrier.collisionFilter.mask = 0x0001;
                        }
                    }, 500);
                    
                    // Reduce cell velocity slightly as it passes through
                    Body.setVelocity(cell, {
                        x: cell.velocity.x * 0.85,
                        y: cell.velocity.y * 0.85
                    });
                } else {
                    // Reduce bounce effectiveness for weak fibrin
                    const bounceReduction = 1 - fibrinStability;
                    Body.setVelocity(cell, {
                        x: cell.velocity.x * (1 - bounceReduction * 0.3),
                        y: cell.velocity.y * (1 - bounceReduction * 0.3)
                    });
                }
            }
        }

        function handlePlateletCollision(platelet, other) {
            if (platelet.label !== 'platelet' || platelet.isStuck) return;

            const conditionConfig = CONFIG.conditions[state.condition];
            
            // Check platelet function first
            if (!state.treatmentApplied && Math.random() > conditionConfig.plateletFunction) {
                // Platelet dysfunction - let it pass through instead of bouncing
                // Reduce restitution to prevent bouncing and allow passage
                platelet.restitution = 0;
                Body.setVelocity(platelet, {
                    x: platelet.velocity.x * 0.95,
                    y: platelet.velocity.y * 0.95
                });
                return;
            }

            const canStick = state.treatmentApplied ? true : conditionConfig.canStick;
            const adhesionStrength = state.treatmentApplied ? 0.95 : conditionConfig.adhesionStrength;

            // Check if collision is with wound edge or stuck platelet
            const isWoundEdge = other.label === 'woundEdge';
            const isStuckPlatelet = other.label === 'platelet' && other.isStuck;

            if (isWoundEdge || isStuckPlatelet) {
                // Check if in wound zone
                const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
                const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;
                
                if (platelet.position.x >= woundLeft - 20 && platelet.position.x <= woundRight + 20 && platelet.position.y < 45) {
                    // Check aggregation rate for platelet-to-platelet adhesion
                    // En vWD sin tratamiento, las plaquetas no se agregan (no hay cemento vWF)
                    if (isStuckPlatelet) {
                        const aggregationRate = state.treatmentApplied ? 0.9 : conditionConfig.aggregationRate;
                        if (Math.random() > aggregationRate) {
                            // Failed aggregation - plaquetas rebotan/se separan (sin cemento vWF)
                        platelet.restitution = 0.9;
                            // En vWD, rebote m√°s fuerte para simular que no hay cemento
                            const bounceStrength = (state.condition === 'vwd' && !state.treatmentApplied) ? 1.5 : 1.0;
                        Body.setVelocity(platelet, {
                                x: platelet.velocity.x * (0.8 * bounceStrength),
                                y: Math.abs(platelet.velocity.y) * (1.2 * bounceStrength) + 1
                            });
                            return;
                        }
                    }
                    
                    if (canStick && Math.random() < adhesionStrength) {
                        stickPlatelet(platelet, other, conditionConfig);
                    } else if (!state.treatmentApplied && conditionConfig.adhesionRetryChance) {
                        // Retry adhesion chance
                        setTimeout(() => {
                            if (!platelet.isStuck && Math.random() < conditionConfig.adhesionRetryChance) {
                                if (canStick && Math.random() < adhesionStrength) {
                                    stickPlatelet(platelet, other, conditionConfig);
                                }
                            }
                        }, 100);
                    } else {
                        // Las plaquetas que no se adhieren atraviesan en lugar de rebotar
                        // Reducir restitution para evitar rebotes y permitir paso
                        platelet.restitution = 0;
                        Body.setVelocity(platelet, {
                            x: platelet.velocity.x * 0.95,
                            y: platelet.velocity.y * 0.95
                        });
                    }
                }
            }
        }

        function stickPlatelet(platelet, anchor, conditionConfig) {
            if (platelet.isStuck) return;
            
            platelet.isStuck = true;
            
            // Apply visual effects based on condition
            const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
            platelet.render.fillStyle = visualEffects.plateletColor || '#808080';
            
            // Stop movement completely
            Body.setVelocity(platelet, { x: 0, y: 0 });
            
            // Make platelet completely static so it doesn't move
            Body.setStatic(platelet, true);
            
            // Create constraint to anchor point - maximum stiffness
            const constraint = Constraint.create({
                bodyA: platelet,
                pointB: anchor.isStatic ? { x: anchor.position.x, y: anchor.position.y } : null,
                bodyB: anchor.isStatic ? null : anchor,
                stiffness: 1.0, // Maximum stiffness
                damping: 1.0, // Maximum damping
                length: 0,
                render: { visible: false }
            });

            Composite.add(engine.world, constraint);

            const plateletData = {
                body: platelet,
                constraint: constraint,
                hasFibrin: false,
                fibrinConnections: [],
                condition: state.condition,
                stuckAt: Date.now(), // Timestamp para identificar las m√°s antiguas
                isAnchor: false
            };

            state.stuckPlatelets.push(plateletData);

            // Rastrear primera adhesi√≥n
            if (!state.firstAdhesionTime && state.startTime) {
                state.firstAdhesionTime = Date.now();
            }

            // Limitar el n√∫mero de plaquetas pegadas para mantener rendimiento
            cleanupOldStuckPlatelets();
            
            // Ocultar cartel cuando hay plaquetas pegadas
            const woundLabel = document.getElementById('wound-label');
            if (state.stuckPlatelets.length > 0) {
                woundLabel.classList.add('hidden');
            }

            // Secuencia: plaquetas primero, luego malla
            // Activar formaci√≥n de fibrina solo despu√©s de umbral de plaquetas
            // Con tratamiento, reducir el umbral m√≠nimo de plaquetas
            const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
            if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
                state.fibrinFormationStarted = true;
                
                // Try to form fibrin with delay if specified
                // Con tratamiento, reducir significativamente el delay
                const baseDelay = conditionConfig.fibrinFormationDelay || 100;
                const delay = state.treatmentApplied ? Math.max(50, baseDelay * 0.3) : baseDelay;
            setTimeout(() => {
                    if (state.stuckPlatelets.includes(plateletData)) {
                tryFormFibrin(plateletData);
                    }
}, delay);
            }
        }

        function tryFormFibrin(plateletData) {
            const conditionConfig = CONFIG.conditions[state.condition];
            const canFormFibrin = state.treatmentApplied ? true : conditionConfig.canFormFibrin;

            if (!canFormFibrin) return;
            
            // Secuencia: plaquetas primero, luego malla - solo formar si ya empez√≥ la formaci√≥n
            if (!state.fibrinFormationStarted) return;
            
            // Check fibrin formation rate
            const fibrinFormationRate = state.treatmentApplied ? 1.0 : conditionConfig.fibrinFormationRate;
            if (Math.random() > fibrinFormationRate) {
                return; // Failed to form fibrin this time
            }
            
            // Limit total fibrin connections
            if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections) return;
            
            // Limit connections per platelet
            if (plateletData.fibrinConnections.length >= CONFIG.fibrin.maxConnectionsPerPlatelet) return;
            
            // Check max cluster size for thrombasthenia
            if (conditionConfig.maxPlateletClusterSize) {
                const nearbyCount = state.stuckPlatelets.filter(p => {
                    const dx = p.body.position.x - plateletData.body.position.x;
                    const dy = p.body.position.y - plateletData.body.position.y;
                    return (dx * dx + dy * dy) < 400 && p.fibrinConnections.length > 0;
                }).length;
                if (nearbyCount >= conditionConfig.maxPlateletClusterSize) {
                    return; // Cannot form larger clusters
                }
            }

            const platelet = plateletData.body;
            
            // Get fibrin stability from condition - affects connection distance
            const fibrinStability = state.treatmentApplied ? 1.0 : conditionConfig.fibrinStability;
            
            // When fibrin is weaker, platelets must be closer to form connections
            // Strong fibrin (1.0): can connect up to 90px away, minimum 20px
            // Weak fibrin (0.3): can connect up to 40px away, minimum 8px
            // Con tratamiento, aumentar el radio de b√∫squeda para formar conexiones m√°s f√°cilmente
            const baseMaxSearchRadius = 40 + (fibrinStability * 50); // 40-90px range
            const maxSearchRadius = state.treatmentApplied ? baseMaxSearchRadius * 1.3 : baseMaxSearchRadius; // 30% m√°s con tratamiento
            const minDistance = 8 + (fibrinStability * 12); // 8-20px range
            const minDistanceSq = minDistance * minDistance;
            
            const plateletX = platelet.position.x;
            const plateletY = platelet.position.y;

            // Find nearby stuck platelets (optimized with early exit)
            for (let i = 0; i < state.stuckPlatelets.length; i++) {
                const other = state.stuckPlatelets[i];
                if (other.body === platelet) continue;
                if (plateletData.fibrinConnections.includes(other.body.id)) continue;
                
                // Limit connections per other platelet too
                if (other.fibrinConnections.length >= CONFIG.fibrin.maxConnectionsPerPlatelet) continue;

                // Quick distance check using squared distance (avoid sqrt)
                const dx = other.body.position.x - plateletX;
                const dy = other.body.position.y - plateletY;
                const distSq = dx * dx + dy * dy;
                const searchRadiusSq = maxSearchRadius * maxSearchRadius;

                if (distSq < searchRadiusSq && distSq > minDistanceSq) {
                    const dist = Math.sqrt(distSq);
                    
                    // Clasificar tipo de cuerda seg√∫n distancia y estabilidad
                    let fibrinType = 'thin'; // Por defecto peque√±a
                    if (dist < 30 && fibrinStability > 0.7) {
                        fibrinType = 'thick'; // Gruesa: distancia < 30px y estabilidad alta
                    } else if (dist < 60 && fibrinStability > 0.4) {
                        fibrinType = 'medium'; // Mediana: distancia 30-60px y estabilidad media
                    }
                    
                    // Verificar restricciones seg√∫n condici√≥n
                    const canFormThick = !conditionConfig.blockThickCords;
                    const canFormMedium = !conditionConfig.blockMediumCords;
                    const canFormThin = !conditionConfig.blockThinCords;
                    
                    if ((fibrinType === 'thick' && !canFormThick) ||
                        (fibrinType === 'medium' && !canFormMedium) ||
                        (fibrinType === 'thin' && !canFormThin)) {
                        continue; // Saltar esta conexi√≥n si est√° bloqueada
                    }
                    
                    const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
                    
                    // Create fibrin constraint with stability-based properties
                    const fibrinConstraint = Constraint.create({
                        bodyA: platelet,
                        bodyB: other.body,
                        stiffness: 0.9 * fibrinStability,
                        damping: 0.3 * (2 - fibrinStability),
                        length: dist * 0.8,
                        render: { visible: false }
                    });

                    Composite.add(engine.world, fibrinConstraint);

                    // Create physical body for fibrin barrier (thin rectangle)
                    const midX = (platelet.position.x + other.body.position.x) / 2;
                    const midY = (platelet.position.y + other.body.position.y) / 2;
                    const angle = Math.atan2(
                        other.body.position.y - platelet.position.y,
                        other.body.position.x - platelet.position.x
                    );
                    
                    // Create a thin rectangular body as barrier
                    // Thickness depends on stability - weaker fibrin = thinner barrier
                    const barrierThickness = 2 + (fibrinStability * 3); // 2-5px range
                    const fibrinBody = Bodies.rectangle(midX, midY, dist, barrierThickness, {
                        isStatic: true, // Static so it acts as a solid barrier
                        render: { 
                            fillStyle: 'transparent', // Invisible, we render it separately
                            visible: false
                        },
                        label: 'fibrinBarrier',
                        restitution: 0.9 * fibrinStability, // Stability affects bounce
                        friction: 0.1,
                        collisionFilter: {
                            group: 0,
                            category: 0x0002, // Separate category for fibrin
                            mask: 0x0001 // Only collide with RBCs and WBCs
                        },
                        // Store stability for collision handling
                        fibrinStability: fibrinStability
                    });
                    
                    Body.setAngle(fibrinBody, angle);
                    Composite.add(engine.world, fibrinBody);

                    const fibrinData = {
                        constraint: fibrinConstraint,
                        pointA: platelet,
                        pointB: other.body,
                        body: fibrinBody,
                        glowing: state.treatmentApplied,
                        stability: fibrinStability,
                        decayRate: conditionConfig.fibrinDecayRate || 0,
                        visualColor: '#FFFFFF', // Blanco para las cuerdas (solo la malla horizontal es morada)
                        opacity: visualEffects.fibrinOpacity || 1.0,
                        fibrinType: fibrinType, // 'thick', 'medium', o 'thin'
                        createdAt: Date.now()
                    };
                    
                    state.fibrinConstraints.push(fibrinData);
                    state.fibrinBodies.push(fibrinBody);

                    plateletData.fibrinConnections.push(other.body.id);
                    plateletData.hasFibrin = true;
                    other.fibrinConnections.push(platelet.id);
                    other.hasFibrin = true;
                    
                    // Schedule fibrin decay if condition has decay rate
                    if (conditionConfig.fibrinDecayRate > 0 && !state.treatmentApplied) {
                        scheduleFibrinDecay(fibrinData, conditionConfig.fibrinDecayRate);
                    }
                    
                    // Stop if we've reached the limit
                    if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections) break;
                }
            }
            
            // Check if wound is sealed after forming new fibrin connection
            checkWoundSealed();
        }
        
        function scheduleFibrinDecay(fibrinData, decayRate) {
            // Decay fibrin over time based on decay rate
            const decayInterval = setInterval(() => {
                if (!state.fibrinConstraints.includes(fibrinData)) {
                    clearInterval(decayInterval);
                    return;
                }
                
                // Reduce stability over time
                fibrinData.stability -= decayRate * 0.1;
                
                if (fibrinData.stability <= 0.1 || Math.random() < decayRate) {
                    // Remove unstable fibrin
                    removeFibrinConnection(fibrinData);
                    clearInterval(decayInterval);
                } else {
                    // Update constraint properties based on stability
                    fibrinData.constraint.stiffness = 0.9 * fibrinData.stability;
                    fibrinData.constraint.damping = 0.3 * (2 - fibrinData.stability);
                }
            }, 2000); // Check every 2 seconds
        }
        
        function removeFibrinConnection(fibrinData) {
            // Remove from world
            Composite.remove(engine.world, fibrinData.constraint);
            if (fibrinData.body) {
                Composite.remove(engine.world, fibrinData.body);
                state.fibrinBodies = state.fibrinBodies.filter(b => b !== fibrinData.body);
            }
            
            // Remove from arrays
            state.fibrinConstraints = state.fibrinConstraints.filter(f => f !== fibrinData);
            
            // Update platelet connections
            const plateletA = state.stuckPlatelets.find(p => p.body === fibrinData.pointA);
            const plateletB = state.stuckPlatelets.find(p => p.body === fibrinData.pointB);
            
            if (plateletA) {
                plateletA.fibrinConnections = plateletA.fibrinConnections.filter(id => id !== fibrinData.pointB.id);
                plateletA.hasFibrin = plateletA.fibrinConnections.length > 0;
            }
            if (plateletB) {
                plateletB.fibrinConnections = plateletB.fibrinConnections.filter(id => id !== fibrinData.pointA.id);
                plateletB.hasFibrin = plateletB.fibrinConnections.length > 0;
            }
        }
        
        function checkWoundSealed() {
            if (state.hemostasisAchieved) return; // Already sealed
            
            const conditionConfig = CONFIG.conditions[state.condition];
            // En condiciones patol√≥gicas, requerir tratamiento para sellado completo
            if (conditionConfig.requiresTreatment && !state.treatmentApplied) {
                return; // No sellar sin tratamiento
            }
            
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const woundCenterY = 29; // Y position where platelets stick
            
            // Find platelets on the left side of the wound (including anchor platelets)
            const leftSidePlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                // Include anchor platelets or platelets near left edge
                return (p.isAnchor && px < woundLeft) || (px < woundLeft + 30 && Math.abs(py - woundCenterY) < 20);
            });
            
            // Find platelets on the right side of the wound (including anchor platelets)
            const rightSidePlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                // Include anchor platelets or platelets near right edge
                return (p.isAnchor && px > woundRight) || (px > woundRight - 30 && Math.abs(py - woundCenterY) < 20);
            });
            
            if (leftSidePlatelets.length === 0 || rightSidePlatelets.length === 0) {
                return; // Need platelets on both sides
            }
            
            // Check if there's a path from left to right through fibrin connections
            for (let i = 0; i < leftSidePlatelets.length; i++) {
                const leftPlatelet = leftSidePlatelets[i];
                if (hasPathToRight(leftPlatelet, rightSidePlatelets, new Set())) {
                    // Wound is sealed!
                    state.hemostasisAchieved = true;
                    state.clotPercentage = 100;
                    // Capturar el momento del cierre de la herida (tiempo de simulaci√≥n acumulado)
                    if (!state.woundClosureTime && state.startTime) {
                        state.woundClosureTime = accumulatedSimulationTime / 1000; // Guardar tiempo de simulaci√≥n en segundos
                    }
                    document.getElementById('hemostasis-indicator').classList.add('visible');
                    const woundLabel = document.getElementById('wound-label');
                    woundLabel.classList.add('healed', 'hidden'); // Ocultar cuando est√° sellada
                    woundLabel.innerHTML = '‚úì Lesi√≥n Sellada';
                    updateUI();
                    return;
                }
            }
        }
        
        function hasPathToRight(currentPlatelet, rightSidePlatelets, visited) {
            // Check if current platelet is on the right side
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;
            
            if (currentPlatelet.body.position.x > woundRight - 20) {
                return true; // Reached right side
            }
            
            // Mark as visited
            visited.add(currentPlatelet.body.id);
            
            // Check all fibrin connections from this platelet
            for (let i = 0; i < state.fibrinConstraints.length; i++) {
                const fibrin = state.fibrinConstraints[i];
                let connectedPlatelet = null;
                
                // Find which platelet is connected to current one
                if (fibrin.pointA === currentPlatelet.body) {
                    connectedPlatelet = state.stuckPlatelets.find(p => p.body === fibrin.pointB);
                } else if (fibrin.pointB === currentPlatelet.body) {
                    connectedPlatelet = state.stuckPlatelets.find(p => p.body === fibrin.pointA);
                }
                
                if (connectedPlatelet && !visited.has(connectedPlatelet.body.id)) {
                    // Check if this connection crosses the wound area
                    const px1 = currentPlatelet.body.position.x;
                    const px2 = connectedPlatelet.body.position.x;
                    const woundLeft = woundX - woundWidth / 2;
                    const woundRight = woundX + woundWidth / 2;
                    
                    // Connection crosses wound if one point is left and other is right
                    if ((px1 < woundLeft && px2 > woundRight) || (px2 < woundLeft && px1 > woundRight)) {
                        // Direct crossing found
                        return true;
                    }
                    
                    // Continue searching through this connection
                    if (hasPathToRight(connectedPlatelet, rightSidePlatelets, visited)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // ==================== RENDERIZADO DEL VASO SANGU√çNEO ====================
        
        // Cache para el fondo del vaso (se genera una vez y se reutiliza)
        let vesselBackgroundCache = null;
        
        function renderVesselBackground(event) {
            const ctx = render.context;
            const canvas = render.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Si el canvas cambi√≥ de tama√±o, regenerar el cache
            if (!vesselBackgroundCache || vesselBackgroundCache.width !== width || vesselBackgroundCache.height !== height) {
                const cacheCanvas = document.createElement('canvas');
                cacheCanvas.width = width;
                cacheCanvas.height = height;
                const cacheCtx = cacheCanvas.getContext('2d');
                
                // Fondo base - gradiente que simula el interior de un vaso sangu√≠neo
                const baseGradient = cacheCtx.createLinearGradient(0, 0, 0, height);
                baseGradient.addColorStop(0, '#1a0505'); // Muy oscuro arriba (cerca de la pared)
                baseGradient.addColorStop(0.15, '#2a0a0a'); // Transici√≥n
                baseGradient.addColorStop(0.35, '#3d1515'); // Zona media-alta
                baseGradient.addColorStop(0.5, '#4a1a1a'); // Centro - m√°s iluminado (flujo sangu√≠neo)
                baseGradient.addColorStop(0.65, '#3d1515'); // Zona media-baja
                baseGradient.addColorStop(0.85, '#2a0a0a'); // Transici√≥n
                baseGradient.addColorStop(1, '#1a0505'); // Muy oscuro abajo (cerca de la pared)
                
                cacheCtx.fillStyle = baseGradient;
                cacheCtx.fillRect(0, 0, width, height);
                
                // Agregar gradiente radial central para simular el flujo de sangre (lumen)
                const centerGradient = cacheCtx.createRadialGradient(
                    width * 0.4, height / 2, 0,
                    width * 0.4, height / 2, Math.max(width, height) * 0.6
                );
                centerGradient.addColorStop(0, 'rgba(139, 30, 30, 0.25)'); // Rojo oscuro en el centro
                centerGradient.addColorStop(0.3, 'rgba(100, 20, 20, 0.15)');
                centerGradient.addColorStop(0.6, 'rgba(60, 10, 10, 0.08)');
                centerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                cacheCtx.fillStyle = centerGradient;
                cacheCtx.fillRect(0, 0, width, height);
                
                // Agregar efecto de profundidad con sombras en los bordes
                const edgeShadow = cacheCtx.createLinearGradient(0, 0, 0, height);
                edgeShadow.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
                edgeShadow.addColorStop(0.1, 'rgba(0, 0, 0, 0.1)');
                edgeShadow.addColorStop(0.9, 'rgba(0, 0, 0, 0.1)');
                edgeShadow.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                
                cacheCtx.fillStyle = edgeShadow;
                cacheCtx.fillRect(0, 0, width, height);
                
                // L√≠neas horizontales sutiles para simular el flujo laminar de la sangre
                cacheCtx.strokeStyle = 'rgba(80, 20, 20, 0.08)';
                cacheCtx.lineWidth = 1;
                for (let y = 30; y < height - 30; y += 8) {
                    cacheCtx.beginPath();
                    // L√≠neas ligeramente onduladas
                    cacheCtx.moveTo(0, y);
                    for (let x = 0; x < width; x += 50) {
                        const wave = Math.sin(x * 0.02 + y * 0.1) * 1.5;
                        cacheCtx.lineTo(x, y + wave);
                    }
                    cacheCtx.stroke();
                }
                
                vesselBackgroundCache = cacheCanvas;
            }
            
            // Dibujar el fondo desde el cache (muy r√°pido)
            ctx.drawImage(vesselBackgroundCache, 0, 0);
        }
        
        function renderVesselWalls(event) {
            const ctx = render.context;
            const canvas = render.canvas;
            const width = canvas.width;
            const height = canvas.height;
            const { thickness } = CONFIG.wall;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            ctx.save();
            
            // ========== PARED INFERIOR (Endotelio vascular) ==========
            const bottomY = height - thickness;
            
            // Capa 1: Adventitia (tejido conectivo externo) - m√°s oscuro
            const adventitiaGradient = ctx.createLinearGradient(0, height - thickness, 0, height);
            adventitiaGradient.addColorStop(0, '#2d1a1a');
            adventitiaGradient.addColorStop(0.3, '#3d2222');
            adventitiaGradient.addColorStop(0.7, '#4a2828');
            adventitiaGradient.addColorStop(1, '#3d2222');
            
            ctx.fillStyle = adventitiaGradient;
            ctx.fillRect(0, height - thickness, width, thickness);
            
            // Capa 2: Media (m√∫sculo liso) - tono medio
            const mediaGradient = ctx.createLinearGradient(0, height - thickness, 0, height - thickness * 0.4);
            mediaGradient.addColorStop(0, '#5a3535');
            mediaGradient.addColorStop(0.5, '#6b4040');
            mediaGradient.addColorStop(1, '#7a4a4a');
            
            ctx.fillStyle = mediaGradient;
            ctx.fillRect(0, height - thickness, width, thickness * 0.6);
            
            // Capa 3: Intima/Endotelio (superficie interior) - m√°s rosado/brillante
            const intimaGradient = ctx.createLinearGradient(0, height - thickness, 0, height - thickness * 0.7);
            intimaGradient.addColorStop(0, '#8b5555');
            intimaGradient.addColorStop(0.3, '#a06666');
            intimaGradient.addColorStop(0.7, '#b87777');
            intimaGradient.addColorStop(1, '#c98888');
            
            ctx.fillStyle = intimaGradient;
            ctx.fillRect(0, height - thickness, width, thickness * 0.3);
            
            // Brillo sutil en el borde interior (superficie del endotelio)
            ctx.strokeStyle = 'rgba(255, 200, 180, 0.35)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height - thickness);
            ctx.lineTo(width, height - thickness);
            ctx.stroke();
            
            // Textura del tejido - fibras horizontales
            ctx.strokeStyle = 'rgba(100, 50, 50, 0.15)';
            ctx.lineWidth = 1;
            for (let y = height - thickness + 3; y < height - 2; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // ========== PARED SUPERIOR IZQUIERDA ==========
            const topY = 0;
            
            // Adventitia
            ctx.fillStyle = adventitiaGradient;
            ctx.fillRect(0, 0, woundLeft, thickness);
            
            // Media
            const topMediaGradient = ctx.createLinearGradient(0, thickness * 0.4, 0, thickness);
            topMediaGradient.addColorStop(0, '#7a4a4a');
            topMediaGradient.addColorStop(0.5, '#6b4040');
            topMediaGradient.addColorStop(1, '#5a3535');
            
            ctx.fillStyle = topMediaGradient;
            ctx.fillRect(0, thickness * 0.4, woundLeft, thickness * 0.6);
            
            // Intima
            const topIntimaGradient = ctx.createLinearGradient(0, thickness * 0.7, 0, thickness);
            topIntimaGradient.addColorStop(0, '#c98888');
            topIntimaGradient.addColorStop(0.3, '#b87777');
            topIntimaGradient.addColorStop(0.7, '#a06666');
            topIntimaGradient.addColorStop(1, '#8b5555');
            
            ctx.fillStyle = topIntimaGradient;
            ctx.fillRect(0, thickness * 0.7, woundLeft, thickness * 0.3);
            
            // Brillo del endotelio
            ctx.strokeStyle = 'rgba(255, 200, 180, 0.35)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, thickness);
            ctx.lineTo(woundLeft, thickness);
            ctx.stroke();
            
            // Textura
            ctx.strokeStyle = 'rgba(100, 50, 50, 0.15)';
            ctx.lineWidth = 1;
            for (let y = 3; y < thickness - 2; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(woundLeft, y);
                ctx.stroke();
            }
            
            // ========== PARED SUPERIOR DERECHA ==========
            // Adventitia
            ctx.fillStyle = adventitiaGradient;
            ctx.fillRect(woundRight, 0, width - woundRight, thickness);
            
            // Media
            ctx.fillStyle = topMediaGradient;
            ctx.fillRect(woundRight, thickness * 0.4, width - woundRight, thickness * 0.6);
            
            // Intima
            ctx.fillStyle = topIntimaGradient;
            ctx.fillRect(woundRight, thickness * 0.7, width - woundRight, thickness * 0.3);
            
            // Brillo del endotelio
            ctx.strokeStyle = 'rgba(255, 200, 180, 0.35)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(woundRight, thickness);
            ctx.lineTo(width, thickness);
            ctx.stroke();
            
            // Textura
            ctx.strokeStyle = 'rgba(100, 50, 50, 0.15)';
            ctx.lineWidth = 1;
            for (let y = 3; y < thickness - 2; y += 4) {
                ctx.beginPath();
                ctx.moveTo(woundRight, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // ========== BORDES DE LA HERIDA ==========
            // Renderizar los bordes de la herida como tejido da√±ado
            const woundEdgeWidth = 6;
            
            // Borde izquierdo de la herida
            const woundEdgeGradient = ctx.createLinearGradient(woundLeft - woundEdgeWidth, 0, woundLeft, 0);
            woundEdgeGradient.addColorStop(0, '#c98888');
            woundEdgeGradient.addColorStop(0.3, '#d46666');
            woundEdgeGradient.addColorStop(0.7, '#e55555');
            woundEdgeGradient.addColorStop(1, '#ff6666');
            
            ctx.fillStyle = woundEdgeGradient;
            ctx.fillRect(woundLeft - woundEdgeWidth / 2, 0, woundEdgeWidth, thickness + 5);
            
            // Borde derecho de la herida
            const woundEdgeGradientRight = ctx.createLinearGradient(woundRight, 0, woundRight + woundEdgeWidth, 0);
            woundEdgeGradientRight.addColorStop(0, '#ff6666');
            woundEdgeGradientRight.addColorStop(0.3, '#e55555');
            woundEdgeGradientRight.addColorStop(0.7, '#d46666');
            woundEdgeGradientRight.addColorStop(1, '#c98888');
            
            ctx.fillStyle = woundEdgeGradientRight;
            ctx.fillRect(woundRight - woundEdgeWidth / 2, 0, woundEdgeWidth, thickness + 5);
            
            // Efecto de "sangrado" en los bordes de la herida
            ctx.strokeStyle = 'rgba(255, 80, 80, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(woundLeft - 1, 0);
            ctx.lineTo(woundLeft - 1, thickness + 8);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(woundRight + 1, 0);
            ctx.lineTo(woundRight + 1, thickness + 8);
            ctx.stroke();
            
            // Brillo/reflejo en los bordes de la herida
            ctx.strokeStyle = 'rgba(255, 150, 150, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(woundLeft - 2, 0);
            ctx.lineTo(woundLeft - 2, thickness + 6);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(woundRight + 2, 0);
            ctx.lineTo(woundRight + 2, thickness + 6);
            ctx.stroke();
            
            ctx.restore();
        }

        function renderFibrin(event) {
            const ctx = render.context;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const adhesionLineY = 23; // Centro del √°rea de adhesi√≥n (debe coincidir con el √°rea de adhesi√≥n)
            const adhesionZoneHalfWidth = 12; // Mitad del ancho del √°rea de adhesi√≥n
            
            // Render ointment layer when treatment is applied - ultra simple for performance
            if (state.showOintment) {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.35)';
                ctx.fillRect(woundLeft, adhesionLineY - adhesionZoneHalfWidth, woundWidth, adhesionZoneHalfWidth * 2);
            }
            
            // Calcular opacidad de la malla morada basada en densidad de plaquetas pegadas en el √°rea de adhesi√≥n
            const stuckPlateletsInWound = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                return px >= woundLeft - 20 && px <= woundRight + 20 && 
                       py >= adhesionLineY - adhesionZoneHalfWidth && py <= adhesionLineY + adhesionZoneHalfWidth;
            }).length;
            
            const maxPlatelets = 20; // M√°ximo esperado de plaquetas en la herida
            // La malla morada empieza muy transparente (0.05) y se opaca progresivamente hasta 0.9
            const meshOpacity = Math.min(0.9, 0.05 + (stuckPlateletsInWound / maxPlatelets) * 0.85);
            
            // √Årea de la malla morada coincide con el √°rea de adhesi√≥n
            const meshTopY = adhesionLineY - adhesionZoneHalfWidth;
            const meshHeight = adhesionZoneHalfWidth * 2; // Altura total del √°rea de adhesi√≥n
            
            // Renderizar malla morada horizontal en la zona de adhesi√≥n que se opaca progresivamente
            // Solo esta √°rea horizontal es morada - las cuerdas son verdes
            if (state.fibrinFormationStarted && stuckPlateletsInWound > 0) {
                ctx.fillStyle = `rgba(157, 78, 221, ${meshOpacity})`; // Morado #9D4EDD
                ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
            }
            
            // Overlay verde cuando est√° sellada
            if (state.hemostasisAchieved) {
                ctx.fillStyle = 'rgba(34, 197, 94, 0.3)'; // Verde semitransparente
                ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
            }
            
            // Render fibrin connections (cuerdas) - optimized for performance
            if (state.fibrinConstraints.length > 0) {
                ctx.save(); // Guardar estado del contexto antes de dibujar cuerdas verdes
                
                for (let i = 0; i < state.fibrinConstraints.length; i++) {
                    const fibrin = state.fibrinConstraints[i];
                    const pointA = fibrin.pointA.position;
                    const pointB = fibrin.pointB.position;
                    
                    // Only draw if both points are still valid
                    if (pointA && pointB) {
                        const fibrinType = fibrin.fibrinType || 'thin';
                        let lineWidth, opacity;
                        
                        // Configurar grosor y opacidad seg√∫n tipo de cuerda
                        switch (fibrinType) {
                            case 'thick':
                                lineWidth = 7; // Aumentado de 5 a 7px
                                opacity = 0.9;
                                break;
                            case 'medium':
                                lineWidth = 4; // Aumentado de 3 a 4px
                                opacity = 0.6;
                                break;
                            case 'thin':
                            default:
                                lineWidth = 2; // Aumentado de 1.5 a 2px
                                opacity = 0.4;
                                break;
                        }
                        
                        // Ajustar opacidad seg√∫n estabilidad
                        opacity *= (fibrin.stability || 1.0);
                        
                        // Color verde para las cuerdas (solo la malla horizontal es morada)
                        ctx.strokeStyle = `rgba(34, 197, 94, ${opacity * 0.8})`; // Verde #22C55E con opacidad
                        ctx.lineWidth = lineWidth;
                        
                        ctx.beginPath();
                    ctx.moveTo(pointA.x, pointA.y);
                    ctx.lineTo(pointB.x, pointB.y);
                        ctx.stroke();
                    }
                }
                
                ctx.restore(); // Restaurar estado del contexto despu√©s de dibujar cuerdas blancas
            }
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 230, b: 118 };
        }
        
        function renderVWF(event) {
            const ctx = render.context;
            
            // Verificar si debe mostrar vWF (cemento entre plaquetas)
            const conditionConfig = CONFIG.conditions[state.condition];
            const shouldShowVWF = state.condition === 'normal' || state.treatmentApplied || 
                                  (state.condition === 'vwd' && state.treatmentApplied);
            
            if (!shouldShowVWF || state.stuckPlatelets.length < 2) {
                return; // No mostrar vWF si no hay vWF o menos de 2 plaquetas
            }
            
            // Dibujar l√≠neas verdes cortas (cemento) entre plaquetas pegadas que est√°n cerca
            const maxVWFDistance = 12; // Distancia m√°xima para mostrar conexi√≥n vWF
            const maxVWFDistanceSq = maxVWFDistance * maxVWFDistance;
            
            // Asegurar que el color verde se aplique correctamente
            ctx.save(); // Guardar estado del contexto
            
            // Usar rgba para asegurar que el color verde se aplique correctamente
            ctx.strokeStyle = 'rgba(34, 197, 94, 1.0)'; // Verde #22C55E en formato rgba
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.globalAlpha = 1.0; // Asegurar opacidad completa para el verde
            
            // Dibujar l√≠neas entre plaquetas cercanas
            for (let i = 0; i < state.stuckPlatelets.length; i++) {
                const plateletA = state.stuckPlatelets[i];
                if (!plateletA.body) continue;
                
                const posA = plateletA.body.position;
                
                for (let j = i + 1; j < state.stuckPlatelets.length; j++) {
                    const plateletB = state.stuckPlatelets[j];
                    if (!plateletB.body) continue;
                    
                    const posB = plateletB.body.position;
                    const dx = posB.x - posA.x;
                    const dy = posB.y - posA.y;
                    const distSq = dx * dx + dy * dy;
                    
                    // Solo dibujar si est√°n cerca (como cemento entre piedras adyacentes)
                    if (distSq < maxVWFDistanceSq && distSq > 4) {
                        const dist = Math.sqrt(distSq);
                        // Opacidad basada en distancia (m√°s opaco cuanto m√°s cerca)
                        const opacity = 0.7 + (1.0 - dist / maxVWFDistance) * 0.3; // Entre 0.7 y 1.0
                        
                        // Re-establecer el color verde antes de cada l√≠nea para asegurar que siempre sea verde
                        ctx.strokeStyle = `rgba(34, 197, 94, ${opacity})`; // Verde con opacidad variable
                        ctx.beginPath();
                        ctx.moveTo(posA.x, posA.y);
                        ctx.lineTo(posB.x, posB.y);
                ctx.stroke();
                    }
                }
            }
            
            ctx.restore(); // Restaurar estado del contexto
        }
        
        function renderParticlesCustom(event) {
            const ctx = render.context;
            
            // Renderizar todas las part√≠culas con estilo personalizado (highlights, sombras, formas)
            // Renderizar solo plaquetas, gl√≥bulos rojos y gl√≥bulos blancos
            state.allBodies.forEach(body => {
                if (!body.label || (body.label !== 'platelet' && body.label !== 'rbc' && body.label !== 'wbc')) return;
                
                const x = body.position.x;
                const y = body.position.y;
                const angle = body.angle;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                if (body.label === 'rbc') {
                    // Gl√≥bulo rojo: ovalado con highlight y sombra
                    const radiusX = 6;
                    const radiusY = 4.5; // M√°s ancho que alto para efecto ovalado
                    
                    // Sombra/contorno oscuro
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radiusX + 0.5, radiusY + 0.5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(139, 0, 0, 0.3)'; // Rojo muy oscuro para sombra
                    ctx.fill();
                    
                    // Cuerpo principal rojo oscuro
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#B91C1C'; // Rojo oscuro
                    ctx.fill();
                    
                    // Highlight peque√±o cerca del centro (superior izquierda)
                    ctx.beginPath();
                    ctx.arc(-1.5, -1, 1.2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 200, 200, 0.8)'; // Rojo claro/rosa para highlight
                    ctx.fill();
                    
                } else if (body.label === 'wbc') {
                    // Gl√≥bulo blanco: circular con highlight brillante y contorno azul oscuro
                    const radius = 10;
                    
                    // Contorno azul oscuro para profundidad
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 1, 0, Math.PI * 2);
                    ctx.strokeStyle = '#4A90E2'; // Azul m√°s oscuro para contorno
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Cuerpo principal azul claro
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#87CEEB'; // Azul claro
                    ctx.fill();
                    
                    // Highlight brillante blanco en cuadrante superior izquierdo
                    const gradient = ctx.createRadialGradient(-3, -3, 0, -3, -3, 4);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)'); // Blanco brillante en el centro
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); // Transparente hacia afuera
                    
                    ctx.beginPath();
                    ctx.arc(-3, -3, 4, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Punto de highlight m√°s peque√±o y brillante
                    ctx.beginPath();
                    ctx.arc(-3, -3, 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)'; // Blanco s√≥lido
                    ctx.fill();
                    
                } else if (body.label === 'platelet') {
                    // Plaqueta: circular gris con highlight sutil
                    const radius = 4;
                    
                    // Sombra sutil
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.2)'; // Gris oscuro para sombra
                    ctx.fill();
                    
                    // Cuerpo principal gris
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#808080'; // Gris medio
                    ctx.fill();
                    
                    // Highlight peque√±o en cuadrante superior izquierdo
                    ctx.beginPath();
                    ctx.arc(-1.2, -1.2, 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(220, 220, 220, 0.7)'; // Gris claro para highlight
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function calculateClotPercentage() {
            // Si la herida est√° sellada (red de fibrina de izquierda a derecha y no pasan part√≠culas), 100%
            if (state.hemostasisAchieved) {
                state.clotPercentage = 100;
                return;
            }
            
            const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
            const woundWidth = CONFIG.wound.width;
            const woundCenterY = 29; // Y position where platelets stick

            // Optimized coverage calculation
            const segments = 20; // Reduced from 30 for better performance
            const segmentWidth = woundWidth / segments;
            let coveredSegments = 0;
            const coverageThreshold = 15 * 15; // Squared distance for comparison

            // Pre-filter platelets that are actually in the wound area (exclude anchor platelets)
            const relevantPlatelets = state.stuckPlatelets.filter(p => {
                // Excluir plaquetas anchor del c√°lculo
                if (p.isAnchor) return false;
                
                const px = p.body.position.x;
                const py = p.body.position.y;
                return px >= woundLeft - 20 && px <= woundLeft + woundWidth + 20 && 
                       py >= woundCenterY - 15 && py <= woundCenterY + 15;
            });

            for (let i = 0; i < segments; i++) {
                const segmentX = woundLeft + (i + 0.5) * segmentWidth;
                
                // Check if any stuck platelet covers this segment (optimized)
                const covered = relevantPlatelets.some(p => {
                    const dx = p.body.position.x - segmentX;
                    const dy = p.body.position.y - woundCenterY;
                    return (dx * dx + dy * dy) < coverageThreshold;
                });

                if (covered) coveredSegments++;
            }

            state.clotPercentage = Math.min(100, Math.round((coveredSegments / segments) * 100));

            // Check if wound is sealed by fibrin network crossing left to right
            // Esto detecta cuando la red de fibrina va de izquierda a derecha
            checkWoundSealed();
            
            // Si est√° sellada, asegurar que el porcentaje sea 100%
            if (state.hemostasisAchieved) {
                state.clotPercentage = 100;
            }
        }

        function updateUI() {
            document.getElementById('blood-loss').textContent = state.bloodLoss;
            document.getElementById('clot-percentage').textContent = state.clotPercentage + '%';
            document.getElementById('clot-bar').style.width = state.clotPercentage + '%';

            // Status indicator
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            if (state.hemostasisAchieved) {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Hemostasia lograda';
            } else if (state.treatmentApplied) {
                statusDot.className = 'status-dot treated';
                statusText.textContent = 'Tratamiento activo';
            } else if (state.bloodLoss > 20) {
                statusDot.className = 'status-dot bleeding';
                statusText.textContent = 'Sangrado activo';
            } else {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Simulaci√≥n activa';
            }
            
            // Actualizar m√©tricas avanzadas solo si la herida no est√° cerrada
            if (!state.hemostasisAchieved) {
                updateAdvancedMetrics();
                updateCharts();
            }
        }
        
        function updateAdvancedMetrics() {
            // Calcular tiempo de simulaci√≥n (ajustado por timeScale)
            const simulationTimeSeconds = accumulatedSimulationTime / 1000;
            
            // Tiempo hasta cierre de herida
            const el = document.getElementById('first-adhesion-time');
            if (state.hemostasisAchieved && state.woundClosureTime !== null && state.startTime) {
                // Mostrar el tiempo de simulaci√≥n cuando se cerr√≥ la herida (ya est√° en segundos de simulaci√≥n)
                if (el) el.textContent = state.woundClosureTime.toFixed(1) + 's';
            } else if (state.startTime && !state.hemostasisAchieved) {
                // Mostrar tiempo de simulaci√≥n transcurrido mientras la herida est√° abierta
                if (el) el.textContent = simulationTimeSeconds.toFixed(1) + 's';
            } else {
                // Sin datos a√∫n
                if (el) el.textContent = '--';
            }
            
            // Detener actualizaci√≥n de otras m√©tricas si la herida est√° cerrada
            if (state.hemostasisAchieved) return;
            
            // Velocidad de formaci√≥n de fibrina (conexiones por minuto)
            if (simulationTimeSeconds > 0) {
                const fibrinPerMinute = (state.fibrinConstraints.length / simulationTimeSeconds) * 60;
                const el = document.getElementById('fibrin-rate');
                if (el) el.textContent = fibrinPerMinute.toFixed(1) + '/min';
            }
            
            // Densidad del co√°gulo (plaquetas por √°rea de herida)
            const woundArea = CONFIG.wound.width * CONFIG.wound.height;
            const clotDensity = woundArea > 0 ? (state.stuckPlatelets.length / woundArea * 1000).toFixed(1) : 0;
            const el1 = document.getElementById('clot-density');
            if (el1) el1.textContent = clotDensity;
            
            // Tasa de agregaci√≥n (plaquetas pegadas / total spawnadas)
            const aggregationRate = state.totalPlateletsSpawned > 0 
                ? ((state.stuckPlatelets.length / state.totalPlateletsSpawned) * 100).toFixed(1) 
                : 0;
            const el2 = document.getElementById('aggregation-rate');
            if (el2) el2.textContent = aggregationRate + '%';
        }
        
        // Gr√°ficos en tiempo real usando Canvas
        const chartConfigs = {
            clot: { color: '#10B981', label: 'Cierre (%)' },
            bloodLoss: { color: '#DC2626', label: 'P√©rdida' },
            fibrin: { color: '#9D4EDD', label: 'Conexiones' }
        };
        
        function initCharts() {
            // Esperar a que los elementos existan
            setTimeout(() => {
                const chartIds = ['clot-chart', 'blood-loss-chart', 'fibrin-chart'];
                chartIds.forEach(chartId => {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    if (canvas.offsetWidth > 0 && canvas.offsetHeight > 0) {
                        canvas.width = canvas.offsetWidth * 2; // Retina display
                        canvas.height = canvas.offsetHeight * 2;
                        ctx.scale(2, 2);
                    }
                });
            }, 100);
        }
        
        function updateCharts() {
            // A√±adir nuevos datos al historial solo si la simulaci√≥n est√° corriendo y no est√° cerrada
            if (state.simulationRunning && !state.hemostasisAchieved && state.startTime) {
                // Usar tiempo de simulaci√≥n (ajustado por timeScale) en lugar de tiempo real
                const simulationTimeSeconds = accumulatedSimulationTime / 1000;
                
                // A√±adir datos al historial (cada segundo de simulaci√≥n)
                const lastTime = state.history.time[state.history.time.length - 1] || 0;
                if (simulationTimeSeconds - lastTime >= 1) {
                    // Obtener p√©rdida sangu√≠nea directamente del DOM
                    const bloodLossEl = document.getElementById('blood-loss');
                    const currentBloodLoss = bloodLossEl ? parseInt(bloodLossEl.textContent) || 0 : 0;
                    
                    state.history.time.push(simulationTimeSeconds);
                    state.history.clotPercentage.push(state.clotPercentage);
                    state.history.bloodLoss.push(currentBloodLoss);
                    state.history.fibrinConnections.push(state.fibrinConstraints.length);
                    state.history.stuckPlatelets.push(state.stuckPlatelets.length);
                    
                    // Limitar historial a √∫ltimos 60 segundos
                    const maxHistory = 60;
                    if (state.history.time.length > maxHistory) {
                        state.history.time.shift();
                        state.history.clotPercentage.shift();
                        state.history.bloodLoss.shift();
                        state.history.fibrinConnections.shift();
                        state.history.stuckPlatelets.shift();
                    }
                }
            }
            
            // Preparar datos para gr√°ficos con el valor actual a√±adido
            let clotData = [...state.history.clotPercentage];
            let bloodLossData = [...state.history.bloodLoss];
            let fibrinData = [...state.history.fibrinConnections];
            
            // Si la simulaci√≥n est√° corriendo, a√±adir el valor actual al final para actualizaci√≥n en tiempo real
            if (state.simulationRunning && !state.hemostasisAchieved && state.startTime) {
                clotData.push(state.clotPercentage);
                
                // Obtener p√©rdida sangu√≠nea actual del DOM
                const bloodLossEl = document.getElementById('blood-loss');
                const currentBloodLoss = bloodLossEl ? parseInt(bloodLossEl.textContent) || 0 : 0;
                bloodLossData.push(currentBloodLoss);
                
                fibrinData.push(state.fibrinConstraints.length);
            }
            
            // Dibujar gr√°ficos siempre con datos actualizados en tiempo real
            drawChart('clot-chart', clotData, chartConfigs.clot, 100);
            drawChart('blood-loss-chart', bloodLossData, chartConfigs.bloodLoss, null);
            drawChart('fibrin-chart', fibrinData, chartConfigs.fibrin, null);
        }
        
        function drawChart(chartId, data, config, maxValue) {
            const canvas = document.getElementById(chartId);
            if (!canvas) {
                console.warn('Canvas not found:', chartId);
                return;
            }
            
            // Asegurar que el canvas est√© inicializado
            if (canvas.width === 0 || canvas.height === 0) {
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth * 2 || 200;
                canvas.height = canvas.offsetHeight * 2 || 140;
                ctx.scale(2, 2);
            }
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width / 2;
            const height = canvas.height / 2;
            
            // Limpiar canvas
            ctx.clearRect(0, 0, width, height);
            
            // Si no hay datos, mostrar gr√°fico vac√≠o con mensaje
            if (!data || data.length === 0) {
                ctx.fillStyle = '#94A3B8';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('Sin datos', width / 2, height / 2);
                return;
            }
            
            // Encontrar valores min/max
            const dataMax = maxValue !== null ? maxValue : Math.max(...data, 1);
            const dataMin = 0;
            const range = dataMax - dataMin || 1;
            
            // Configurar estilo
            ctx.strokeStyle = config.color;
            ctx.fillStyle = config.color;
            ctx.lineWidth = 2;
            
            // Dibujar l√≠nea
            ctx.beginPath();
            const stepX = width / Math.max(data.length - 1, 1);
            
            data.forEach((value, index) => {
                const x = index * stepX;
                const y = height - ((value - dataMin) / range) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Relleno bajo la l√≠nea
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.globalAlpha = 0.2;
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            // Etiquetas
            ctx.fillStyle = '#64748B';
            ctx.font = '10px Inter';
            ctx.textAlign = 'right';
            ctx.fillText(dataMax.toFixed(0), width - 4, 12);
            ctx.textAlign = 'left';
            ctx.fillText(config.label, 4, 12);
        }
        
        // Controles de velocidad
        function setupSpeedControls() {
            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            
            if (speedSlider) {
                speedSlider.addEventListener('input', (e) => {
                    state.timeScale = parseFloat(e.target.value);
                    if (speedValue) speedValue.textContent = state.timeScale + 'x';
                    
                    // Reiniciar el spawn para aplicar el nuevo intervalo
                    if (state.simulationRunning && !state.isPaused) {
                        startParticleSpawning();
                    }
                });
            }
        }
        
        // Panel educativo
        function setupEducationalPanel() {
            const toggle = document.getElementById('educational-toggle');
            const panel = document.getElementById('educational-panel');
            const arrow = document.getElementById('educational-arrow');
            
            if (toggle) {
                toggle.addEventListener('click', () => {
                    panel.classList.toggle('expanded');
                    if (arrow) arrow.textContent = panel.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
                });
            }
        }
        
        // Tooltips
        function setupTooltips() {
            const triggers = document.querySelectorAll('.tooltip-trigger');
            
            triggers.forEach(trigger => {
                const tooltip = trigger.parentElement.querySelector('.tooltip');
                
                trigger.addEventListener('mouseenter', () => {
                    if (tooltip) tooltip.classList.add('visible');
                });
                
                trigger.addEventListener('mouseleave', () => {
                    if (tooltip) tooltip.classList.remove('visible');
                });
            });
        }
        

        function applyTreatment() {
            if (state.treatmentApplied) return;

            state.treatmentApplied = true;
            state.showOintment = true;
            
            // Actualizar wizard - paso 2 completado
            updateWizardStep(2);

            // Show treatment indicator
            const indicator = document.getElementById('treatment-indicator');
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 2000);

            // Update button
            const btn = document.getElementById('treatment-btn');
            btn.classList.add('applied');
            btn.innerHTML = '‚úì Tratamiento Aplicado';
            btn.disabled = true;

            // Apply treatment effects based on condition
            const condition = CONFIG.conditions[state.condition];
            
            switch(state.condition) {
                case 'hemophilia':
                case 'hemophiliaSevere':
                    // Factor VIII/IX replacement - enables fibrin formation
                    applyFactorReplacement();
                    break;
                    
                case 'vwd':
                    // Desmopresina or vWF concentrate - improves platelet adhesion
                    applyVWFReplacement();
                    break;
                    
                case 'thrombocytopenia':
                    // Platelet transfusion - increases platelet count
                    applyPlateletTransfusion();
                    break;
                    
                case 'thrombasthenia':
                    // Platelet transfusion - provides functional platelets
                    applyPlateletTransfusion();
                    break;
                    
                case 'anticoagulated':
                    // Vitamin K or PCC - reverses anticoagulation
                    reverseAnticoagulation();
                    break;
                    
                default:
                    // Generic treatment - improves all parameters
                    applyGenericTreatment();
            }

            // For all conditions, try to form additional fibrin connections
            // Con tratamiento, intentar formar fibrina m√°s frecuentemente
            const retryInterval = state.treatmentApplied ? 100 : 200;
            const maxRetries = state.treatmentApplied ? 5 : 3;
            
            let retryCount = 0;
            const tryFormFibrinRepeatedly = () => {
                if (retryCount < maxRetries && !state.hemostasisAchieved) {
                    state.stuckPlatelets.forEach(plateletData => {
                        tryFormFibrin(plateletData);
                    });
                    retryCount++;
                    setTimeout(tryFormFibrinRepeatedly, retryInterval);
                }
            };
            
            setTimeout(tryFormFibrinRepeatedly, retryInterval);

            updateUI();
        }
        
        function applyFactorReplacement() {
            // Factor VIII/IX replacement for hemophilia
            // Gradually improves fibrin formation rate
            const condition = CONFIG.conditions[state.condition];
            const targetRate = 0.9;
            
            // Form fibrin on all existing stuck platelets immediately
            state.stuckPlatelets.forEach(plateletData => {
                if (!plateletData.hasFibrin) {
                    tryFormFibrin(plateletData);
                }
            });
            
            // Make all fibrin stable and glowing
            state.fibrinConstraints.forEach(f => {
                f.glowing = true;
                f.stability = 1.0;
                f.decayRate = 0;
                f.visualColor = '#39FF14';
                f.opacity = 1.0;
            });
        }
        
        function applyVWFReplacement() {
            // Desmopresina or vWF concentrate for von Willebrand disease
            // Improves platelet adhesion and function
            const condition = CONFIG.conditions[state.condition];
            
            // Update visual effects - platelets return to normal color
            state.stuckPlatelets.forEach(platelet => {
                platelet.body.render.fillStyle = '#808080';
            });
            
            // Improve adhesion for new platelets (handled by canStick check)
        }
        
        function applyPlateletTransfusion() {
            // Platelet transfusion for thrombocytopenia/thrombasthenia
            // Temporarily increases platelet spawn rate
            const condition = CONFIG.conditions[state.condition];
            const originalRatio = condition.plateletRatio;
            
            // Increase platelet ratio temporarily
            condition.plateletRatio = Math.min(0.35, originalRatio * 3);
            
            // Spawn extra platelets immediately
            for (let i = 0; i < 25; i++) {
                if (state.allBodies.length < CONFIG.particles.maxCount) {
                    createParticle('platelet');
                }
            }
            
            // Restore after 10 seconds
            setTimeout(() => {
                condition.plateletRatio = originalRatio;
            }, 10000);
        }
        
        function reverseAnticoagulation() {
            // Vitamin K or Prothrombin Complex Concentrate (PCC)
            // Improves fibrin stability and formation
            state.fibrinConstraints.forEach(f => {
                f.stability = Math.min(1.0, f.stability + 0.3);
                f.decayRate = 0;
                f.visualColor = '#00E676';
                f.opacity = 1.0;
            });
        }
        
        function applyGenericTreatment() {
            // Generic treatment - improves all parameters slightly
            state.fibrinConstraints.forEach(f => {
                f.stability = Math.min(1.0, f.stability + 0.2);
                f.glowing = true;
            });
        }

        function setCondition(condition) {
            state.condition = condition;
            state.treatmentApplied = false;
            state.simulationRunning = false;
            
            // Update UI
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.condition === condition);
            });
            
            // Actualizar panel educativo
            const conditionConfig = CONFIG.conditions[condition];
            const conditionNameEl = document.getElementById('current-condition-name');
            const conditionDescEl = document.getElementById('current-condition-desc');
            if (conditionNameEl) conditionNameEl.textContent = conditionConfig.name;
            if (conditionDescEl) conditionDescEl.textContent = conditionConfig.description;

            // Reset simulation
            initSimulation();
            
            // Actualizar wizard - paso 1 completado
            updateWizardStep(1);
            
            // Habilitar bot√≥n de inicio
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.textContent = '‚ñ∂ Iniciar Simulaci√≥n';
                startBtn.classList.remove('paused');
            }
        }
        
        function toggleSimulation() {
            if (!state.simulationRunning) {
                // Iniciar simulaci√≥n
                state.simulationRunning = true;
                state.isPaused = false;
                state.startTime = Date.now();
                state.firstAdhesionTime = null;
                state.woundClosureTime = null;
                state.totalPlateletsSpawned = 0;
                state.history = { time: [], clotPercentage: [], bloodLoss: [], fibrinConnections: [], stuckPlatelets: [] };
                // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
                lastPhysicsTime = 0;
                accumulatedTime = 0;
                
                // Asegurar que timeScale tenga un valor v√°lido
                if (!state.timeScale || state.timeScale <= 0) {
                    state.timeScale = 1.0;
                }
                
                // Reiniciar el spawn para asegurar que funcione
                startParticleSpawning();
                
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.textContent = '‚è∏ Pausar Simulaci√≥n';
                    startBtn.classList.add('paused');
                }
                updateWizardStep(3);
            } else {
                // Pausar simulaci√≥n
                state.simulationRunning = false;
                // No usar Runner.stop() - usamos nuestro propio loop
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.textContent = '‚ñ∂ Reanudar Simulaci√≥n';
                    startBtn.classList.remove('paused');
                }
            }
        }
        
        function updateWizardStep(step) {
            state.currentStep = step;
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');
                if (stepNum < step) {
                    el.classList.add('completed');
                } else if (stepNum === step) {
                    el.classList.add('active');
                }
            });
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initSimulation();

            // Condition buttons
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setCondition(btn.dataset.condition);
                });
            });

            // Treatment button
            document.getElementById('treatment-btn').addEventListener('click', applyTreatment);
            
            // Start button
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.addEventListener('click', toggleSimulation);
                startBtn.disabled = true; // Deshabilitado hasta seleccionar condici√≥n
            }

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', () => {
                state.simulationRunning = false;
                state.isPaused = false;
                // No necesitamos detener el runner porque usamos nuestro propio loop
                initSimulation();
                updateWizardStep(1);
                if (startBtn) {
                    startBtn.textContent = '‚ñ∂ Iniciar Simulaci√≥n';
                    startBtn.classList.remove('paused');
                    startBtn.disabled = false;
                }
            });
            
            // Inicializar controles avanzados
            initCharts();
            setupSpeedControls();
            setupEducationalPanel();
            setupTooltips();
            
            // Inicializar wizard
            updateWizardStep(1);
            
            // Asegurar que la condici√≥n normal est√© activa por defecto
            const normalBtn = document.querySelector('[data-condition="normal"]');
            if (normalBtn) {
                normalBtn.classList.add('active');
            }
            
            // Habilitar bot√≥n de inicio ya que la condici√≥n normal est√° activa por defecto
            if (startBtn) {
                startBtn.disabled = false;
            }
        });
    </script>
</body>
</html>

