<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Laboratorio Virtual de Hemostasia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Enlace de salto r√°pido para accesibilidad -->
    <a href="#main-content" class="skip-link">Saltar al contenido principal</a>
    
    <header class="header" role="banner">
      <button
        class="tutorial-start-btn"
        id="tutorial-start-btn"
        aria-label="Iniciar tutorial interactivo"
        aria-describedby="tutorial-description"
      >
        üéì Tutorial
      </button>
      <span id="tutorial-description" class="sr-only">
        Abre un tutorial paso a paso sobre c√≥mo usar el simulador
      </span>
      <div class="header-title">
        <h1>Laboratorio Virtual de Hemostasia</h1>
      </div>
      <button
        class="accessibility-btn"
        id="accessibility-btn"
        aria-label="Abrir configuraci√≥n de accesibilidad"
        aria-expanded="false"
        aria-controls="accessibility-panel"
        title="Accesibilidad (Alt+A)"
      >
        ‚ôø Accesibilidad
      </button>
    </header>

    <main class="main-container" id="main-content" role="main">
      <!-- Sistema de Tutorial Interactivo -->
      <div class="tutorial-overlay" id="tutorial-overlay" aria-hidden="true"></div>
      <div class="tutorial-highlight" id="tutorial-highlight" aria-hidden="true"></div>
      <div class="tutorial-panel" id="tutorial-panel" role="dialog" aria-labelledby="tutorial-title-text" aria-modal="true" aria-hidden="true">
        <div class="tutorial-robot-container" aria-hidden="true">
          <img
            src="images/DIINA-08.png"
            alt="DIINA Robot"
            class="tutorial-robot-image"
          />
        </div>
        <div class="tutorial-header">
          <div class="tutorial-title">
            <img
              src="images/puzzle.svg"
              alt=""
              class="tutorial-icon-puzzle"
              aria-hidden="true"
            />
            <span id="tutorial-title-text">RECUERDA</span>
          </div>
          <button class="tutorial-close" id="tutorial-close" aria-label="Cerrar tutorial">√ó</button>
        </div>
        <div class="tutorial-content">
          <div class="tutorial-step-indicator">
            <div class="tutorial-step-info">
              <span>Paso</span>
              <span id="tutorial-current-step">1</span>
              <span>de</span>
              <span id="tutorial-total-steps">8</span>
            </div>
            <div class="tutorial-progress-bar">
              <div
                class="tutorial-progress-fill"
                id="tutorial-progress-fill"
              ></div>
            </div>
            <div class="tutorial-step-dots" id="tutorial-step-dots"></div>
          </div>
          <div class="tutorial-text" id="tutorial-text">
            Contenido del tutorial
          </div>
          <div class="tutorial-actions">
            <button
              class="tutorial-btn tutorial-btn-secondary"
              id="tutorial-prev"
              aria-label="Paso anterior del tutorial"
            >
              Anterior
            </button>
            <button
              class="tutorial-btn tutorial-btn-primary"
              id="tutorial-next"
              aria-label="Siguiente paso del tutorial"
            >
              Siguiente
            </button>
          </div>
        </div>
      </div>

      <!-- Layout principal de tres columnas -->
      <div class="simulator-layout">
        <!-- Columna izquierda: Condiciones Cl√≠nicas -->
        <aside class="conditions-sidebar" role="complementary" aria-label="Condiciones cl√≠nicas">
          <div class="panel-card" role="region" aria-labelledby="condition-title">
            <div class="panel-title" id="condition-title">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"
                />
              </svg>
              Condici√≥n Cl√≠nica
            </div>
            <div class="condition-grid" role="radiogroup" aria-labelledby="condition-title">
            <button 
              class="condition-btn" 
              data-condition="normal"
              role="radio"
              aria-checked="false"
              aria-describedby="normal-desc"
            >
              <div class="condition-name">Normal</div>
              <div class="condition-desc" id="normal-desc">
                Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan
                correctamente
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="hemophilia"
              role="radio"
              aria-checked="false"
              aria-describedby="hemophilia-desc"
            >
              <div class="condition-name">Hemofilia A/B</div>
              <div class="condition-desc" id="hemophilia-desc">
                D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la
                fibrina se forma muy lentamente y es inestable
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="vwd"
              role="radio"
              aria-checked="false"
              aria-describedby="vwd-desc"
            >
              <div class="condition-name">Von Willebrand</div>
              <div class="condition-desc" id="vwd-desc">
                D√©ficit Factor vWF - Las plaquetas tienen dificultad para
                adherirse a la herida
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="thrombocytopenia"
              role="radio"
              aria-checked="false"
              aria-describedby="thrombocytopenia-desc"
            >
              <div class="condition-name">Trombocitopenia</div>
              <div class="condition-desc" id="thrombocytopenia-desc">
                Recuento bajo de plaquetas - Pocas plaquetas disponibles para
                formar el co√°gulo
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="hemophiliaSevere"
              role="radio"
              aria-checked="false"
              aria-describedby="hemophiliaSevere-desc"
            >
              <div class="condition-name">Hemofilia Severa</div>
              <div class="condition-desc" id="hemophiliaSevere-desc">
                D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina,
                sangrado prolongado
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="thrombasthenia"
              role="radio"
              aria-checked="false"
              aria-describedby="thrombasthenia-desc"
            >
              <div class="condition-name">Trombastenia</div>
              <div class="condition-desc" id="thrombasthenia-desc">
                D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero
                no se agregan entre s√≠
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="factorDeficiency"
              role="radio"
              aria-checked="false"
              aria-describedby="factorDeficiency-desc"
            >
              <div class="condition-name">D√©ficit Factor VII</div>
              <div class="condition-desc" id="factorDeficiency-desc">
                V√≠a extr√≠nseca defectuosa - Formaci√≥n de fibrina reducida
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="anticoagulated"
              role="radio"
              aria-checked="false"
              aria-describedby="anticoagulated-desc"
            >
              <div class="condition-name">Anticoagulado</div>
              <div class="condition-desc" id="anticoagulated-desc">
                Warfarina - Factores dependientes de vitamina K reducidos,
                fibrina inestable
              </div>
            </button>
          </div>
        </div>
        </aside>

        <!-- Columna central: Simulador -->
        <section class="viewer-section" aria-labelledby="simulation-title">
          <h2 id="simulation-title" class="sr-only">√Årea de simulaci√≥n de coagulaci√≥n sangu√≠nea</h2>
          
          <!-- Leyenda encima del simulador -->
          <div class="legend">
            <div class="legend-item tooltip-container">
              <div class="legend-dot platelet"></div>
              <span class="tooltip-trigger">Plaquetas</span>
              <div class="tooltip">
                C√©lulas sangu√≠neas peque√±as que se adhieren a la herida y forman
                el tap√≥n inicial. Se activan al contacto con el col√°geno expuesto.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot rbc"></div>
              <span class="tooltip-trigger">Gl√≥bulos Rojos</span>
              <div class="tooltip">
                Eritrocitos que transportan ox√≠geno. No participan directamente en
                la coagulaci√≥n pero pueden quedar atrapados en el co√°gulo.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot wbc"></div>
              <span class="tooltip-trigger">Gl√≥bulos Blancos</span>
              <div class="tooltip">
                Leucocitos que participan en la respuesta inmune. Pueden ayudar en
                la limpieza de la herida.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot fibrin"></div>
              <span class="tooltip-trigger">Red de Fibrina</span>
              <div class="tooltip">
                Prote√≠na formada a partir del fibrin√≥geno por acci√≥n de la
                trombina. Crea una malla que refuerza el tap√≥n plaquetario.
              </div>
            </div>
            <div class="legend-item tooltip-container">
              <div class="legend-dot vwf"></div>
              <span class="tooltip-trigger">Factor von Willebrand</span>
              <div class="tooltip">
                Prote√≠na que media la adhesi√≥n de las plaquetas al col√°geno
                expuesto. Esencial para el inicio de la hemostasia.
              </div>
            </div>
          </div>
          
          <div class="viewer-container" role="img" aria-label="Simulaci√≥n de coagulaci√≥n sangu√≠nea">
            <div class="viewer-labels">
              <div class="label label-wound" id="wound-label" role="status" aria-live="polite">
                ‚ö†Ô∏è Lesi√≥n Activa
              </div>
            </div>
            <div class="treatment-indicator" id="treatment-indicator" role="status" aria-live="assertive" aria-atomic="true">
              üíâ Tratamiento Administrado
            </div>

            <!-- Sistema de Feedback Contextual -->
            <div class="contextual-feedback" id="contextual-feedback" role="alert" aria-live="polite" aria-atomic="true">
              <div class="feedback-header">
                <span class="feedback-icon" id="feedback-icon" aria-hidden="true">üí°</span>
                <span class="feedback-title" id="feedback-title"
                  >Informaci√≥n</span
                >
                <button class="feedback-close" id="feedback-close" aria-label="Cerrar mensaje">√ó</button>
              </div>
              <div class="feedback-content" id="feedback-content">
                Mensaje de feedback contextual
              </div>
            </div>

            <!-- Descripci√≥n textual para lectores de pantalla -->
            <div class="sr-only" id="canvas-description" aria-live="polite">
              Simulaci√≥n de coagulaci√≥n sangu√≠nea iniciando
            </div>

            <canvas 
              id="simulation-canvas"
              aria-label="Visualizaci√≥n de c√©lulas sangu√≠neas en el vaso sangu√≠neo"
              role="img"
              tabindex="0"
              aria-describedby="canvas-description"
            ></canvas>

            <!-- M√©tricas dentro del simulador (lado derecho) -->
            <div class="viewer-metrics">
              <div class="metric-box">
                <div class="metric-value blood-loss" id="blood-loss">0</div>
                <div class="metric-label">P√©rdida Sangu√≠nea</div>
              </div>
              <div class="metric-box">
                <div class="metric-value clot-progress" id="clot-percentage">
                  0%
                </div>
                <div class="metric-label">Cierre de la Herida</div>
              </div>
            </div>
          </div>

          <!-- Contenedor de botones de control -->
          <div class="simulation-controls-row">
            <button 
              class="start-btn control-btn-large" 
              id="start-btn"
              aria-label="Iniciar la simulaci√≥n"
              title="Iniciar simulaci√≥n (Alt+S)"
            >
              ‚ñ∂ Iniciar Simulaci√≥n
            </button>
            <button 
              class="pause-btn control-btn-small" 
              id="pause-btn"
              aria-label="Pausar la simulaci√≥n"
              title="Pausar simulaci√≥n"
              disabled
            >
              ‚è∏ Pausar
            </button>
            <button 
              class="reset-btn control-btn-small" 
              id="reset-btn"
              aria-label="Reiniciar la simulaci√≥n"
              title="Reiniciar simulaci√≥n (Alt+R)"
            >
              ‚Üª Reiniciar
            </button>
            <div class="speed-control control-speed">
              <label>Velocidad:</label>
              <input
                type="range"
                class="speed-slider"
                id="speed-slider"
                min="0.25"
                max="2"
                step="0.25"
                value="1"
              />
              <span id="speed-value">1x</span>
            </div>
            <button 
              class="treatment-btn control-btn-large" 
              id="treatment-btn"
              aria-label="Administrar tratamiento m√©dico"
              title="Aplicar tratamiento (Alt+T)"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"
                />
              </svg>
              Administrar Tratamiento
            </button>
          </div>

          <!-- Simulation Wizard -->
          <div class="simulation-wizard">
            <div class="wizard-step active" data-step="1">
              <div class="step-number">1</div>
              <div class="step-content">
                <div class="step-title">Selecciona condici√≥n</div>
                <div class="step-desc">
                  Elige una condici√≥n cl√≠nica arriba
                </div>
              </div>
            </div>
            <div class="wizard-arrow" aria-hidden="true">‚Üí</div>
            <div class="wizard-step" data-step="2">
              <div class="step-number">2</div>
              <div class="step-content">
                <div class="step-title">Inicia simulaci√≥n</div>
                <div class="step-desc">Presiona el bot√≥n Iniciar</div>
              </div>
            </div>
            <div class="wizard-arrow" aria-hidden="true">‚Üí</div>
            <div class="wizard-step" data-step="3">
              <div class="step-number">3</div>
              <div class="step-content">
                <div class="step-title">Aplica tratamiento</div>
                <div class="step-desc">Opcional: administra tratamiento</div>
              </div>
            </div>
          </div>

          <!-- Secci√≥n de informaci√≥n educativa y feedback acumulado -->
          <div class="info-feedback-section">
            <!-- Columna izquierda: Informaci√≥n Educativa -->
            <div class="educational-info-column">
              <div class="panel-card">
                <div class="panel-title">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12,3L1,9L12,15L21,10.09V17H23V9M5,13.18V17.18L12,21L19,17.18V13.18L12,17L5,13.18Z" />
                  </svg>
                  Informaci√≥n Educativa
                </div>
                <div class="educational-info-content" id="educational-info-content">
                  <!-- El contenido se actualizar√° din√°micamente -->
                </div>
              </div>
            </div>

            <!-- Columna derecha: Tablero de Feedback Acumulado -->
            <div class="feedback-board-column">
              <div class="panel-card">
                <div class="panel-title">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z" />
                  </svg>
                  Feedback Contextual
                </div>
                <div class="feedback-board" id="feedback-board">
                  <div class="feedback-board-empty">
                    Los mensajes de feedback aparecer√°n aqu√≠ con su tiempo de aparici√≥n
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Columna derecha: M√©tricas en Tiempo Real -->
        <aside class="metrics-sidebar" role="complementary" aria-label="M√©tricas en tiempo real">
          <div class="panel-card">
            <div class="metrics-section">
              <div class="panel-title">
                <svg viewBox="0 0 24 24">
                  <path
                    d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"
                  />
                </svg>
                M√©tricas en Tiempo Real
              </div>

              <!-- M√©tricas avanzadas -->
              <div class="advanced-metrics">
                <div class="advanced-metric">
                  <div class="advanced-metric-label">
                    Tiempo hasta cierre de herida
                  </div>
                  <div class="advanced-metric-value" id="first-adhesion-time">
                    --
                  </div>
                </div>
                <div class="advanced-metric">
                  <div class="advanced-metric-label">
                    Velocidad formaci√≥n fibrina
                  </div>
                  <div class="advanced-metric-value" id="fibrin-rate">
                    0/min
                  </div>
                </div>
                <div class="advanced-metric">
                  <div class="advanced-metric-label">Densidad del co√°gulo</div>
                  <div class="advanced-metric-value" id="clot-density">0</div>
                </div>
                <div class="advanced-metric">
                  <div class="advanced-metric-label">Tasa de agregaci√≥n</div>
                  <div class="advanced-metric-value" id="aggregation-rate">
                    0%
                  </div>
                </div>
              </div>

              <!-- Gr√°ficos en tiempo real -->
              <div class="charts-container">
                <div class="chart-panel">
                  <div class="chart-title">
                    <span>üìà</span> Evoluci√≥n del Cierre de la Herida
                  </div>
                  <canvas class="chart-canvas" id="clot-chart"></canvas>
                </div>
                <div class="chart-panel">
                  <div class="chart-title">
                    <span>ü©∏</span> P√©rdida Sangu√≠nea Acumulada
                  </div>
                  <canvas class="chart-canvas" id="blood-loss-chart"></canvas>
                </div>
                <div class="chart-panel">
                  <div class="chart-title">
                    <span>üï∏Ô∏è</span> Formaci√≥n de Red de Fibrina
                  </div>
                  <canvas class="chart-canvas" id="fibrin-chart"></canvas>
                </div>
              </div>
            </div>
          </div>
        </aside>
      </div>
    </main>

    <!-- Panel de Configuraci√≥n de Accesibilidad -->
    <div class="a11y-overlay" id="a11y-overlay" aria-hidden="true"></div>
    <div 
      class="accessibility-panel" 
      id="accessibility-panel" 
      role="dialog" 
      aria-labelledby="a11y-title" 
      aria-hidden="true"
      aria-modal="true"
    >
      <div class="a11y-header">
        <h2 id="a11y-title">Configuraci√≥n de Accesibilidad</h2>
        <button class="a11y-close" id="a11y-close" aria-label="Cerrar panel de accesibilidad">√ó</button>
      </div>
      <div class="a11y-content">
        <section>
          <h3>Tama√±o de fuente</h3>
          <div class="font-size-control" role="group" aria-label="Tama√±o de fuente">
            <button class="font-size-btn" data-size="small" aria-label="Tama√±o peque√±o">A-</button>
            <button class="font-size-btn active" data-size="medium" aria-label="Tama√±o medio">A</button>
            <button class="font-size-btn" data-size="large" aria-label="Tama√±o grande">A+</button>
            <button class="font-size-btn" data-size="xlarge" aria-label="Tama√±o extra grande">A++</button>
            <button class="font-size-btn" data-size="xxlarge" aria-label="Tama√±o muy grande">A+++</button>
          </div>
        </section>
        
        <section>
          <h3>Contraste</h3>
          <label>
            <input type="checkbox" id="high-contrast-checkbox">
            Modo de alto contraste
          </label>
        </section>
        
        <section>
          <h3>Animaciones</h3>
          <label>
            <input type="checkbox" id="reduce-motion-checkbox">
            Reducir animaciones
          </label>
        </section>
        
        <section>
          <h3>Atajos de teclado</h3>
          <dl class="keyboard-shortcuts">
            <dt><kbd>Alt</kbd> + <kbd>S</kbd></dt>
            <dd>Iniciar/Pausar simulaci√≥n</dd>
            <dt><kbd>Alt</kbd> + <kbd>T</kbd></dt>
            <dd>Aplicar tratamiento</dd>
            <dt><kbd>Alt</kbd> + <kbd>R</kbd></dt>
            <dd>Reiniciar</dd>
            <dt><kbd>Alt</kbd> + <kbd>H</kbd></dt>
            <dd>Abrir tutorial</dd>
            <dt><kbd>Alt</kbd> + <kbd>A</kbd></dt>
            <dd>Abrir accesibilidad</dd>
            <dt><kbd>ESC</kbd></dt>
            <dd>Cerrar modales</dd>
            <dt><kbd>Flechas</kbd> ‚Üê ‚Üí</dt>
            <dd>Navegar condiciones</dd>
          </dl>
        </section>
      </div>
    </div>

    <script>
      // Matter.js modules
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Body,
        Composite,
        Constraint,
        Events,
        Vector,
      } = Matter;

      // ========================================
      // SISTEMA DE ACCESIBILIDAD Y USABILIDAD
      // ========================================

      // Sistema de anuncios para lectores de pantalla
      const ScreenReaderAnnouncements = {
        liveRegion: null,

        init() {
          // Crear regi√≥n live
          this.liveRegion = document.createElement('div');
          this.liveRegion.setAttribute('role', 'status');
          this.liveRegion.setAttribute('aria-live', 'polite');
          this.liveRegion.setAttribute('aria-atomic', 'true');
          this.liveRegion.className = 'sr-only';
          this.liveRegion.id = 'sr-announcements';
          document.body.appendChild(this.liveRegion);
        },

        announce(message, priority = 'polite') {
          if (!this.liveRegion) this.init();
          
          this.liveRegion.setAttribute('aria-live', priority);
          this.liveRegion.textContent = message;
          
          // Limpiar despu√©s de un momento para permitir re-anuncios
          setTimeout(() => {
            this.liveRegion.textContent = '';
          }, 1000);
        },

        announceUrgent(message) {
          this.announce(message, 'assertive');
        }
      };

      // Navegaci√≥n por teclado
      const KeyboardNavigation = {
        init() {
          // Atajos globales
          document.addEventListener('keydown', (e) => {
            // Evitar conflictos con inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
              return;
            }

            // Modo de atajos activado con Alt
            if (e.altKey) {
              switch(e.key.toLowerCase()) {
                case 's': // Alt+S = Iniciar/Pausar simulaci√≥n
                  e.preventDefault();
                  document.getElementById('start-btn')?.click();
                  ScreenReaderAnnouncements.announce('Simulaci√≥n iniciada o pausada');
                  break;
                case 't': // Alt+T = Tratamiento
                  e.preventDefault();
                  const treatmentBtn = document.getElementById('treatment-btn');
                  if (!treatmentBtn.disabled) {
                    treatmentBtn.click();
                    ScreenReaderAnnouncements.announce('Tratamiento aplicado');
                  }
                  break;
                case 'r': // Alt+R = Reiniciar
                  e.preventDefault();
                  document.getElementById('reset-btn')?.click();
                  ScreenReaderAnnouncements.announce('Simulaci√≥n reiniciada');
                  break;
                case 'h': // Alt+H = Tutorial
                  e.preventDefault();
                  document.getElementById('tutorial-start-btn')?.click();
                  break;
                case 'a': // Alt+A = Accesibilidad
                  e.preventDefault();
                  AccessibilityPanel.toggle();
                  break;
                case '1': // Alt+1-8 = Seleccionar condici√≥n
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                  e.preventDefault();
                  const conditions = document.querySelectorAll('.condition-btn');
                  const index = parseInt(e.key) - 1;
                  if (conditions[index]) {
                    conditions[index].click();
                    ScreenReaderAnnouncements.announce(`Condici√≥n ${conditions[index].querySelector('.condition-name').textContent} seleccionada`);
                  }
                  break;
              }
            }

            // Navegaci√≥n sin Alt
            switch(e.key) {
              case 'Escape': // ESC = Cerrar modales
                this.closeModals();
                break;
              case 'ArrowLeft': // Flechas para navegar condiciones
              case 'ArrowRight':
                if (e.target.classList.contains('condition-btn')) {
                  this.navigateConditions(e.key === 'ArrowRight');
                  e.preventDefault();
                }
                break;
            }
          });

          // Mejorar focus visible
          this.setupFocusManagement();
        },

        navigateConditions(forward) {
          const buttons = Array.from(document.querySelectorAll('.condition-btn'));
          const currentIndex = buttons.findIndex(btn => btn === document.activeElement);
          let nextIndex = forward ? currentIndex + 1 : currentIndex - 1;
          
          if (nextIndex < 0) nextIndex = buttons.length - 1;
          if (nextIndex >= buttons.length) nextIndex = 0;
          
          buttons[nextIndex].focus();
          ScreenReaderAnnouncements.announce(`Condici√≥n ${buttons[nextIndex].querySelector('.condition-name').textContent}`);
        },

        setupFocusManagement() {
          // Ya est√° manejado en CSS con :focus-visible
        },

        closeModals() {
          const tutorialPanel = document.getElementById('tutorial-panel');
          if (tutorialPanel && tutorialPanel.getAttribute('aria-hidden') === 'false') {
            document.getElementById('tutorial-close')?.click();
          }
          const a11yPanel = document.getElementById('accessibility-panel');
          if (a11yPanel && a11yPanel.getAttribute('aria-hidden') === 'false') {
            AccessibilityPanel.close();
          }
          const feedback = document.getElementById('contextual-feedback');
          if (feedback && feedback.classList.contains('visible')) {
            document.getElementById('feedback-close')?.click();
          }
        }
      };

      // Panel de accesibilidad
      const AccessibilityPanel = {
        init() {
          const panel = document.getElementById('accessibility-panel');
          const overlay = document.getElementById('a11y-overlay');
          const closeBtn = document.getElementById('a11y-close');
          const openBtn = document.getElementById('accessibility-btn');

          if (openBtn) {
            openBtn.addEventListener('click', () => this.toggle());
          }

          if (closeBtn) {
            closeBtn.addEventListener('click', () => this.close());
          }

          if (overlay) {
            overlay.addEventListener('click', () => this.close());
          }

          // Cerrar con ESC
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && panel.getAttribute('aria-hidden') === 'false') {
              this.close();
            }
          });

          // Configurar controles
          this.setupFontSizeControl();
          this.setupHighContrast();
          this.setupReduceMotion();

          // Restaurar preferencias guardadas
          this.loadPreferences();
        },

        toggle() {
          const panel = document.getElementById('accessibility-panel');
          const overlay = document.getElementById('a11y-overlay');
          const openBtn = document.getElementById('accessibility-btn');
          
          const isHidden = panel.getAttribute('aria-hidden') === 'true';
          
          if (isHidden) {
            panel.setAttribute('aria-hidden', 'false');
            overlay.classList.add('active');
            overlay.setAttribute('aria-hidden', 'false');
            if (openBtn) openBtn.setAttribute('aria-expanded', 'true');
            
            // Focus en el primer elemento del panel
            const firstFocusable = panel.querySelector('button, input');
            if (firstFocusable) setTimeout(() => firstFocusable.focus(), 100);
            
            ScreenReaderAnnouncements.announce('Panel de accesibilidad abierto');
          } else {
            this.close();
          }
        },

        close() {
          const panel = document.getElementById('accessibility-panel');
          const overlay = document.getElementById('a11y-overlay');
          const openBtn = document.getElementById('accessibility-btn');
          
          panel.setAttribute('aria-hidden', 'true');
          overlay.classList.remove('active');
          overlay.setAttribute('aria-hidden', 'true');
          if (openBtn) openBtn.setAttribute('aria-expanded', 'false');
          
          // Devolver focus al bot√≥n que abri√≥ el panel
          if (openBtn) openBtn.focus();
        },

        setupFontSizeControl() {
          const buttons = document.querySelectorAll('.font-size-btn');
          buttons.forEach(btn => {
            btn.addEventListener('click', () => {
              const size = btn.dataset.size;
              
              // Remover clases anteriores
              document.body.className = document.body.className
                .replace(/font-size-\w+/g, '');
              
              // Agregar nueva clase
              document.body.classList.add(`font-size-${size}`);
              
              // Actualizar botones activos
              buttons.forEach(b => b.classList.toggle('active', b === btn));
              
              // Guardar preferencia
              localStorage.setItem('fontSize', size);
              
              ScreenReaderAnnouncements.announce(`Tama√±o de fuente: ${size}`);
              
              // Recalcular highlight del tutorial si est√° activo
              setTimeout(() => {
                if (typeof InteractiveTutorial !== 'undefined') {
                  InteractiveTutorial.recalculateHighlight();
                }
              }, 100);
            });
          });
        },

        setupHighContrast() {
          const checkbox = document.getElementById('high-contrast-checkbox');
          if (checkbox) {
            checkbox.addEventListener('change', (e) => {
              if (e.target.checked) {
                document.body.classList.add('high-contrast-mode');
                ScreenReaderAnnouncements.announce('Modo de alto contraste activado');
              } else {
                document.body.classList.remove('high-contrast-mode');
                ScreenReaderAnnouncements.announce('Modo de alto contraste desactivado');
              }
              localStorage.setItem('highContrast', e.target.checked);
            });
          }
        },

        setupReduceMotion() {
          const checkbox = document.getElementById('reduce-motion-checkbox');
          if (checkbox) {
            checkbox.addEventListener('change', (e) => {
              if (e.target.checked) {
                document.body.classList.add('reduced-motion');
                ScreenReaderAnnouncements.announce('Animaciones reducidas');
              } else {
                document.body.classList.remove('reduced-motion');
                ScreenReaderAnnouncements.announce('Animaciones normales');
              }
              localStorage.setItem('reduceMotion', e.target.checked);
            });
          }
        },

        loadPreferences() {
          // NO cargar preferencias guardadas - siempre empezar con valores por defecto
          // Esto asegura que cada vez que se recarga la p√°gina, todo vuelve a la normalidad
          
          // Establecer valores por defecto
          document.body.classList.add('font-size-medium');
          document.querySelector('.font-size-btn[data-size="medium"]')?.classList.add('active');
          
          // Asegurar que los checkboxes est√©n desmarcados
          const highContrastCheckbox = document.getElementById('high-contrast-checkbox');
          const reduceMotionCheckbox = document.getElementById('reduce-motion-checkbox');
          if (highContrastCheckbox) highContrastCheckbox.checked = false;
          if (reduceMotionCheckbox) reduceMotionCheckbox.checked = false;
          
          // Limpiar localStorage para empezar limpio (opcional - comentado para permitir persistencia si se desea)
          // localStorage.removeItem('fontSize');
          // localStorage.removeItem('highContrast');
          // localStorage.removeItem('reduceMotion');
        }
      };

      // Generar descripci√≥n textual de la simulaci√≥n
      function generateSimulationDescription() {
        const stuckCount = state.stuckPlatelets.filter(p => !p.isAnchor).length;
        const fibrinCount = state.fibrinConstraints.length;
        const clotPercent = Math.round(state.clotPercentage);
        const bloodLossEl = document.getElementById('blood-loss');
        const bloodLoss = bloodLossEl ? parseInt(bloodLossEl.textContent) || 0 : 0;
        
        let description = `Simulaci√≥n de coagulaci√≥n sangu√≠nea. `;
        description += `Condici√≥n: ${CONFIG.conditions[state.condition]?.name || 'Normal'}. `;
        description += `${stuckCount} plaquetas adheridas. `;
        description += `${fibrinCount} conexiones de fibrina formadas. `;
        description += `Cierre de herida: ${clotPercent} por ciento. `;
        description += `P√©rdida sangu√≠nea: ${bloodLoss} unidades. `;
        
        if (state.hemostasisAchieved) {
          description += 'Hemostasia lograda. ';
        } else if (state.treatmentApplied) {
          description += 'Tratamiento aplicado. ';
        }
        
        if (state.simulationRunning) {
          description += 'Simulaci√≥n en curso.';
        } else {
          description += 'Simulaci√≥n pausada.';
        }
        
        return description;
      }

      // Actualizar descripci√≥n peri√≥dicamente
      function updateSimulationDescription() {
        const descEl = document.getElementById('canvas-description');
        if (descEl && state) {
          descEl.textContent = generateSimulationDescription();
        }
      }

      // Actualizar estados ARIA de condiciones
      function updateConditionARIA() {
        document.querySelectorAll('.condition-btn').forEach(btn => {
          const isActive = btn.classList.contains('active');
          btn.setAttribute('aria-checked', isActive);
        });
      }

      // ========================================
      // SISTEMA DE FEEDBACK CONTEXTUAL INTELIGENTE
      // ========================================

      const ContextualFeedback = {
        shownFeedbacks: new Set(),
        isShowing: false,
        autoHideTimeout: null,

        // Definici√≥n de todos los feedbacks contextuales
        feedbacks: {
          simulationStart: {
            id: "simulationStart",
            icon: "üé¨",
            title: "Simulaci√≥n Iniciada",
            message:
              "Observa c√≥mo las c√©lulas sangu√≠neas fluyen por el vaso. Las plaquetas (grises) son las responsables de formar el co√°gulo.",
            trigger: (state) =>
              state.simulationRunning &&
              state.startTime &&
              Date.now() - state.startTime < 2000,
            showOnce: true,
            priority: 10,
            autoHide: 5000,
          },

          firstPlateletAdhesion: {
            id: "firstPlateletAdhesion",
            icon: "üî¥",
            title: "Primera Adhesi√≥n",
            message:
              "Las plaquetas se adhieren al col√°geno mediante el factor von Willebrand (vWF).",
            trigger: (state) => {
              // Contar solo plaquetas que NO son ancla (excluir las invisibles de los lados)
              const realPlatelets = state.stuckPlatelets.filter(
                (p) => !p.isAnchor
              );
              return realPlatelets.length >= 1 && realPlatelets.length <= 3;
            },
            showOnce: true,
            priority: 9,
            autoHide: 5000,
          },

          plateletAggregation: {
            id: "plateletAggregation",
            icon: "üîó",
            title: "Agregaci√≥n Plaquetaria",
            message: "Las plaquetas se unen formando un tap√≥n primario.",
            trigger: (state) =>
              state.stuckPlatelets.length >= 8 &&
              state.stuckPlatelets.length <= 12,
            showOnce: true,
            priority: 8,
            autoHide: 5000,
          },

          fibrinFormationStart: {
            id: "fibrinFormationStart",
            icon: "üï∏Ô∏è",
            title: "Formaci√≥n de Fibrina",
            message:
              "La cascada de coagulaci√≥n genera trombina, que convierte fibrin√≥geno en fibrina.",
            trigger: (state) =>
              state.fibrinConstraints.length >= 5 &&
              state.fibrinConstraints.length <= 10,
            showOnce: true,
            priority: 7,
            autoHide: 5000,
          },

          hemostasisAchieved: {
            id: "hemostasisAchieved",
            icon: "‚úÖ",
            title: "Hemostasia Lograda",
            message: "El co√°gulo ha sellado completamente la herida.",
            trigger: (state) =>
              state.hemostasisAchieved && !state.treatmentApplied,
            showOnce: true,
            priority: 10,
            autoHide: 5000,
          },

          hemophiliaSlowFibrin: {
            id: "hemophiliaSlowFibrin",
            icon: "‚ö†Ô∏è",
            title: "Fibrina Lenta",
            message:
              "En hemofilia, el d√©ficit de Factor VIII/IX causa formaci√≥n lenta de fibrina.",
            trigger: (state) =>
              (state.condition === "hemophilia" ||
                state.condition === "hemophiliaSevere") &&
              state.stuckPlatelets.length > 10 &&
              state.fibrinConstraints.length < 5 &&
              state.simulationRunning &&
              state.startTime &&
              Date.now() - state.startTime > 8000,
            showOnce: true,
            priority: 8,
            autoHide: 5000,
          },

          vwdAdhesionProblem: {
            id: "vwdAdhesionProblem",
            icon: "‚ö†Ô∏è",
            title: "Adhesi√≥n Dificultosa",
            message:
              "En von Willebrand, el d√©ficit de vWF dificulta la adhesi√≥n plaquetaria.",
            trigger: (state) =>
              state.condition === "vwd" &&
              state.totalPlateletsSpawned > 30 &&
              state.stuckPlatelets.length < 5,
            showOnce: true,
            priority: 8,
            autoHide: 5000,
          },

          thrombocytopeniaLowPlatelets: {
            id: "thrombocytopeniaLowPlatelets",
            icon: "‚ö†Ô∏è",
            title: "Pocas Plaquetas",
            message:
              "En trombocitopenia hay pocas plaquetas disponibles para formar el co√°gulo.",
            trigger: (state) =>
              state.condition === "thrombocytopenia" &&
              state.simulationRunning &&
              state.startTime &&
              Date.now() - state.startTime > 5000 &&
              state.startTime &&
              Date.now() - state.startTime < 7000,
            showOnce: true,
            priority: 8,
            autoHide: 5000,
          },

          treatmentApplied: {
            id: "treatmentApplied",
            icon: "üíâ",
            title: "Tratamiento",
            message: "El tratamiento est√° mejorando la funci√≥n de coagulaci√≥n.",
            trigger: (state) =>
              state.treatmentApplied && state.simulationRunning,
            showOnce: true,
            priority: 9,
            autoHide: 5000,
          },

          treatmentSuccess: {
            id: "treatmentSuccess",
            icon: "üéØ",
            title: "Tratamiento Efectivo",
            message: "El tratamiento ha permitido lograr la hemostasia.",
            trigger: (state) =>
              state.hemostasisAchieved && state.treatmentApplied,
            showOnce: true,
            priority: 10,
            autoHide: 5000,
          },

          bloodLossWarning: {
            id: "bloodLossWarning",
            icon: "ü©∏",
            title: "P√©rdida Sangu√≠nea",
            message:
              "La p√©rdida sangu√≠nea est√° aumentando. Considera administrar tratamiento.",
            trigger: (state) =>
              state.bloodLoss > 50 &&
              !state.treatmentApplied &&
              !state.hemostasisAchieved,
            showOnce: true,
            priority: 7,
            autoHide: 5000,
          },
        },

        // Inicializar el sistema
        init() {
          const closeBtn = document.getElementById("feedback-close");
          if (closeBtn) {
            closeBtn.addEventListener("click", () => this.hide());
          }
        },

        // Verificar y mostrar feedbacks relevantes
        check(state) {
          // Buscar feedbacks que cumplan condiciones
          for (const key in this.feedbacks) {
            const feedback = this.feedbacks[key];

            // Skip si ya se mostr√≥ y es showOnce
            if (feedback.showOnce && this.shownFeedbacks.has(feedback.id)) {
              continue;
            }

            // Verificar trigger
            try {
              if (feedback.trigger(state)) {
                // Si hay un feedback mostr√°ndose, ocultarlo inmediatamente
                if (this.isShowing) {
                  this.hide();
                }
                this.show(feedback);
                break; // Solo mostrar uno a la vez
              }
            } catch (e) {
              // Ignorar errores en triggers
            }
          }
        },

        // Mostrar feedback
        show(feedback) {
          // NO mostrar en el simulador, solo agregar al tablero acumulado
          // Marcar como mostrado
          this.shownFeedbacks.add(feedback.id);

          // Agregar al tablero de feedback acumulado
          this.addToFeedbackBoard(feedback);

          // Marcar que estamos mostrando (para evitar mostrar m√∫ltiples a la vez)
          this.isShowing = true;
          
          // Resetear el estado despu√©s de un breve delay para permitir nuevos feedbacks
          setTimeout(() => {
            this.isShowing = false;
          }, 100);
        },

        // Agregar feedback al tablero acumulado
        addToFeedbackBoard(feedback) {
          const feedbackBoard = document.getElementById("feedback-board");
          if (!feedbackBoard) return;

          // Remover mensaje de vac√≠o si existe
          const emptyMsg = feedbackBoard.querySelector(".feedback-board-empty");
          if (emptyMsg) {
            emptyMsg.remove();
          }

          // Calcular tiempo transcurrido desde el inicio de la simulaci√≥n
          let timeText = "0:00";
          if (state.startTime) {
            const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }

          // Crear elemento de feedback
          const feedbackItem = document.createElement("div");
          feedbackItem.className = "feedback-board-item";
          feedbackItem.innerHTML = `
            <div class="feedback-board-item-header">
              <span class="feedback-board-icon">${feedback.icon}</span>
              <span class="feedback-board-title">${feedback.title}</span>
              <span class="feedback-board-time">${timeText}</span>
            </div>
            <div class="feedback-board-item-content">${feedback.message}</div>
          `;

          // Agregar al inicio del tablero (m√°s reciente arriba)
          feedbackBoard.insertBefore(feedbackItem, feedbackBoard.firstChild);
        },

        // Ocultar feedback
        hide() {
          const container = document.getElementById("contextual-feedback");
          if (container) {
            container.classList.remove("visible", "entering");
          }

          this.isShowing = false;

          if (this.autoHideTimeout) {
            clearTimeout(this.autoHideTimeout);
            this.autoHideTimeout = null;
          }
        },

        // Resetear feedbacks mostrados
        reset() {
          this.shownFeedbacks.clear();
          this.hide();
          
          // Limpiar tablero de feedback
          const feedbackBoard = document.getElementById("feedback-board");
          if (feedbackBoard) {
            feedbackBoard.innerHTML = '<div class="feedback-board-empty">Los mensajes de feedback aparecer√°n aqu√≠ con su tiempo de aparici√≥n</div>';
          }
        },
      };

      // ========================================
      // SISTEMA DE TUTORIAL INTERACTIVO
      // ========================================

      const InteractiveTutorial = {
        currentStep: 0,
        isActive: false,
        currentHighlightSelector: null, // Guardar el selector del highlight actual
        steps: [
          {
            title: "Bienvenido al Simulador",
            content: `
                        <h3>¬°Bienvenido!</h3>
                        <p>Este tutorial te guiar√° paso a paso para usar el simulador de hemostasia.</p>
                        <p><strong>Objetivo:</strong> Aprender c√≥mo funciona el proceso de coagulaci√≥n sangu√≠nea mediante simulaci√≥n interactiva.</p>
                        <p>Haz clic en "Siguiente" para comenzar.</p>
                    `,
            highlight: null,
            panelPosition: "right",
          },
          {
            title: "Selecci√≥n de Condici√≥n",
            content: `
                        <h3>Condiciones Cl√≠nicas</h3>
                        <p>El simulador permite experimentar con diferentes condiciones:</p>
                        <ul>
                            <li><strong>Normal:</strong> Coagulaci√≥n fisiol√≥gica normal</li>
                            <li><strong>Hemofilia:</strong> D√©ficit de Factor VIII/IX</li>
                            <li><strong>Von Willebrand:</strong> D√©ficit de factor vWF</li>
                            <li><strong>Trombocitopenia:</strong> Bajo recuento de plaquetas</li>
                        </ul>
                        <p>Selecciona una condici√≥n para ver c√≥mo afecta al proceso de coagulaci√≥n.</p>
                    `,
            highlight: ".conditions-sidebar .panel-card",
            panelPosition: "right",
            action: () => {
              // Resaltar el primer bot√≥n de condici√≥n
              const firstBtn = document.querySelector(
                '.condition-btn[data-condition="normal"]'
              );
              if (firstBtn) {
                firstBtn.style.transform = "scale(1.05)";
                firstBtn.style.transition = "transform 0.3s";
              }
            },
          },
          {
            title: "√Årea de Simulaci√≥n",
            content: `
                        <h3>Visualizaci√≥n de la Simulaci√≥n</h3>
                        <p>En esta √°rea ver√°s:</p>
                        <ul>
                            <li><strong>Plaquetas (grises):</strong> C√©lulas que forman el co√°gulo</li>
                            <li><strong>Gl√≥bulos rojos:</strong> Transportan ox√≠geno</li>
                            <li><strong>Gl√≥bulos blancos:</strong> Participan en la respuesta inmune</li>
                            <li><strong>Red de fibrina:</strong> Refuerza el tap√≥n plaquetario</li>
                        </ul>
                        <p>Observa c√≥mo las c√©lulas fluyen por el vaso sangu√≠neo.</p>
                    `,
            highlight: ".viewer-container",
            panelPosition: "right",
          },
          {
            title: "Controles de Simulaci√≥n",
            content: `
                        <h3>Controles Principales</h3>
                        <p>Usa estos botones para controlar la simulaci√≥n:</p>
                        <ul>
                            <li><strong>‚ñ∂ Iniciar:</strong> Comienza la simulaci√≥n</li>
                            <li><strong>üíâ Tratamiento:</strong> Administra tratamiento (si es necesario)</li>
                            <li><strong>‚Üª Reiniciar:</strong> Vuelve a empezar</li>
                        </ul>
                        <p>El wizard te gu√≠a a trav√©s de los pasos necesarios.</p>
                    `,
            highlight: ".simulation-controls-row",
            panelPosition: "bottom",
          },
          {
            title: "M√©tricas en Tiempo Real",
            content: `
                        <h3>M√©tricas de la Simulaci√≥n</h3>
                        <p>Observa estas m√©tricas mientras corre la simulaci√≥n:</p>
                        <ul>
                            <li><strong>P√©rdida Sangu√≠nea:</strong> Cantidad de sangre perdida</li>
                            <li><strong>Cierre de Herida:</strong> Porcentaje de cierre del co√°gulo</li>
                            <li><strong>Tiempo hasta cierre:</strong> Cu√°nto tarda en cerrarse</li>
                            <li><strong>Velocidad de fibrina:</strong> Tasa de formaci√≥n</li>
                        </ul>
                        <p>Estas m√©tricas te ayudan a entender el progreso de la hemostasia.</p>
                    `,
            highlight: ".metrics-section",
            panelPosition: "left",
          },
          {
            title: "Gr√°ficos en Tiempo Real",
            content: `
                        <h3>Visualizaci√≥n de Datos</h3>
                        <p>Los gr√°ficos muestran:</p>
                        <ul>
                            <li><strong>Cierre de herida:</strong> Progreso del co√°gulo</li>
                            <li><strong>P√©rdida sangu√≠nea:</strong> Sangrado acumulado</li>
                            <li><strong>Conexiones de fibrina:</strong> Formaci√≥n de la red</li>
                        </ul>
                        <p>Estos gr√°ficos se actualizan en tiempo real durante la simulaci√≥n.</p>
                    `,
            highlight: ".charts-container",
            panelPosition: "left",
          },
          {
            title: "Leyenda de Elementos",
            content: `
                        <h3>Elementos de la Simulaci√≥n</h3>
                        <p>La leyenda explica cada elemento:</p>
                        <ul>
                            <li><strong>Plaquetas:</strong> Forman el tap√≥n inicial</li>
                            <li><strong>Factor von Willebrand:</strong> Media la adhesi√≥n</li>
                            <li><strong>Fibrina:</strong> Refuerza el co√°gulo</li>
                        </ul>
                        <p>Pasa el mouse sobre cada elemento para m√°s informaci√≥n.</p>
                    `,
            highlight: ".legend",
            panelPosition: "top",
          },
          {
            title: "Panel Educativo",
            content: `
                        <h3>Informaci√≥n Adicional</h3>
                        <p>El panel educativo contiene:</p>
                        <ul>
                            <li>Informaci√≥n sobre la condici√≥n actual</li>
                            <li>Explicaci√≥n de la cascada de coagulaci√≥n</li>
                            <li>Proceso completo de hemostasia</li>
                        </ul>
                        <p>Expande el panel para aprender m√°s sobre los conceptos cient√≠ficos.</p>
                        <p><strong>¬°Ya est√°s listo para usar el simulador!</strong></p>
                    `,
            highlight: ".educational-info-column .panel-card",
            panelPosition: "top",
          },
        ],

        init() {
          // Asegurar que el tutorial est√© cerrado al inicio
          this.close();
          this.currentHighlightSelector = null;

          const startBtn = document.getElementById("tutorial-start-btn");
          const closeBtn = document.getElementById("tutorial-close");
          const nextBtn = document.getElementById("tutorial-next");
          const prevBtn = document.getElementById("tutorial-prev");

          if (startBtn) {
            startBtn.addEventListener("click", () => this.start());
          }

          if (closeBtn) {
            closeBtn.addEventListener("click", () => this.close());
          }

          if (nextBtn) {
            nextBtn.addEventListener("click", () => this.next());
          }

          if (prevBtn) {
            prevBtn.addEventListener("click", () => this.prev());
          }

          // Actualizar total de pasos
          const totalStepsEl = document.getElementById("tutorial-total-steps");
          if (totalStepsEl) {
            totalStepsEl.textContent = this.steps.length;
          }

          // Recalcular highlight cuando cambia el tama√±o de la ventana
          let resizeTimeout;
          window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              if (this.isActive && this.currentHighlightSelector) {
                this.recalculateHighlight();
              }
            }, 150);
          });

          // Observar cambios en las clases del body para detectar cambios de tama√±o de fuente
          const bodyObserver = new MutationObserver(() => {
            if (this.isActive && this.currentHighlightSelector) {
              // Esperar un momento para que el DOM se actualice
              setTimeout(() => {
                this.recalculateHighlight();
              }, 100);
            }
          });

          bodyObserver.observe(document.body, {
            attributes: true,
            attributeFilter: ['class']
          });
        },

        start() {
          this.isActive = true;
          this.currentStep = -1; // Reset para que la primera transici√≥n funcione

          // Inicializar elementos visuales
          const overlay = document.getElementById("tutorial-overlay");
          const panel = document.getElementById("tutorial-panel");
          const textEl = document.getElementById("tutorial-text");

          if (overlay) {
            overlay.style.display = "block";
            overlay.style.opacity = "0";
            setTimeout(() => {
              overlay.style.transition = "opacity 0.4s ease-out";
              overlay.style.opacity = "1";
            }, 10);
          }
          if (panel) {
            panel.style.display = "block";
            panel.style.opacity = "0";
          }
          if (textEl) {
            textEl.style.opacity = "1";
          }

          this.showStep(0);
        },

        showStep(stepIndex) {
          if (stepIndex < 0 || stepIndex >= this.steps.length) {
            this.close();
            return;
          }

          const step = this.steps[stepIndex];
          const textEl = document.getElementById("tutorial-text");
          const panel = document.getElementById("tutorial-panel");

          // Si ya hay contenido, hacer fade-out primero
          if (
            textEl &&
            textEl.innerHTML.trim() !== "Contenido del tutorial" &&
            this.currentStep !== stepIndex
          ) {
            textEl.style.opacity = "0";
            textEl.style.transition = "opacity 0.2s ease-out";

            setTimeout(() => {
              this.updateStepContent(stepIndex, step);
            }, 200);
          } else {
            this.updateStepContent(stepIndex, step);
          }
        },

        updateStepContent(stepIndex, step) {
          this.currentStep = stepIndex;

          // Actualizar contenido
          const titleEl = document.getElementById("tutorial-title-text");
          const textEl = document.getElementById("tutorial-text");
          const currentStepEl = document.getElementById(
            "tutorial-current-step"
          );
          const panel = document.getElementById("tutorial-panel");
          const overlay = document.getElementById("tutorial-overlay");
          const highlight = document.getElementById("tutorial-highlight");

          if (titleEl) titleEl.textContent = step.title;
          if (textEl) {
            textEl.innerHTML = step.content;
            // Fade-in del nuevo contenido
            textEl.style.opacity = "0";
            setTimeout(() => {
              textEl.style.transition = "opacity 0.3s ease-in";
              textEl.style.opacity = "1";
            }, 10);
          }
          if (currentStepEl) currentStepEl.textContent = stepIndex + 1;

          // Actualizar posici√≥n del panel sin desaparecerlo
          if (panel) {
            const position = step.panelPosition || "right";
            const currentClasses = panel.className.split(" ");
            const currentPosition =
              currentClasses.find((cls) =>
                ["left", "right", "top", "bottom"].includes(cls)
              ) || null;
            const wasHidden =
              panel.style.display === "none" ||
              !panel.classList.contains("active");

            // Si el panel estaba oculto o es el primer paso
            if (wasHidden || (!currentPosition && this.currentStep === 0)) {
              // Primera vez o panel oculto: establecer posici√≥n y hacer fade-in
              panel.className = `tutorial-panel ${position} active`;
              panel.style.display = "block";
              panel.style.opacity = "0";
              // Asegurar que la posici√≥n se aplique antes del fade-in
              void panel.offsetWidth;
              setTimeout(() => {
                panel.style.transition = "opacity 0.3s ease-in";
                panel.style.opacity = "1";
              }, 10);
            } else if (currentPosition && currentPosition !== position) {
              // Cambio de posici√≥n: fade-out, cambiar posici√≥n, fade-in
              panel.style.transition = "opacity 0.15s ease-out";
              panel.style.opacity = "0";

              setTimeout(() => {
                panel.className = `tutorial-panel ${position} active`;
                // Forzar reflow para aplicar nueva posici√≥n antes del fade-in
                void panel.offsetWidth;
                // Fade in con la nueva posici√≥n
                panel.style.transition = "opacity 0.3s ease-in";
                panel.style.opacity = "1";
              }, 150);
            } else {
              // Si no cambia la posici√≥n, solo asegurar que est√© visible
              panel.style.display = "block";
              panel.style.opacity = "1";
              if (!currentPosition) {
                panel.className = `tutorial-panel ${position} active`;
              } else {
                panel.classList.add("active");
              }
            }
          }

          // Mostrar overlay
          if (overlay) {
            overlay.style.display = "block";
            overlay.classList.add("active");
          }

          // Guardar el selector del highlight actual
          this.currentHighlightSelector = step.highlight || null;
          
          // Mostrar highlight si existe (con delay para suavizar transici√≥n)
          if (step.highlight && highlight) {
            highlight.style.opacity = "0";
            setTimeout(() => {
              this.showHighlight(step.highlight);
              highlight.style.transition = "opacity 0.3s ease-in";
              highlight.style.opacity = "1";
            }, 150);
          } else if (highlight) {
            highlight.style.opacity = "0";
            setTimeout(() => {
              highlight.style.display = "none";
            }, 200);
          }

          // Ejecutar acci√≥n si existe
          if (step.action) {
            step.action();
          }

          // Actualizar botones y progreso
          this.updateButtons();
          this.updateStepDots();
          this.updateProgressBar();
        },

        updateProgressBar() {
          const progressFill = document.getElementById(
            "tutorial-progress-fill"
          );
          if (progressFill) {
            const progress = ((this.currentStep + 1) / this.steps.length) * 100;
            progressFill.style.width = progress + "%";
          }
        },

        showHighlight(selector, skipScroll = false) {
          const highlight = document.getElementById("tutorial-highlight");
          const element = document.querySelector(selector);

          if (!highlight || !element) {
            if (highlight) {
              highlight.style.display = "none";
              highlight.style.opacity = "0";
            }
            return;
          }

          // Guardar el selector actual
          this.currentHighlightSelector = selector;

          // Scroll al elemento si est√° fuera de la vista (solo si no se omite)
          if (!skipScroll) {
            element.scrollIntoView({
              behavior: "smooth",
              block: "center",
              inline: "nearest",
            });
          }

          // Funci√≥n para actualizar posici√≥n y tama√±o
          const updateHighlight = () => {
            const rect = element.getBoundingClientRect();
            highlight.style.display = "block";
            highlight.style.left = rect.left - 4 + "px";
            highlight.style.top = rect.top - 4 + "px";
            highlight.style.width = rect.width + 8 + "px";
            highlight.style.height = rect.height + 8 + "px";

            // Ajustar posici√≥n del panel si es necesario
            const panel = document.getElementById("tutorial-panel");
            if (panel) {
              const step = this.steps[this.currentStep];
              const panelWidth = 400;

              // Asegurar que el panel no se superponga con el highlight
              if (
                step.panelPosition === "right" &&
                rect.right + panelWidth > window.innerWidth
              ) {
                panel.classList.remove("right");
                panel.classList.add("left");
              } else if (
                step.panelPosition === "left" &&
                rect.left - panelWidth < 0
              ) {
                panel.classList.remove("left");
                panel.classList.add("right");
              }
            }
          };

          // Esperar un momento para que el scroll termine (solo si no se omite)
          if (!skipScroll) {
            setTimeout(updateHighlight, 300);
          } else {
            // Si se omite el scroll, actualizar inmediatamente pero con un peque√±o delay para asegurar que el DOM se haya actualizado
            setTimeout(updateHighlight, 50);
          }
        },

        // Recalcular el highlight actual (√∫til cuando cambia el tama√±o de fuente o ventana)
        recalculateHighlight() {
          if (this.currentHighlightSelector && this.isActive) {
            this.showHighlight(this.currentHighlightSelector, true);
          }
        },

        updateButtons() {
          const nextBtn = document.getElementById("tutorial-next");
          const prevBtn = document.getElementById("tutorial-prev");

          if (nextBtn) {
            if (this.currentStep === this.steps.length - 1) {
              nextBtn.textContent = "Finalizar";
            } else {
              nextBtn.textContent = "Siguiente";
            }
          }

          if (prevBtn) {
            prevBtn.disabled = this.currentStep === 0;
          }
        },

        updateStepDots() {
          const dotsContainer = document.getElementById("tutorial-step-dots");
          if (!dotsContainer) return;

          dotsContainer.innerHTML = "";

          for (let i = 0; i < this.steps.length; i++) {
            const dot = document.createElement("div");
            dot.className = "tutorial-step-dot";

            if (i < this.currentStep) {
              dot.classList.add("completed");
            } else if (i === this.currentStep) {
              dot.classList.add("active");
            }

            dotsContainer.appendChild(dot);
          }
        },

        next() {
          if (this.currentStep < this.steps.length - 1) {
            this.showStep(this.currentStep + 1);
          } else {
            this.close();
          }
        },

        prev() {
          if (this.currentStep > 0) {
            this.showStep(this.currentStep - 1);
          }
        },

        close() {
          this.isActive = false;
          this.currentStep = 0;
          this.currentHighlightSelector = null;
          const panel = document.getElementById("tutorial-panel");
          const overlay = document.getElementById("tutorial-overlay");
          const highlight = document.getElementById("tutorial-highlight");
          const textEl = document.getElementById("tutorial-text");
          const progressFill = document.getElementById(
            "tutorial-progress-fill"
          );

          if (panel) {
            panel.classList.remove("active");
            panel.style.display = "none";
          }
          if (overlay) {
            overlay.classList.remove("active");
            overlay.style.display = "none";
            overlay.style.opacity = "0";
          }
          if (highlight) {
            highlight.style.display = "none";
            highlight.style.opacity = "0";
          }
          if (textEl) {
            textEl.style.opacity = "1";
            textEl.style.transition = "";
          }
          if (progressFill) {
            progressFill.style.width = "0%";
          }

          // Limpiar efectos de acci√≥n
          document.querySelectorAll(".condition-btn").forEach((btn) => {
            btn.style.transform = "";
            btn.style.transition = "";
          });
        },
      };

      // Simulation Configuration
      const CONFIG = {
        canvas: {
          width: 1300,
          height: 300,
        },
        wound: {
          x: 550, // Center
          width: 300,
          height: 20,
        },
        wall: {
          thickness: 30, // Increased thickness to prevent particles from passing through
          color: "#FDA4AF",
        },
        physics: {
          flowForce: 0.000175, // Base: promedio entre 0.00015 y 0.00020
          flowForceMin: 0.00008, // M√≠nimo muy reducido para pulso extremadamente dram√°tico
          flowForceMax: 0.00045, // M√°ximo muy aumentado para hacer el pulso extremadamente visible (5.6x diferencia)
          suctionForce: -0.00050, // Vertical hacia arriba (negativo) - aumentado m√°s
          suctionRadius: 180,
        },
        particles: {
          maxCount: 150, // Reduced for better performance
          spawnRate: 3, // Increased spawn rate for more particles
          plateletRatio: 0.30, // 30% para efectos did√°cticos
          rbcRatio: 0.65, // 65% - mayor√≠a en sangre real
          wbcRatio: 0.05, // 5%
        },
        fibrin: {
          maxConnections: 200, // Limit fibrin connections to prevent performance issues
          maxConnectionsPerPlatelet: 8, // Limit connections per platelet
        },
        stuckPlatelets: {
          maxCount: 80, // L√≠mite m√°ximo de plaquetas pegadas para mantener rendimiento
        },
        conditions: {
          normal: {
            name: "Normal",
            description:
              "Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesi√≥n: S√ç
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregaci√≥n: S√ç
            fibrinFormationRate: 1.0,
            fibrinStability: 1.0, // Fibrina FUERTE (stiffness: 0.9) - Resultado: Tap√≥n s√≥lido verde
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            bleedingTime: 3,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676", // Verde s√≥lido
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La coagulaci√≥n normal es un proceso fisiol√≥gico complejo que permite detener el sangrado tras una lesi√≥n vascular. Todos los componentes del sistema hemost√°tico funcionan de manera coordinada.",
              pathophysiology: "En condiciones normales, la hemostasia primaria (adhesi√≥n y agregaci√≥n plaquetaria) y secundaria (cascada de coagulaci√≥n) trabajan en sinergia. Las plaquetas se adhieren al col√°geno expuesto mediante el factor von Willebrand (vWF), se agregan entre s√≠, y la cascada de coagulaci√≥n genera trombina que convierte el fibrin√≥geno en fibrina, formando una red estable que refuerza el tap√≥n plaquetario.",
              symptoms: "No hay s√≠ntomas anormales. El tiempo de sangrado es normal (2-4 minutos) y la formaci√≥n del co√°gulo es eficiente y estable.",
              causes: "Estado fisiol√≥gico normal. No hay d√©ficit ni alteraci√≥n de factores de coagulaci√≥n.",
              treatment: "No requiere tratamiento. El sistema hemost√°tico funciona correctamente.",
              prognosis: "Excelente. La coagulaci√≥n ocurre de manera eficiente, minimizando la p√©rdida sangu√≠nea y permitiendo la cicatrizaci√≥n adecuada.",
              clinicalNotes: "Este es el estado de referencia para comparar otras condiciones. Los tiempos normales de coagulaci√≥n son: tiempo de sangrado 2-4 min, tiempo de protrombina (PT) 11-13 seg, tiempo de tromboplastina parcial (PTT) 25-35 seg.",
              affectedFactors: "Ninguno - todos los factores funcionan normalmente",
              cascadePathway: "Ambas v√≠as (intr√≠nseca y extr√≠nseca) funcionan correctamente, convergiendo en la v√≠a com√∫n que genera trombina eficientemente.",
            },
          },
          hemophilia: {
            name: "Hemofilia A/B",
            description:
              "D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesi√≥n: S√ç (Se forma el tap√≥n blanco)
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregaci√≥n: S√ç
            fibrinFormationRate: 0.1, // Probabilidad 10% - MUY D√âBIL o INEXISTENTE
            fibrinStability: 0.001, // MUY D√âBIL (stiffness: 0.001) - La fuerza de succi√≥n lo rompe
            fibrinDecayRate: 0.05, // Decaimiento r√°pido
            fibrinFormationDelay: 1500,
            bleedingTime: 30,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF6B6B", // Rojo para indicar d√©bil
              fibrinGlow: false,
              fibrinOpacity: 0.3, // Muy transparente
            },
            educational: {
              overview: "La hemofilia es un trastorno hemorr√°gico hereditario causado por d√©ficit de Factor VIII (Hemofilia A) o Factor IX (Hemofilia B). Es la coagulopat√≠a hereditaria m√°s com√∫n, afectando principalmente a varones.",
              pathophysiology: "El d√©ficit de Factor VIII o IX interrumpe la v√≠a intr√≠nseca de la cascada de coagulaci√≥n. Las plaquetas se adhieren normalmente formando el tap√≥n primario, pero la generaci√≥n de trombina est√° severamente reducida. Sin suficiente trombina, el fibrin√≥geno no se convierte eficientemente en fibrina, resultando en co√°gulos d√©biles e inestables que se desintegran f√°cilmente.",
              symptoms: "Sangrado prolongado tras lesiones menores, hemartrosis (sangrado en articulaciones), hematomas espont√°neos, sangrado post-quir√∫rgico severo. El tiempo de sangrado puede ser normal, pero el tiempo de tromboplastina parcial (PTT) est√° prolongado.",
              causes: "Mutaciones gen√©ticas en el cromosoma X que codifican para Factor VIII (Hemofilia A) o Factor IX (Hemofilia B). Patr√≥n de herencia ligado al cromosoma X (afecta principalmente varones).",
              treatment: "Tratamiento de reemplazo con concentrados de Factor VIII o IX seg√∫n el tipo. En casos leves puede usarse desmopresina (DDAVP) para Hemofilia A. Tratamiento profil√°ctico en casos severos. Tratamiento de episodios hemorr√°gicos agudos.",
              prognosis: "Con tratamiento adecuado, los pacientes pueden llevar una vida relativamente normal. Sin tratamiento, el sangrado recurrente puede causar artropat√≠a hemof√≠lica, anemia cr√≥nica y complicaciones graves.",
              clinicalNotes: "Hemofilia A (d√©ficit Factor VIII) es m√°s com√∫n que Hemofilia B (d√©ficit Factor IX). La severidad depende del nivel de factor: severa (<1%), moderada (1-5%), leve (5-40%). El PTT est√° prolongado mientras que el PT es normal.",
              affectedFactors: "Factor VIII (Hemofilia A) o Factor IX (Hemofilia B) - componentes cr√≠ticos de la v√≠a intr√≠nseca",
              cascadePathway: "V√≠a intr√≠nseca defectuosa. El Factor VIII act√∫a como cofactor del Factor IX activado. Sin estos factores, la generaci√≥n de trombina es insuficiente.",
            },
          },
          vwd: {
            name: "Enfermedad de Von Willebrand",
            description:
              "D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida",
            plateletRatio: 0.30, // Spawn normal
            canStick: false, // Adhesi√≥n: NO - Fallo en el "pegamento" (vWF)
            canFormFibrin: true,
            stickProbability: 0.0, // No pueden adherirse
            plateletFunction: 0.4,
            adhesionStrength: 0.0,
            aggregationRate: 0.0, // Sin agregaci√≥n porque no hay adhesi√≥n
            fibrinFormationRate: 0.0, // No se forma porque no hay adhesi√≥n
            fibrinStability: 0.0,
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            plateletBounceFactor: 0.9, // Rebote alto (restitution: 0.9) - rebotan contra la pared
            adhesionRetryChance: 0.0,
            bleedingTime: 15,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676",
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La enfermedad de Von Willebrand (EvW) es el trastorno hemorr√°gico hereditario m√°s com√∫n, afectando aproximadamente al 1% de la poblaci√≥n. Se caracteriza por d√©ficit o disfunci√≥n del factor von Willebrand (vWF).",
              pathophysiology: "El factor von Willebrand act√∫a como 'pegamento' que permite que las plaquetas se adhieran al col√°geno expuesto en la pared vascular lesionada. Tambi√©n transporta y estabiliza el Factor VIII en plasma. Sin vWF funcional, las plaquetas no pueden adherirse al sitio de la lesi√≥n, impidiendo la formaci√≥n del tap√≥n primario y, por tanto, la iniciaci√≥n de la cascada de coagulaci√≥n.",
              symptoms: "Sangrado mucocut√°neo (epistaxis, sangrado gingival, menorragia), sangrado prolongado tras cirug√≠a menor, hematomas f√°ciles, tiempo de sangrado prolongado. Los s√≠ntomas suelen ser m√°s leves que en hemofilia.",
              causes: "Mutaciones gen√©ticas en el gen VWF localizado en el cromosoma 12. Puede ser heredada de forma autos√≥mica dominante (tipo 1 y 2) o recesiva (tipo 3). Tipo 1: d√©ficit cuantitativo parcial; Tipo 2: defectos cualitativos; Tipo 3: d√©ficit completo severo.",
              treatment: "Desmopresina (DDAVP) para tipos 1 y 2A leves - aumenta la liberaci√≥n de vWF end√≥geno. Concentrados de vWF/Factor VIII para casos severos o cuando DDAVP no es efectivo. √Åcido tranex√°mico como coadyuvante para sangrado mucocut√°neo.",
              prognosis: "Generalmente buena. La mayor√≠a de los pacientes tienen s√≠ntomas leves y pueden manejar episodios hemorr√°gicos con tratamiento adecuado. Los casos severos requieren manejo similar a hemofilia.",
              clinicalNotes: "Existen tres tipos principales: Tipo 1 (d√©ficit parcial, 75% de casos), Tipo 2 (defectos cualitativos, 20-25%), Tipo 3 (d√©ficit severo, raro). El tiempo de sangrado est√° prolongado y el Factor VIII puede estar reducido.",
              affectedFactors: "Factor von Willebrand (vWF) - esencial para la adhesi√≥n plaquetaria y estabilizaci√≥n del Factor VIII",
              cascadePathway: "Fallo en la hemostasia primaria. Sin adhesi√≥n plaquetaria, no se inicia adecuadamente la cascada de coagulaci√≥n, aunque los factores de coagulaci√≥n pueden estar normales.",
            },
          },
          thrombocytopenia: {
            name: "Trombocitopenia",
            description:
              "Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo",
            plateletRatio: 0.075, // Spawn BAJO (5-10%, promedio 7.5%)
            canStick: true, // Funcionalidad normal
            canFormFibrin: true, // El "cemento" (fibrina) funciona bien
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 1.0, // Normal - si logran juntarse, tejen fibrina
            fibrinStability: 1.0, // Normal
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            spawnRateMultiplier: 0.3,
            bleedingTime: 20,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676",
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La trombocitopenia es una condici√≥n caracterizada por un recuento bajo de plaquetas (<150,000/ŒºL). Las plaquetas existentes funcionan normalmente, pero su n√∫mero insuficiente dificulta la formaci√≥n adecuada del tap√≥n hemost√°tico.",
              pathophysiology: "Con pocas plaquetas circulantes, aunque cada plaqueta funcione correctamente, no hay suficientes c√©lulas para cubrir el √°rea de la lesi√≥n y formar un tap√≥n primario efectivo. La cascada de coagulaci√≥n puede funcionar normalmente, pero sin un tap√≥n plaquetario adecuado, la formaci√≥n de fibrina es limitada o ineficaz.",
              symptoms: "Petequias (peque√±as manchas rojas en la piel), p√∫rpura (manchas moradas), equimosis (hematomas), sangrado mucocut√°neo, sangrado prolongado tras lesiones menores. El riesgo de sangrado aumenta significativamente con recuentos <50,000/ŒºL y es severo con <20,000/ŒºL.",
              causes: "M√∫ltiples causas: disminuci√≥n de producci√≥n (anemia apl√°sica, leucemia, d√©ficit de vitamina B12/folato), aumento de destrucci√≥n (p√∫rpura trombocitop√©nica inmune, trombocitopenia inducida por f√°rmacos), secuestro espl√©nico, consumo excesivo (coagulaci√≥n intravascular diseminada).",
              treatment: "Depende de la causa: corticosteroides o inmunoglobulina IV para trombocitopenia inmune, transfusi√≥n de plaquetas para sangrado activo o recuentos muy bajos, esplenectom√≠a en casos refractarios, tratamiento de la causa subyacente.",
              prognosis: "Var√≠a seg√∫n la causa. La trombocitopenia inmune aguda en ni√±os suele resolverse espont√°neamente. Las formas cr√≥nicas requieren manejo a largo plazo. Con tratamiento adecuado, la mayor√≠a de los pacientes pueden mantener recuentos seguros.",
              clinicalNotes: "Recuento normal: 150,000-450,000/ŒºL. Leve: 100,000-150,000/ŒºL (sangrado menor). Moderada: 50,000-100,000/ŒºL (sangrado con trauma). Severa: <50,000/ŒºL (sangrado espont√°neo). El tiempo de sangrado est√° prolongado proporcionalmente al d√©ficit.",
              affectedFactors: "Ning√∫n factor de coagulaci√≥n est√° afectado - el problema es cuantitativo (n√∫mero de plaquetas) no cualitativo (funci√≥n)",
              cascadePathway: "La cascada de coagulaci√≥n funciona normalmente, pero la hemostasia primaria es inadecuada debido al n√∫mero insuficiente de plaquetas para formar el tap√≥n inicial.",
            },
          },
          hemophiliaSevere: {
            name: "Hemofilia Severa",
            description:
              "D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesi√≥n: S√ç (Se forma tap√≥n blanco)
            canFormFibrin: false, // Fibrina: CERO
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregaci√≥n: S√ç
            fibrinFormationRate: 0.0, // CERO
            fibrinStability: 0.0, // CERO
            fibrinDecayRate: 0.2,
            fibrinFormationDelay: 0,
            bleedingTime: 60,
            blockThickCords: true,
            blockMediumCords: true,
            blockThinCords: true, // Bloquear todas las cuerdas
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF0000",
              fibrinGlow: false,
              fibrinOpacity: 0.0, // Invisible porque no se forma
            },
            educational: {
              overview: "La hemofilia severa se define por niveles de Factor VIII o IX <1% de lo normal. Representa la forma m√°s grave de hemofilia, con sangrado espont√°neo frecuente y riesgo significativo de complicaciones hemorr√°gicas graves.",
              pathophysiology: "Con niveles pr√°cticamente indetectables de Factor VIII o IX, la v√≠a intr√≠nseca de coagulaci√≥n est√° completamente bloqueada. El tap√≥n plaquetario primario se forma normalmente, pero sin generaci√≥n de trombina, no hay conversi√≥n de fibrin√≥geno a fibrina. Los co√°gulos que se forman son extremadamente d√©biles y se desintegran r√°pidamente, resultando en sangrado prolongado o recurrente.",
              symptoms: "Sangrado espont√°neo frecuente (sin trauma aparente), hemartrosis recurrente que puede llevar a artropat√≠a hemof√≠lica, hematomas extensos, sangrado intracraneal (complicaci√≥n grave), sangrado post-quir√∫rgico severo, sangrado gastrointestinal o genitourinario.",
              causes: "Mutaciones gen√©ticas severas en los genes de Factor VIII (Hemofilia A severa) o Factor IX (Hemofilia B severa) que resultan en producci√≥n m√≠nima o nula del factor. Patr√≥n de herencia ligado al cromosoma X.",
              treatment: "Tratamiento profil√°ctico regular con concentrados de Factor VIII/IX (2-3 veces por semana) para prevenir sangrados. Tratamiento de episodios hemorr√°gicos agudos con dosis altas. En algunos casos, terapia g√©nica experimental. Manejo multidisciplinario incluyendo fisioterapia para prevenir artropat√≠a.",
              prognosis: "Sin tratamiento, la esperanza de vida est√° significativamente reducida debido a complicaciones hemorr√°gicas. Con tratamiento profil√°ctico adecuado, los pacientes pueden llevar vidas relativamente normales, aunque requieren atenci√≥n m√©dica continua. La artropat√≠a hemof√≠lica es una complicaci√≥n com√∫n a largo plazo.",
              clinicalNotes: "Niveles de factor <1% definen hemofilia severa. El PTT est√° muy prolongado (>60 segundos). Los pacientes requieren tratamiento profil√°ctico para prevenir sangrados espont√°neos. El desarrollo de inhibidores (anticuerpos contra el factor) es una complicaci√≥n grave que afecta al 20-30% de pacientes con Hemofilia A severa.",
              affectedFactors: "Factor VIII o Factor IX pr√°cticamente ausentes (<1% de actividad normal) - bloqueo completo de la v√≠a intr√≠nseca",
              cascadePathway: "V√≠a intr√≠nseca completamente bloqueada. Sin Factor VIII/IX, no hay activaci√≥n del Factor X, resultando en ausencia total de generaci√≥n de trombina y formaci√≥n de fibrina.",
            },
          },
          thrombasthenia: {
            name: "Trombastenia de Glanzmann",
            description:
              "D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesi√≥n (Pared): S√ç - Se pegan al tejido
            canFormFibrin: true,
            stickProbability: 0.9,
            plateletFunction: 0.2,
            adhesionStrength: 0.85, // Se pegan a la pared
            aggregationRate: 0.0, // Agregaci√≥n (Plaqueta-Plaqueta): NO
            fibrinFormationRate: 0.0, // No se forma porque no hay agregaci√≥n
            fibrinStability: 0.0,
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            maxPlateletClusterSize: 1, // Solo una plaqueta por posici√≥n - no agregaci√≥n
            bleedingTime: 25,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FFA500",
              fibrinGlow: false,
              fibrinOpacity: 0.0, // No se forma fibrina
            },
            educational: {
              overview: "La trombastenia de Glanzmann es un trastorno hemorr√°gico hereditario raro caracterizado por d√©ficit o disfunci√≥n del complejo glicoprote√≠na IIb/IIIa (GPIIb/IIIa), el receptor principal de fibrin√≥geno en las plaquetas.",
              pathophysiology: "Las plaquetas pueden adherirse normalmente a la pared vascular mediante vWF y otros receptores, pero no pueden agregarse entre s√≠ porque el receptor GPIIb/IIIa est√° ausente o disfuncional. Este receptor es esencial para que las plaquetas se unan mediante puentes de fibrin√≥geno. Sin agregaci√≥n, no se forma un tap√≥n plaquetario efectivo, y aunque la cascada de coagulaci√≥n funcione, sin un tap√≥n adecuado la formaci√≥n de fibrina es limitada.",
              symptoms: "Sangrado mucocut√°neo severo (epistaxis, gingivorragia, menorragia), p√∫rpura, equimosis, sangrado prolongado tras cirug√≠a o trauma. El tiempo de sangrado est√° muy prolongado. Las plaquetas no se agregan en respuesta a agonistas como ADP, trombina o col√°geno.",
              causes: "Mutaciones en los genes ITGA2B (codifica GPIIb) o ITGB3 (codifica GPIIIa) localizados en el cromosoma 17. Herencia autos√≥mica recesiva. Tipo I: ausencia completa del complejo; Tipo II: presencia pero disfunci√≥n del complejo.",
              treatment: "Transfusi√≥n de plaquetas para episodios hemorr√°gicos agudos o antes de procedimientos quir√∫rgicos. √Åcido tranex√°mico como coadyuvante. Desmopresina puede tener efecto limitado. En casos refractarios, factor VIIa recombinante. Evitar antiagregantes plaquetarios.",
              prognosis: "Es un trastorno cr√≥nico que requiere manejo de por vida. Con tratamiento adecuado de episodios hemorr√°gicos, los pacientes pueden llevar vidas relativamente normales, aunque el sangrado puede ser severo. La menorragia puede ser particularmente problem√°tica en mujeres.",
              clinicalNotes: "El recuento plaquetario es normal, pero la agregaci√≥n plaquetaria est√° ausente o severamente reducida. El tiempo de sangrado est√° muy prolongado (>20 minutos). La prueba de agregaci√≥n plaquetaria muestra ausencia de respuesta a todos los agonistas. Es m√°s com√∫n en poblaciones con consanguinidad.",
              affectedFactors: "Glicoprote√≠na IIb/IIIa (GPIIb/IIIa) - receptor de fibrin√≥geno esencial para la agregaci√≥n plaquetaria",
              cascadePathway: "La cascada de coagulaci√≥n puede funcionar normalmente, pero sin agregaci√≥n plaquetaria no se forma un tap√≥n primario efectivo, limitando la iniciaci√≥n y eficacia de la formaci√≥n de fibrina.",
            },
          },
          factorDeficiency: {
            name: "D√©ficit Factor VII",
            description:
              "D√©ficit Factor VII - V√≠a extr√≠nseca defectuosa, formaci√≥n de fibrina reducida",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesi√≥n: S√ç - Las plaquetas se pegan
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 1.0, // Normal despu√©s del retraso
            fibrinStability: 0.9, // Normal despu√©s del retraso
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 4000, // Retraso 3-5 segundos extra (4000ms) tras la adhesi√≥n
            bleedingTime: 12,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FFD700",
              fibrinGlow: false,
              fibrinOpacity: 0.9,
            },
            educational: {
              overview: "El d√©ficit de Factor VII es un trastorno hemorr√°gico hereditario raro que afecta la v√≠a extr√≠nseca de la coagulaci√≥n. El Factor VII es el primer factor activado en la v√≠a extr√≠nseca cuando se expone el factor tisular tras una lesi√≥n.",
              pathophysiology: "El Factor VII, junto con el factor tisular (FT), inicia la v√≠a extr√≠nseca activando el Factor X. Con d√©ficit de Factor VII, esta activaci√≥n inicial est√° retrasada o reducida. La v√≠a intr√≠nseca puede compensar parcialmente, pero hay un retraso significativo en la generaci√≥n de trombina y formaci√≥n de fibrina. Las plaquetas funcionan normalmente, pero el refuerzo de fibrina tarda m√°s en formarse.",
              symptoms: "Sangrado variable seg√∫n la severidad del d√©ficit. Puede incluir sangrado mucocut√°neo, hemartrosis (menos com√∫n que en hemofilia), sangrado post-quir√∫rgico, menorragia. Los s√≠ntomas suelen ser m√°s leves que en hemofilia. El tiempo de protrombina (PT) est√° prolongado mientras que el PTT puede ser normal.",
              causes: "Mutaciones en el gen F7 localizado en el cromosoma 13 que codifica el Factor VII. Herencia autos√≥mica recesiva. Puede ser cong√©nito (raro) o adquirido (asociado a enfermedad hep√°tica, d√©ficit de vitamina K, o uso de warfarina).",
              treatment: "Concentrados de Factor VII recombinante o plasma fresco congelado para episodios hemorr√°gicos. En casos leves puede no requerir tratamiento profil√°ctico. El tratamiento de reemplazo es efectivo pero de corta duraci√≥n (vida media corta del Factor VII).",
              prognosis: "Generalmente buena. Los pacientes con d√©ficit leve pueden tener s√≠ntomas m√≠nimos. Los casos severos requieren tratamiento de episodios hemorr√°gicos pero pueden llevar vidas relativamente normales con manejo adecuado.",
              clinicalNotes: "El PT est√° prolongado mientras que el PTT es normal (patr√≥n inverso a hemofilia). El d√©ficit de Factor VII es el m√°s com√∫n de los d√©ficits de factores de la v√≠a extr√≠nseca, aunque sigue siendo raro. La vida media del Factor VII es corta (4-6 horas), requiriendo dosis frecuentes en tratamiento.",
              affectedFactors: "Factor VII - componente cr√≠tico de la v√≠a extr√≠nseca que inicia la activaci√≥n del Factor X",
              cascadePathway: "V√≠a extr√≠nseca defectuosa o retrasada. La v√≠a intr√≠nseca puede compensar parcialmente, pero hay un retraso en la generaci√≥n inicial de trombina, resultando en formaci√≥n tard√≠a de fibrina.",
            },
          },
          anticoagulated: {
            name: "Anticoagulado (Warfarina)",
            description:
              "Anticoagulaci√≥n oral - Factores dependientes de vitamina K reducidos, fibrina inestable",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesi√≥n: Normal
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 0.3, // ESCASA - probabilidad baja
            fibrinStability: 0.3, // D√âBIL (stiffness baja) - similar a hemofilia leve
            fibrinDecayRate: 0.08, // Decaimiento r√°pido
            fibrinFormationDelay: 800,
            bleedingTime: 8,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF6347",
              fibrinGlow: false,
              fibrinOpacity: 0.5, // M√°s transparente
            },
            educational: {
              overview: "La anticoagulaci√≥n con warfarina es un tratamiento com√∫n para prevenir trombosis en pacientes con fibrilaci√≥n auricular, pr√≥tesis valvulares card√≠acas, o historia de tromboembolismo. La warfarina inhibe la s√≠ntesis de factores de coagulaci√≥n dependientes de vitamina K.",
              pathophysiology: "La warfarina bloquea la enzima vitamina K ep√≥xido reductasa, impidiendo la carboxilaci√≥n de los factores II, VII, IX y X (factores dependientes de vitamina K). Sin esta modificaci√≥n post-traduccional, estos factores no pueden unirse al calcio y fosfol√≠pidos, reduciendo su actividad. Esto resulta en generaci√≥n reducida de trombina y formaci√≥n de fibrina d√©bil e inestable. Las plaquetas funcionan normalmente, pero el refuerzo de fibrina es insuficiente.",
              symptoms: "Aumento del riesgo de sangrado, especialmente con sobredosificaci√≥n. Puede presentar sangrado mucocut√°neo, hematomas f√°ciles, sangrado prolongado tras procedimientos, hemorragia gastrointestinal o intracraneal (complicaci√≥n grave). El tiempo de protrombina (PT/INR) est√° prolongado.",
              causes: "Uso terap√©utico de warfarina para prevenci√≥n de trombosis. La dosis se ajusta seg√∫n el INR objetivo (generalmente 2-3 para mayor√≠a de indicaciones, 2.5-3.5 para pr√≥tesis valvulares mec√°nicas). Interacciones con m√∫ltiples f√°rmacos y alimentos pueden afectar los niveles.",
              treatment: "Para sangrado menor: suspender warfarina temporalmente. Para sangrado mayor o INR muy elevado: vitamina K oral o IV para revertir la anticoagulaci√≥n, concentrado de complejo protromb√≠nico (PCC) para reversi√≥n r√°pida en emergencias, plasma fresco congelado como alternativa. Monitoreo regular de INR para ajuste de dosis.",
              prognosis: "Con monitoreo adecuado y mantenimiento del INR en rango terap√©utico, el riesgo de sangrado es bajo. Sin embargo, requiere monitoreo regular y ajuste de dosis. El riesgo de sangrado aumenta con INR >4.5. Los pacientes deben evitar traumatismos y ser cuidadosos con interacciones farmacol√≥gicas.",
              clinicalNotes: "El INR (International Normalized Ratio) es el par√°metro de monitoreo est√°ndar. Rango terap√©utico t√≠pico: 2-3. La warfarina tiene inicio de acci√≥n lento (2-3 d√≠as) y vida media larga (36-42 horas). Requiere 5-7 d√≠as para alcanzar efecto completo y similar tiempo para revertirse. Interacciones comunes con antibi√≥ticos, AINEs, y alimentos ricos en vitamina K.",
              affectedFactors: "Factores II (protrombina), VII, IX y X - todos dependientes de vitamina K para su activaci√≥n funcional",
              cascadePathway: "Ambas v√≠as (intr√≠nseca y extr√≠nseca) est√°n afectadas porque comparten factores dependientes de vitamina K. La generaci√≥n de trombina est√° reducida, resultando en formaci√≥n de fibrina d√©bil e inestable.",
            },
          },
        },
      };

      // Game State
      let state = {
        condition: "normal",
        treatmentApplied: false,
        bloodLoss: 0,
        clotPercentage: 0,
        hemostasisAchieved: false,
        stuckPlatelets: [],
        fibrinConstraints: [],
        fibrinBodies: [], // Physical bodies for fibrin network
        allBodies: [],
        showOintment: false,
        fibrinFormationStarted: false, // Secuencia: plaquetas primero, luego malla
        simulationRunning: false, // Control manual de simulaci√≥n
        currentStep: 1, // Paso actual del wizard
        // M√©tricas avanzadas
        startTime: null,
        firstAdhesionTime: null,
        woundClosureTime: null,
        fibrinFormationRate: 0,
        clotDensity: 0,
        totalPlateletsSpawned: 0,
        failedAdhesions: 0,
        aggregationRate: 0,
        // Datos hist√≥ricos para gr√°ficos
        history: {
          time: [],
          clotPercentage: [],
          bloodLoss: [],
          fibrinConnections: [],
          stuckPlatelets: [],
        },
        // Controles de velocidad
        timeScale: 1.0,
        isPaused: false,
        // Accesibilidad
        lastAnnouncedHemostasis: false,
        lastAnnouncedTreatment: false,
      };

      // Spawn timing for fixed interval
      let spawnInterval = null;
      let lastSpawnTime = 0;
      // spawnIntervalCounter removido
      let actualSpawnIntervals = []; // Array para calcular el intervalo promedio
      const SPAWN_INTERVAL_MS = 125; // Intervalo variable entre 100-150ms (promedio 125ms)

      // Performance optimization: frame counters for throttling
      let frameCount = 0;
      const CLEANUP_INTERVAL = 5; // Cleanup every 5 frames (m√°s frecuente para mejor limpieza)
      const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames

      // Fixed timestep loop variables - garantizar velocidad constante independiente del FPS
      let physicsLoopId = null;
      let renderLoopId = null;
      let lastPhysicsTime = 0;
      const FIXED_TIMESTEP = 1000 / 60; // 16.67ms = 60 FPS fijo para f√≠sica
      let accumulatedTime = 0;
      let accumulatedSimulationTime = 0; // Tiempo de simulaci√≥n acumulado (ajustado por timeScale)
      let lastSimulationTimeUpdate = 0; // √öltima vez que se actualiz√≥ el tiempo de simulaci√≥n

      // Matter.js Setup
      let engine, render, runner;

      function initSimulation() {
        // Clear spawn timeout
        if (spawnInterval !== null) {
          clearTimeout(spawnInterval);
          spawnInterval = null;
        }
        // spawnIntervalCounter removido

        lastSpawnTime = 0;
        actualSpawnIntervals = [];
        spawnStats = {
          lastSpawnCount: 0,
          totalSpawned: 0,
          spawnHistory: [],
        };

        // Reset state (preservar propiedades nuevas)
        state = {
          condition: state.condition,
          treatmentApplied: false,
          bloodLoss: 0,
          clotPercentage: 0,
          hemostasisAchieved: false,
          stuckPlatelets: [],
          fibrinConstraints: [],
          fibrinBodies: [],
          allBodies: [],
          showOintment: false,
          fibrinFormationStarted: false,
          simulationRunning: false,
          currentStep: state.currentStep || 1,
          // M√©tricas avanzadas
          startTime: null,
          firstAdhesionTime: null,
          woundClosureTime: null,
          fibrinFormationRate: 0,
          clotDensity: 0,
          totalPlateletsSpawned: 0,
          failedAdhesions: 0,
          aggregationRate: 0,
          // Datos hist√≥ricos para gr√°ficos
          history: {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          },
          // Controles de velocidad (base speed = 0.75, slider 1.0 = velocidad normal m√°s lenta)
          timeScale: state.timeScale || 0.75,
          isPaused: false,
          // Accesibilidad
          lastAnnouncedHemostasis: false,
          lastAnnouncedTreatment: false,
        };

        // FPS counter removed

        // Clear previous engine events
        if (engine) {
          Events.off(engine, "beforeUpdate");
          Events.off(engine, "afterUpdate");
          Events.off(engine, "collisionStart");
          // Remove anchor platelets before clearing world
          if (state.stuckPlatelets) {
            state.stuckPlatelets.forEach((plateletData) => {
              if (plateletData.isAnchor && plateletData.body) {
                Composite.remove(engine.world, plateletData.body);
              }
            });
          }
          Composite.clear(engine.world);
          Engine.clear(engine);
        }
        if (render) {
          Events.off(render, "afterRender");
          Render.stop(render);
        }
        // No necesitamos detener el runner porque usamos nuestro propio loop
        // if (runner) {
        //     Runner.stop(runner);
        // }

        // Reset canvas
        const canvas = document.getElementById("simulation-canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Reset state
        state.fibrinFormationStarted = false;
        state.simulationRunning = false;
        state.currentStep = 1;

        // Resetear tiempo acumulado de simulaci√≥n
        accumulatedSimulationTime = 0;
        lastSimulationTimeUpdate = 0;

        // Reset UI elements
        const woundLabel = document.getElementById("wound-label");
        woundLabel.classList.remove("healed", "hidden");
        woundLabel.innerHTML = "‚ö†Ô∏è Lesi√≥n Activa";
        
        // Remover efecto de pulsaci√≥n del bot√≥n de reiniciar
        const resetBtn = document.getElementById("reset-btn");
        if (resetBtn) {
          resetBtn.classList.remove("hemostasis-pulse");
        }

        const treatmentBtn = document.getElementById("treatment-btn");
        treatmentBtn.classList.remove("applied");
        treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg> Administrar Tratamiento`;
        treatmentBtn.disabled = false;

        // Resetear tiempo hasta cierre de herida
        const firstAdhesionTimeEl = document.getElementById(
          "first-adhesion-time"
        );
        if (firstAdhesionTimeEl) {
          firstAdhesionTimeEl.textContent = "--";
        }

        // Resetear sistema de feedback contextual
        ContextualFeedback.reset();

        // Create engine with zero gravity
        engine = Engine.create();
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 0;

        // Create renderer using existing canvas
        const canvasEl = document.getElementById("simulation-canvas");

        // Guardar el ancho original del canvas
        const originalCanvasWidth = CONFIG.canvas.width;
        const fixedCanvasHeight = CONFIG.canvas.height; // 300px fijo

        // Ajustar tama√±o del canvas seg√∫n el tama√±o de la pantalla
        // Mantener altura fija, solo ajustar ancho
        const updateCanvasSize = () => {
          const container = canvasEl.parentElement;
          const containerWidth = container.clientWidth;
          const maxWidth = Math.min(originalCanvasWidth, containerWidth - 32); // 32px de padding

          // Obtener el tama√±o visual real del canvas (considerando zoom del navegador)
          const rect = canvasEl.getBoundingClientRect();
          const visualWidth = rect.width;
          const visualHeight = rect.height;

          // Ajustar el tama√±o interno del canvas para que coincida exactamente con el tama√±o visual
          // Esto asegura que el canvas se renderice correctamente incluso con zoom
          // Usar el tama√±o visual directamente sin escalar con DPR para evitar problemas de zoom
          canvasEl.width = Math.round(visualWidth);
          canvasEl.height = Math.round(visualHeight);

          // Usar el tama√±o visual como tama√±o l√≥gico para la f√≠sica
          const logicalWidth = visualWidth;
          const logicalHeight = visualHeight;

          // Actualizar CONFIG para que la f√≠sica use el nuevo tama√±o l√≥gico
          CONFIG.canvas.width = logicalWidth;
          CONFIG.canvas.height = logicalHeight;

          // Mantener la herida siempre centrada
          CONFIG.wound.x = logicalWidth / 2;

          // Actualizar el renderer si ya existe
          if (render) {
            render.options.width = logicalWidth;
            render.options.height = logicalHeight;
            render.canvas.width = canvasEl.width;
            render.canvas.height = canvasEl.height;
            // Obtener el contexto fresco despu√©s de cambiar el tama√±o del canvas
            render.context = canvasEl.getContext("2d");
          }

          // Invalidar el cache del fondo del vaso para que se regenere con el nuevo tama√±o
          vesselBackgroundCache = null;

          // Si el engine ya existe, necesitamos recrear las paredes con el nuevo tama√±o
          if (engine && state.simulationRunning === false) {
            // Solo recrear si la simulaci√≥n no est√° corriendo
            // Las paredes se recrear√°n en el siguiente initSimulation
          }
        };

        updateCanvasSize();

        // Actualizar tama√±o cuando cambia el tama√±o de la ventana o el zoom
        let resizeTimeout;
        const handleResize = () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            updateCanvasSize();
            // Si la simulaci√≥n est√° corriendo, reiniciar para aplicar los cambios
            if (state.simulationRunning) {
              const wasRunning = state.simulationRunning;
              state.simulationRunning = false;
              initSimulation();
              if (wasRunning) {
                setTimeout(() => {
                  state.simulationRunning = true;
                  lastPhysicsTime = 0;
                  accumulatedTime = 0;
                }, 100);
              }
            }
          }, 250);
        };

        window.addEventListener("resize", handleResize);

        // Detectar cambios de zoom usando ResizeObserver
        const resizeObserver = new ResizeObserver(() => {
          handleResize();
        });
        resizeObserver.observe(canvasEl);

        render = Render.create({
          canvas: canvasEl,
          engine: engine,
          options: {
            width: canvasEl.width,
            height: canvasEl.height,
            wireframes: false,
            background: "transparent", // Fondo transparente - dibujamos nosotros
            // Desacoplar el renderer del timestep de la f√≠sica
            // El renderer se actualiza a su propio ritmo, pero la f√≠sica siempre usa timestep fijo
            // Usar pixelRatio 1 para evitar que Matter.js escale el canvas internamente
            // Ya estamos manejando el tama√±o manualmente para soportar zoom
            pixelRatio: 1,
          },
        });

        // Asegurar que el engine siempre use timestep fijo
        engine.timing.timeScale = 1.0;
        engine.timing.timestamp = 0;

        // Create vessel walls
        createVesselWalls();

        // Start engine and renderer with fixed timestep
        // Configurar el engine para usar timestep fijo
        engine.timing.timeScale = 1.0; // Asegurar que el timeScale sea 1.0

        // Crear Runner pero NO ejecutarlo autom√°ticamente
        // Usaremos nuestro propio loop con timestep fijo garantizado
        runner = Runner.create({
          delta: FIXED_TIMESTEP,
          isFixed: true,
          enabled: false, // Deshabilitar el loop autom√°tico
        });

        // Loop de renderizado independiente (puede ejecutarse a cualquier FPS)
        function renderLoop() {
          if (render) {
            Render.world(render);
          }
          renderLoopId = requestAnimationFrame(renderLoop);
        }

        // Iniciar el loop de renderizado (siempre activo)
        renderLoop();

        // Loop de f√≠sica con timestep fijo (solo se ejecuta cuando simulationRunning = true)
        function physicsLoop(currentTime) {
          if (!state.simulationRunning) {
            physicsLoopId = requestAnimationFrame(physicsLoop);
            return;
          }

          // Calcular tiempo transcurrido desde el √∫ltimo frame
          if (lastPhysicsTime === 0) {
            lastPhysicsTime = currentTime;
          }

          const deltaTime = currentTime - lastPhysicsTime;
          lastPhysicsTime = currentTime;

          // Acumular tiempo y ejecutar pasos de f√≠sica a intervalos fijos
          accumulatedTime += deltaTime;

          // Acumular tiempo de simulaci√≥n ajustado por timeScale (solo cuando est√° corriendo y no pausada)
          if (!state.isPaused && state.simulationRunning) {
            const timeScale = state.timeScale || 1.0;
            accumulatedSimulationTime += deltaTime * timeScale;
          }

          // Ejecutar tantos pasos de f√≠sica como sean necesarios para mantener timestep fijo
          // Ajustar el n√∫mero de pasos seg√∫n timeScale para acelerar la simulaci√≥n
          const timeScale = state.timeScale || 1.0;
          const maxSteps = 5; // Limitar pasos por frame para evitar "spiral of death"
          let stepsExecuted = 0;

          // Ejecutar m√∫ltiples pasos seg√∫n timeScale, pero mantener timestep fijo
          // Esto acelera la simulaci√≥n sin afectar la estabilidad f√≠sica
          const stepsToExecute = Math.max(1, Math.ceil(timeScale));

          while (
            accumulatedTime >= FIXED_TIMESTEP &&
            stepsExecuted < maxSteps
          ) {
            // Solo ejecutar f√≠sica si no est√° pausada
            if (!state.isPaused && state.simulationRunning) {
              // Ejecutar m√∫ltiples pasos de f√≠sica con timestep fijo para acelerar la simulaci√≥n
              // En lugar de escalar el timestep, ejecutamos m√°s pasos por iteraci√≥n
              // Esto mantiene la f√≠sica estable pero acelera la simulaci√≥n
              for (let i = 0; i < stepsToExecute; i++) {
                Engine.update(engine, FIXED_TIMESTEP);
              }
            }
            // Restar el tiempo correspondiente a los pasos ejecutados
            accumulatedTime -= FIXED_TIMESTEP;
            stepsExecuted++;
          }

          // Si acumulamos demasiado tiempo, resetear para evitar lag
          if (accumulatedTime > FIXED_TIMESTEP * 5) {
            accumulatedTime = 0;
          }

          physicsLoopId = requestAnimationFrame(physicsLoop);
        }

        // Iniciar el loop de f√≠sica (siempre activo, pero solo procesa cuando simulationRunning = true)
        // Resetear variables de tiempo
        lastPhysicsTime = 0;
        accumulatedTime = 0;

        // Iniciar el loop de f√≠sica
        if (!physicsLoopId) {
          physicsLoopId = requestAnimationFrame(physicsLoop);
        }

        // Estado inicial: simulaci√≥n no corriendo
        state.simulationRunning = false;

        // Setup collision events
        setupCollisionEvents();

        // Start particle spawning
        startParticleSpawning();

        // Reset frame counter
        frameCount = 0;

        // Update loop for forces - use fixed timestep for frame-independent forces
        // Con isFixed: true, el Runner ejecuta pasos de f√≠sica a intervalos fijos
        // Cada paso siempre es de 16.67ms, independientemente del FPS del renderer
        Events.on(engine, "beforeUpdate", () => {
          // Solo actualizar si la simulaci√≥n est√° corriendo y no est√° pausada
          if (!state.simulationRunning || state.isPaused) return;

          frameCount++;
          // Aplicar fuerzas con timestep fijo (el timeScale se maneja ejecutando m√∫ltiples pasos de f√≠sica)
          // Esto asegura que las fuerzas de adhesi√≥n funcionen correctamente independientemente de la velocidad
          applyForces(runner.delta);

          // Update fibrin barrier positions to follow platelets (every 3 frames for performance)
          if (frameCount % 3 === 0 && state.fibrinConstraints.length > 0) {
            state.fibrinConstraints.forEach((fibrin) => {
              if (fibrin.body && fibrin.pointA && fibrin.pointB) {
                const midX =
                  (fibrin.pointA.position.x + fibrin.pointB.position.x) / 2;
                const midY =
                  (fibrin.pointA.position.y + fibrin.pointB.position.y) / 2;
                const dist = Vector.magnitude(
                  Vector.sub(fibrin.pointB.position, fibrin.pointA.position)
                );
                const angle = Math.atan2(
                  fibrin.pointB.position.y - fibrin.pointA.position.y,
                  fibrin.pointB.position.x - fibrin.pointA.position.x
                );

                Body.setPosition(fibrin.body, { x: midX, y: midY });
                Body.setAngle(fibrin.body, angle);
                // Update width to match distance
                const currentWidth =
                  fibrin.body.bounds.max.x - fibrin.body.bounds.min.x;
                if (Math.abs(currentWidth - dist) > 1) {
                  Body.scale(fibrin.body, dist / currentWidth, 1);
                }
              }
            });
          }

          // Throttle expensive operations
          if (frameCount % CLEANUP_INTERVAL === 0) {
            cleanupParticles();
            // Tambi√©n limpiar plaquetas pegadas antiguas peri√≥dicamente
            cleanupOldStuckPlatelets();
          }
          if (frameCount % UI_UPDATE_INTERVAL === 0) {
            calculateClotPercentage();
            updateUI();
          }

          // vWF se renderiza como l√≠neas entre plaquetas (no necesita actualizaci√≥n)
        });

        // Custom render - todo en afterRender, en orden: fondo, paredes, fibrina, vWF, part√≠culas
        Events.on(render, "afterRender", renderVesselBackground);
        Events.on(render, "afterRender", renderVesselWalls);
        Events.on(render, "afterRender", renderFibrin);
        Events.on(render, "afterRender", renderVWF); // vWF se renderiza despu√©s de las cuerdas
        Events.on(render, "afterRender", renderParticlesCustom);

        // Update UI
        updateUI();
      }

      // FPS Counter removido

      function createVesselWalls() {
        const { width, height } = CONFIG.canvas;
        const { thickness, color } = CONFIG.wall;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;

        // Bottom wall (solid) - with bounce and collision filter
        const bottomWall = Bodies.rectangle(
          width / 2,
          height - thickness / 2,
          width,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Top wall - Left segment - with bounce and collision filter
        const leftWallWidth = woundX - woundWidth / 2;
        const topWallLeft = Bodies.rectangle(
          leftWallWidth / 2,
          thickness / 2,
          leftWallWidth,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Top wall - Right segment - with bounce and collision filter
        const rightWallStart = woundX + woundWidth / 2;
        const rightWallWidth = width - rightWallStart;
        const topWallRight = Bodies.rectangle(
          rightWallStart + rightWallWidth / 2,
          thickness / 2,
          rightWallWidth,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Wound edge markers (left and right edges of wound)
        const woundEdgeLeft = Bodies.rectangle(
          woundX - woundWidth / 2,
          thickness / 2,
          6,
          thickness + 10,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "woundEdge",
            isSensor: false,
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        const woundEdgeRight = Bodies.rectangle(
          woundX + woundWidth / 2,
          thickness / 2,
          6,
          thickness + 10,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "woundEdge",
            isSensor: false,
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        Composite.add(engine.world, [
          bottomWall,
          topWallLeft,
          topWallRight,
          woundEdgeLeft,
          woundEdgeRight,
        ]);

        // Create invisible anchor platelets on each side of the wound
        createInvisibleAnchorPlatelets(woundX, woundWidth, thickness);
      }

      function createInvisibleAnchorPlatelets(
        woundX,
        woundWidth,
        wallThickness
      ) {
        const adhesionLineY = 23; // Same Y position as the adhesion line
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Left anchor platelet - positioned just inside the left edge of the wound
        const leftAnchorX = woundLeft + 2;
        const leftAnchor = Bodies.circle(leftAnchorX, adhesionLineY + 6, 4, {
          isStatic: true,
          render: { fillStyle: "transparent", visible: false },
          label: "platelet",
          isStuck: true,
          isAnchor: true, // Mark as anchor platelet
        });

        // Right anchor platelet - positioned just inside the right edge of the wound
        const rightAnchorX = woundRight - 10;
        const rightAnchor = Bodies.circle(rightAnchorX, adhesionLineY + 6, 4, {
          isStatic: true,
          render: { fillStyle: "transparent", visible: false },
          label: "platelet",
          isStuck: true,
          isAnchor: true, // Mark as anchor platelet
        });

        Composite.add(engine.world, [leftAnchor, rightAnchor]);

        // Add to stuck platelets list so they can form fibrin connections
        const leftAnchorData = {
          body: leftAnchor,
          constraint: null,
          hasFibrin: false,
          fibrinConnections: [],
          isAnchor: true,
        };

        const rightAnchorData = {
          body: rightAnchor,
          constraint: null,
          hasFibrin: false,
          fibrinConnections: [],
          isAnchor: true,
        };

        state.stuckPlatelets.push(leftAnchorData, rightAnchorData);

        // Try to form fibrin connections from anchor platelets after a delay
        setTimeout(() => {
          if (state.stuckPlatelets.includes(leftAnchorData)) {
            tryFormFibrin(leftAnchorData);
          }
          if (state.stuckPlatelets.includes(rightAnchorData)) {
            tryFormFibrin(rightAnchorData);
          }
        }, 200);
      }

      function createParticle(type) {
        const y = 50 + Math.random() * 200;
        const x = -10;

        let body;

        switch (type) {
          case "platelet":
            // En Von Willebrand, las plaquetas tienen alta restituci√≥n (rebotan)
            const conditionConfig = CONFIG.conditions[state.condition];
            const plateletRestitution = 
              (state.condition === "vwd" && !state.treatmentApplied) 
                ? 0.9 // Alta restituci√≥n para vWD - rebotan en lugar de adherirse
                : 0.5; // Rebote medio normal
            
            body = Bodies.circle(x, y, 4, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "platelet",
              restitution: plateletRestitution,
              friction: 0.1,
              frictionAir: 0.02, // Reducido para que se muevan m√°s r√°pido, pero a√∫n suficiente para adhesi√≥n
              density: 0.001,
              isSticky: true,
              isStuck: false,
              collisionFilter: {
                group: 0,
                category: 0x0001,
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            // Rastrear plaquetas spawnadas
            state.totalPlateletsSpawned++;
            break;

          case "rbc":
            // Gl√≥bulos rojos: usar c√≠rculo pero renderizar como elipse en custom render
            body = Bodies.circle(x, y, 6, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "rbc",
              restitution: 0.5, // Rebote medio - ligero, relleno visual
              friction: 0.05,
              frictionAir: 0.01,
              density: 0.0008, // Ligero
              collisionFilter: {
                group: 0,
                category: 0x0001, // RBC category
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            break;

          case "wbc":
            body = Bodies.circle(x, y, 10, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "wbc",
              restitution: 0.7,
              friction: 0.1,
              frictionAir: 0.03,
              density: 0.04, // Pesado - obst√°culo visual
              collisionFilter: {
                group: 0,
                category: 0x0001, // WBC category
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            break;
        }

        if (body) {
          // Aplicar velocidad inicial basada en la fuerza del flujo para que aparezcan ya con velocidad normal
          // Calcular velocidad inicial basada en la fuerza promedio del flujo
          // Simula que la part√≠cula ya ha estado aceler√°ndose por un tiempo
          const flowForceAvg = (CONFIG.physics.flowForceMin + CONFIG.physics.flowForceMax) / 2;
          // Velocidad inicial: simula ~1 segundo de aceleraci√≥n previa
          // v = a * t, donde a = F/m y t = tiempo de aceleraci√≥n
          const accelerationTime = 1.0; // 1 segundo de aceleraci√≥n previa
          const acceleration = flowForceAvg / body.mass; // a = F/m
          const initialVelocityX = acceleration * accelerationTime;
          
          Body.setVelocity(body, {
            x: Math.max(0.02, initialVelocityX), // M√≠nimo para asegurar movimiento visible
            y: 0, // Sin velocidad vertical inicial
          });
          
          Composite.add(engine.world, body);
          state.allBodies.push(body);
        }

        return body;
      }

      // Variables para tracking de spawn
      let spawnStats = {
        lastSpawnCount: 0,
        totalSpawned: 0,
        spawnHistory: [], // √öltimos 10 conteos de spawn
      };

      function startParticleSpawning() {
        // Clear any existing timeout
        if (spawnInterval !== null) {
          clearTimeout(spawnInterval);
          spawnInterval = null;
        }
        // spawnIntervalCounter removido

        lastSpawnTime = performance.now();
        actualSpawnIntervals = [];
        spawnStats = {
          lastSpawnCount: 0,
          totalSpawned: 0,
          spawnHistory: [],
        };

        // Funci√≥n para spawnear part√≠culas
        const spawnParticles = () => {
          // Solo spawnear si la simulaci√≥n est√° corriendo
          if (!state.simulationRunning) {
            return;
          }

          const currentTime = performance.now();
          const actualInterval = currentTime - lastSpawnTime;

          // Registrar el intervalo real para el contador
          actualSpawnIntervals.push(actualInterval);
          if (actualSpawnIntervals.length > 20) {
            actualSpawnIntervals.shift(); // Mantener solo los √∫ltimos 20
          }

          let spawnedThisCycle = 0;

          // Contar solo part√≠culas m√≥viles (no pegadas) para el l√≠mite de spawn
          const mobileBodies = state.allBodies.filter((b) => {
            return !state.stuckPlatelets.some((p) => p.body === b);
          });

          if (mobileBodies.length < CONFIG.particles.maxCount) {
            const conditionConfig = CONFIG.conditions[state.condition];
            const plateletRatio = conditionConfig.plateletRatio;

            // Apply spawn rate multiplier for conditions like thrombocytopenia
            const spawnMultiplier = conditionConfig.spawnRateMultiplier || 1.0;
            const spawnCount = Math.max(
              1,
              Math.floor(CONFIG.particles.spawnRate * spawnMultiplier)
            );

            for (let i = 0; i < spawnCount; i++) {
              // Verificar l√≠mite con part√≠culas m√≥viles actualizadas
              const currentMobileCount = state.allBodies.filter((b) => {
                return !state.stuckPlatelets.some((p) => p.body === b);
              }).length;
              if (currentMobileCount >= CONFIG.particles.maxCount) break;

              const rand = Math.random();

              if (rand < plateletRatio) {
                createParticle("platelet");
                spawnedThisCycle++;
              } else if (rand < plateletRatio + CONFIG.particles.rbcRatio) {
                createParticle("rbc");
                spawnedThisCycle++;
              } else {
                createParticle("wbc");
                spawnedThisCycle++;
              }
            }
          }

          // Registrar estad√≠sticas de spawn
          spawnStats.lastSpawnCount = spawnedThisCycle;
          spawnStats.totalSpawned += spawnedThisCycle;
          spawnStats.spawnHistory.push(spawnedThisCycle);
          if (spawnStats.spawnHistory.length > 10) {
            spawnStats.spawnHistory.shift();
          }

          lastSpawnTime = currentTime;
        };

        // Funci√≥n recursiva que mantiene intervalo constante en tiempo real (8-10 part√≠culas/segundo)
        const scheduleNextSpawn = () => {
          if (!state.simulationRunning) return;

          // Intervalo variable entre 100-150ms (promedio 125ms) - siempre constante en tiempo real
          // Esto garantiza 8-10 part√≠culas por segundo independientemente de la velocidad de simulaci√≥n
          const variableInterval = 100 + Math.random() * 50; // 100-150ms

          spawnInterval = setTimeout(() => {
            spawnParticles();
            scheduleNextSpawn(); // Programar siguiente spawn con nuevo intervalo
          }, variableInterval);
        };

        // Iniciar el ciclo de spawn solo si la simulaci√≥n est√° corriendo
        if (state.simulationRunning) {
          scheduleNextSpawn();
        }

        // Contador de spawn removido
      }

      function toggleSimulation() {
        if (!state.simulationRunning) {
          // Iniciar simulaci√≥n
          state.simulationRunning = true;
          state.isPaused = false;
          state.startTime = Date.now();
          state.firstAdhesionTime = null;
          state.woundClosureTime = null;
          state.totalPlateletsSpawned = 0;
          state.lastAnnouncedHemostasis = false;
          state.lastAnnouncedTreatment = false;
          state.history = {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          };
          // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
          lastPhysicsTime = 0;
          accumulatedTime = 0;

          // Asegurar que timeScale tenga un valor v√°lido
          if (!state.timeScale || state.timeScale <= 0) {
            state.timeScale = 1.0;
          }

          // Reiniciar el spawn para asegurar que funcione
          startParticleSpawning();

          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitar bot√≥n de inicio cuando est√° corriendo
          }
          if (pauseBtn) {
            pauseBtn.disabled = false; // Habilitar bot√≥n de pausa cuando est√° corriendo
          }
          
          // Habilitar bot√≥n de tratamiento cuando la simulaci√≥n est√° corriendo
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied) {
            treatmentBtn.disabled = false;
          }
          
          // Si el tratamiento ya se aplic√≥, marcar todos los pasos como completados
          // Si no, avanzar al paso 3
          if (state.treatmentApplied) {
            document.querySelectorAll(".wizard-step").forEach((el, index) => {
              const stepNum = index + 1;
              el.classList.remove("active", "completed");
              if (stepNum <= 3) {
                el.classList.add("completed");
              }
            });
            state.currentStep = 3;
          } else {
            updateWizardStep(3);
          }
          
          if (typeof ScreenReaderAnnouncements !== 'undefined') {
            ScreenReaderAnnouncements.announce("Simulaci√≥n iniciada");
          }
        } else {
          // Pausar simulaci√≥n
          state.simulationRunning = false;
          state.isPaused = true;
          // No usar Runner.stop() - usamos nuestro propio loop
          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = false; // Habilitar bot√≥n de inicio cuando est√° pausada
          }
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar bot√≥n de pausa cuando est√° pausada
          }
          
          // El bot√≥n de tratamiento permanece habilitado cuando la simulaci√≥n est√° pausada
          // (siempre que se haya iniciado al menos una vez y no se haya aplicado ya)
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied && state.startTime) {
            treatmentBtn.disabled = false;
          }
          
          if (typeof ScreenReaderAnnouncements !== 'undefined') {
            ScreenReaderAnnouncements.announce("Simulaci√≥n pausada");
          }
        }
      }

      function updateWizardStep(step) {
        state.currentStep = step;
        document.querySelectorAll(".wizard-step").forEach((el, index) => {
          const stepNum = index + 1;
          el.classList.remove("active", "completed");
          if (stepNum < step) {
            el.classList.add("completed");
          } else if (stepNum === step) {
            el.classList.add("active");
          }
        });
        
        // Agregar/remover efecto de aura en condiciones cuando el paso 1 est√° activo
        const conditionsSidebar = document.querySelector(".conditions-sidebar");
        if (conditionsSidebar) {
          if (step === 1) {
            conditionsSidebar.classList.add("wizard-step-1-active");
          } else {
            conditionsSidebar.classList.remove("wizard-step-1-active");
          }
        }
        
        // Agregar/remover efecto de aura en bot√≥n de iniciar cuando el paso 2 est√° activo
        const startBtn = document.getElementById("start-btn");
        if (startBtn) {
          if (step === 2) {
            startBtn.classList.add("wizard-step-2-active");
          } else {
            startBtn.classList.remove("wizard-step-2-active");
          }
        }
        
        // Agregar/remover efecto de aura en bot√≥n de tratamiento cuando el paso 3 est√° activo
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          if (step === 3) {
            treatmentBtn.classList.add("wizard-step-3-active");
          } else {
            treatmentBtn.classList.remove("wizard-step-3-active");
          }
        }
      }

      function applyForces(timestep = 16.67) {
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Invisible adhesion line parameters - positioned at wound opening
        const adhesionLineY = 23; // Y position center of the adhesion zone
        const adhesionLineThreshold = 25; // Width of adhesion zone (m√°s ancho para efecto de profundidad)
        const adhesionDetectionThreshold = 8; // Umbral m√°s estricto para detectar adhesi√≥n (solo cuando est√° muy cerca)

        // IMPORTANTE: Con Runner.isFixed = true y delta = 16.67ms,
        // el timestep siempre es constante independientemente del FPS del renderer.
        // El Runner ejecuta pasos de f√≠sica a intervalos fijos, y cada paso siempre es de 16.67ms.
        // Por lo tanto, timeScale siempre debe ser 1.0 para mantener velocidad constante.
        // NO escalamos por el timestep real porque ya est√° fijo en 16.67ms.
        const timeScale = 1.0; // Siempre 1.0 porque el timestep es fijo

        state.allBodies.forEach((body) => {
          // Skip stuck platelets and static bodies
          if (body.isStuck || body.isStatic) return;

          // Prevent particles from passing through walls by checking bounds
          const { width, height } = CONFIG.canvas;
          const wallThickness = CONFIG.wall.thickness;
          const particleRadius =
            body.circleRadius ||
            (body.label === "rbc" ? 6 : body.label === "wbc" ? 10 : 4);

          // Check bottom wall
          if (body.position.y > height - wallThickness - particleRadius) {
            Body.setPosition(body, {
              x: body.position.x,
              y: height - wallThickness - particleRadius - 0.1,
            });
            Body.setVelocity(body, {
              x: body.velocity.x,
              y: Math.min(0, body.velocity.y * -0.8), // Bounce up
            });
          }

          // Check top walls (left and right segments)
          const woundX = CONFIG.wound.x;
          const woundWidth = CONFIG.wound.width;
          const woundLeft = woundX - woundWidth / 2;
          const woundRight = woundX + woundWidth / 2;

          if (body.position.y < wallThickness + particleRadius) {
            // Check if particle is in wound area
            if (body.position.x < woundLeft || body.position.x > woundRight) {
              // Outside wound - push back from top wall
              Body.setPosition(body, {
                x: body.position.x,
                y: wallThickness + particleRadius + 0.1,
              });
              Body.setVelocity(body, {
                x: body.velocity.x,
                y: Math.max(0, body.velocity.y * -0.8), // Bounce down
              });
            }
          }

          // Laminar flow force (right) con pulso card√≠aco (s√≠stole/di√°stole)
          // Simular pulso card√≠aco con funci√≥n seno: oscila entre flowForceMin y flowForceMax
          // Usar tiempo de simulaci√≥n acumulado (ajustado por timeScale) para que el pulso se acelere/ralentice con la velocidad
          const heartRate = 0.6; // Latidos por segundo (36 bpm) - muy lento para ser extremadamente visible
          const currentTime = accumulatedSimulationTime / 1000; // Tiempo de simulaci√≥n en segundos (ajustado por timeScale)
          const pulseFactor = Math.sin(currentTime * heartRate * Math.PI * 2);
          // Mapear seno (-1 a 1) al rango de fuerzas (min a max)
          // Calcular fuerza con pulso: oscila suavemente entre min y max
          // Cuando pulseFactor = -1 ‚Üí flowForce = min
          // Cuando pulseFactor = 1 ‚Üí flowForce = max
          const pulseRange = CONFIG.physics.flowForceMax - CONFIG.physics.flowForceMin;
          const flowForce = CONFIG.physics.flowForceMin + 
            (pulseRange / 2) * (1 + pulseFactor); // Mapea seno(-1 a 1) a (min a max)
          
          // Aplicar fuerza laminar con pulso
          Body.applyForce(body, body.position, {
            x: flowForce * body.mass * timeScale,
            y: 0,
          });

          // Suction force (vertical hacia arriba) - solo bajo la herida
          // Desactivar succi√≥n cuando la herida est√° cerrada
          if (!state.hemostasisAchieved) {
            // Aplicar succi√≥n vertical hacia arriba en el √°rea de la herida
            // √Årea de succi√≥n desplazada un poco a la izquierda
            const suctionOffset = 35; // Desplazamiento hacia la izquierda
            const suctionLeft = woundLeft - suctionOffset;
            const suctionRight = woundRight - suctionOffset;
            
            if (
              body.position.x > suctionLeft &&
              body.position.x < suctionRight &&
              body.position.y < 250
            ) {
              const distanceToWound = Math.abs(body.position.y - 20);
              // Succi√≥n m√°s fuerte cerca de la herida, disminuye con la distancia
              const suctionStrength =
                Math.abs(CONFIG.physics.suctionForce) * (1 - distanceToWound / 230);

              Body.applyForce(body, body.position, {
                x: 0,
                y: CONFIG.physics.suctionForce * body.mass * timeScale, // Vertical hacia arriba (negativo)
              });
            }
          }

          // FIBRIN NET BOUNCE - Make RBCs and WBCs bounce off fibrin network
          if (
            (body.label === "rbc" || body.label === "wbc") &&
            state.fibrinConstraints.length > 0
          ) {
            const cellRadius = body.label === "rbc" ? 6 : 10;
            const bounceThreshold = cellRadius + 6; // Increased detection threshold
            const bounceStrength = body.label === "rbc" ? 0.008 : 0.012; // Much stronger bounce force
            const cellPos = body.position;

            // Only check fibrin near the wound area for performance
            const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2 - 30;
            const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2 + 30;

            if (
              cellPos.x >= woundLeft &&
              cellPos.x <= woundRight &&
              cellPos.y < 120
            ) {
              for (let i = 0; i < state.fibrinConstraints.length; i++) {
                const fibrin = state.fibrinConstraints[i];
                const pointA = fibrin.pointA.position;
                const pointB = fibrin.pointB.position;

                if (!pointA || !pointB) continue;

                // Quick bounds check - skip if fibrin line is far from cell
                const minX = Math.min(pointA.x, pointB.x);
                const maxX = Math.max(pointA.x, pointB.x);
                const minY = Math.min(pointA.y, pointB.y);
                const maxY = Math.max(pointA.y, pointB.y);

                if (
                  cellPos.x < minX - bounceThreshold ||
                  cellPos.x > maxX + bounceThreshold ||
                  cellPos.y < minY - bounceThreshold ||
                  cellPos.y > maxY + bounceThreshold
                ) {
                  continue;
                }

                // Calculate distance from cell to fibrin line segment
                const lineVec = Vector.sub(pointB, pointA);
                const lineLength = Vector.magnitude(lineVec);

                if (lineLength < 0.1) continue; // Skip very short lines

                const toCell = Vector.sub(cellPos, pointA);
                const lineLengthSq = lineLength * lineLength;
                const t = Math.max(
                  0,
                  Math.min(1, Vector.dot(toCell, lineVec) / lineLengthSq)
                );
                const closestPoint = Vector.add(
                  pointA,
                  Vector.mult(lineVec, t)
                );
                const distVec = Vector.sub(cellPos, closestPoint);
                const distance = Vector.magnitude(distVec);
                const bounceThresholdSq = bounceThreshold * bounceThreshold;
                const distanceSq = distance * distance;

                // If cell is close to fibrin line, apply bounce force (or allow passage if weak)
                if (distanceSq < bounceThresholdSq && distance > 0.1) {
                  // Get fibrin stability - affects barrier effectiveness
                  const fibrinStability = fibrin.stability || 1.0;

                  // Si est√° sellado, bloquear completamente el paso
                  const passThroughChance = state.hemostasisAchieved
                    ? 0
                    : (1 - fibrinStability) * 0.3; // Up to 30% chance for very weak fibrin

                  if (Math.random() < passThroughChance) {
                    // Cell passes through weak fibrin - reduce velocity slightly
                    Body.setVelocity(body, {
                      x: body.velocity.x * 0.9,
                      y: body.velocity.y * 0.9,
                    });
                    continue; // Skip bounce for this fibrin connection
                  }

                  // Normalize distance vector to get bounce direction
                  const bounceDir = {
                    x: distVec.x / distance,
                    y: distVec.y / distance,
                  };

                  // Calculate velocity component towards the line
                  const velocityDot =
                    body.velocity.x * bounceDir.x +
                    body.velocity.y * bounceDir.y;

                  // Only apply bounce if moving towards the line
                  if (velocityDot < 0) {
                    // Bounce force reduced by stability - weaker fibrin = weaker bounce
                    const proximityFactor = 1 - distance / bounceThreshold;
                    const stabilityMultiplier = 0.3 + fibrinStability * 0.7; // 0.3-1.0 range
                    const bounceForce =
                      bounceStrength *
                      proximityFactor *
                      proximityFactor *
                      stabilityMultiplier;

                    // Scale bounce force by timestep for frame independence (use timeScale from function scope)
                    Body.applyForce(body, body.position, {
                      x: bounceDir.x * bounceForce * body.mass * 10 * timeScale,
                      y: bounceDir.y * bounceForce * body.mass * 10 * timeScale,
                    });

                    // Invert velocity component - effectiveness depends on stability
                    const bounceFactor =
                      0.5 + fibrinStability * 0.3 + proximityFactor * 0.2; // 0.5-1.0 range
                    Body.setVelocity(body, {
                      x:
                        body.velocity.x -
                        bounceDir.x * velocityDot * bounceFactor,
                      y:
                        body.velocity.y -
                        bounceDir.y * velocityDot * bounceFactor,
                    });

                    // Push cell away from the line - less effective for weak fibrin
                    const pushDistance =
                      (bounceThreshold - distance) * 0.3 * fibrinStability;
                    Body.setPosition(body, {
                      x: body.position.x + bounceDir.x * pushDistance,
                      y: body.position.y + bounceDir.y * pushDistance,
                    });
                  }
                }
              }
            }
          }

          // INVISIBLE ADHESION LINE - Check if platelet crosses the invisible line
          if (body.label === "platelet" && !body.isStuck) {
            const inWoundZone =
              body.position.x > woundLeft && body.position.x < woundRight;
            // Usar umbral m√°s estricto para detectar adhesi√≥n (solo cuando est√° muy cerca del centro)
            const distanceFromCenter = Math.abs(
              body.position.y - adhesionLineY
            );
            const nearAdhesionLine = distanceFromCenter < adhesionLineThreshold; // √Årea amplia para variaci√≥n
            const veryCloseToCenter = distanceFromCenter < 8; // Solo adherir cuando est√° muy cerca del centro

            if (inWoundZone && nearAdhesionLine && veryCloseToCenter) {
              const conditionConfig = CONFIG.conditions[state.condition];
              const canStick = state.treatmentApplied
                ? true
                : conditionConfig.canStick;
              // Reducir probabilidad base de adhesi√≥n
              const stickProb = state.treatmentApplied
                ? 0.7
                : conditionConfig.stickProbability * 0.3;

              // Check platelet function first
              if (
                !state.treatmentApplied &&
                Math.random() > conditionConfig.plateletFunction
              ) {
                // Platelet dysfunction - let it pass through fibrin network instead of bouncing
                // Reduce restitution to prevent bouncing and allow passage
                body.restitution = 0;
                Body.setVelocity(body, {
                  x: body.velocity.x * 0.95,
                  y: body.velocity.y * 0.95,
                });
                return;
              }

              // Fuerza de adhesi√≥n ajustada (un poco m√°s alta que antes)
              const baseAdhesionStrength = state.treatmentApplied
                ? 0.5
                : conditionConfig.adhesionStrength * 0.2;

              // A√±adir factor de distancia: m√°s cerca del centro = mayor probabilidad
              // Solo adherir si est√° muy cerca del centro (dentro de 6px)
              const distanceFactor = Math.max(0.3, 1 - distanceFromCenter / 6); // Factor moderado
              const finalAdhesionStrength =
                baseAdhesionStrength * distanceFactor;

              // A√±adir factor de velocidad: plaquetas m√°s lentas tienen mayor probabilidad
              const speed = Math.sqrt(
                body.velocity.x * body.velocity.x +
                  body.velocity.y * body.velocity.y
              );
              const speedFactor = Math.max(0.5, 1 - speed / 0.4); // Factor de velocidad moderado
              const finalAdhesionWithSpeed =
                finalAdhesionStrength * speedFactor;

              if (canStick && Math.random() < finalAdhesionWithSpeed) {
                // Stick to the invisible line
                stickPlateletToLine(body, adhesionLineY, conditionConfig);
              } else if (
                !state.treatmentApplied &&
                conditionConfig.adhesionRetryChance
              ) {
                // Retry adhesion chance
                setTimeout(() => {
                  if (
                    !body.isStuck &&
                    Math.random() < conditionConfig.adhesionRetryChance
                  ) {
                    if (canStick && Math.random() < adhesionStrength) {
                      stickPlateletToLine(body, adhesionLineY, conditionConfig);
                    }
                  }
                }, 100);
              } else {
                // Las plaquetas que no se adhieren atraviesan la malla en lugar de rebotar
                // Reducir restitution para evitar rebotes y permitir paso
                body.restitution = 0;
                Body.setVelocity(body, {
                  x: body.velocity.x * 0.95,
                  y: body.velocity.y * 0.95,
                });
              }
            }
          }
        });

        // For hemophilia and conditions with unstable fibrin - apply extra force to dislodge weakly attached platelets
        const conditionConfig = CONFIG.conditions[state.condition];
        if (
          (state.condition === "hemophilia" ||
            state.condition === "hemophiliaSevere" ||
            conditionConfig.fibrinStability < 0.5) &&
          !state.treatmentApplied
        ) {
          state.stuckPlatelets.forEach((platelet) => {
            if (
              !platelet.hasFibrin ||
              platelet.fibrinConnections.length === 0
            ) {
              // Gradually increase dislodge force for platelets without fibrin support - scaled by timestep
              const dislodgeForce =
                0.00015 * (1 - conditionConfig.fibrinStability);
              Body.applyForce(platelet.body, platelet.body.position, {
                x: 0,
                y:
                  -dislodgeForce *
                  platelet.body.mass *
                  (1 + Math.random()) *
                  timeScale,
              });
            }
          });
        }
      }

      function stickPlateletToLine(platelet, lineY, conditionConfig) {
        if (platelet.isStuck) return;

        platelet.isStuck = true;

        // Apply visual effects based on condition
        const visualEffects =
          conditionConfig.visualEffects ||
          CONFIG.conditions.normal.visualEffects;
        platelet.render.fillStyle = visualEffects.plateletColor || "#808080";

        // Stop movement and position within the adhesion zone (efecto de profundidad)
        Body.setVelocity(platelet, { x: 0, y: 0 });
        // Variar la posici√≥n Y dentro del √°rea de adhesi√≥n para crear profundidad
        // Las plaquetas pueden adherirse en un rango sim√©trico alrededor de la l√≠nea central
        const adhesionZoneHalfWidth = 12; // Mitad del ancho del √°rea de adhesi√≥n
        const adhesionZoneTop = lineY - adhesionZoneHalfWidth;
        const adhesionZoneBottom = lineY + adhesionZoneHalfWidth;
        // Posici√≥n aleatoria dentro del √°rea de adhesi√≥n, con distribuci√≥n normal centrada
        // Usar la posici√≥n actual de la plaqueta como referencia, pero limitada al √°rea de adhesi√≥n
        const currentY = platelet.position.y;
        const targetY = Math.max(
          adhesionZoneTop,
          Math.min(adhesionZoneBottom, currentY)
        );
        // A√±adir peque√±a variaci√≥n aleatoria para efecto de profundidad
        const randomVariation = (Math.random() - 0.5) * 4; // Variaci√≥n de ¬±2 p√≠xeles
        const stickY = Math.max(
          adhesionZoneTop,
          Math.min(adhesionZoneBottom, targetY + randomVariation)
        );
        Body.setPosition(platelet, { x: platelet.position.x, y: stickY });

        // Make platelet completely static so it doesn't move
        Body.setStatic(platelet, true);

        // Create constraint to the adhesion point - maximum stiffness
        const constraint = Constraint.create({
          bodyA: platelet,
          pointB: { x: platelet.position.x, y: stickY },
          stiffness: 1.0, // Maximum stiffness
          damping: 1.0, // Maximum damping
          length: 0,
          render: { visible: false },
        });

        Composite.add(engine.world, constraint);

        const plateletData = {
          body: platelet,
          constraint: constraint,
          hasFibrin: false,
          fibrinConnections: [],
          condition: state.condition,
          stuckAt: Date.now(), // Timestamp para identificar las m√°s antiguas
          isAnchor: false,
        };

        state.stuckPlatelets.push(plateletData);

        // Rastrear primera adhesi√≥n
        if (!state.firstAdhesionTime && state.startTime) {
          state.firstAdhesionTime = Date.now();
        }

        // Limitar el n√∫mero de plaquetas pegadas para mantener rendimiento
        cleanupOldStuckPlatelets();

        // Ocultar cartel cuando hay plaquetas pegadas
        const woundLabel = document.getElementById("wound-label");
        if (state.stuckPlatelets.length > 0) {
          woundLabel.classList.add("hidden");
        }

        // Secuencia: plaquetas primero, luego malla
        // Activar formaci√≥n de fibrina solo despu√©s de umbral de plaquetas
        // Con tratamiento, reducir el umbral m√≠nimo de plaquetas
        const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
        if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
          state.fibrinFormationStarted = true;

          // Try to form fibrin after delay if specified
          // Con tratamiento, reducir significativamente el delay
          const baseDelay = conditionConfig.fibrinFormationDelay || 150;
          const delay = state.treatmentApplied
            ? Math.max(50, baseDelay * 0.3)
            : baseDelay;
          setTimeout(() => {
            if (state.stuckPlatelets.includes(plateletData)) {
              tryFormFibrin(plateletData);

              // Also try to form fibrin from nearby anchor platelets
              state.stuckPlatelets.forEach((other) => {
                if (other.isAnchor && other.body) {
                  const dist = Vector.magnitude(
                    Vector.sub(plateletData.body.position, other.body.position)
                  );
                  if (dist < 80) {
                    tryFormFibrin(other);
                  }
                }
              });
            }
          }, delay);
        }
      }

      function cleanupOldStuckPlatelets() {
        const maxStuckPlatelets = CONFIG.stuckPlatelets.maxCount;

        // Si no excedemos el l√≠mite, no hacer nada
        if (state.stuckPlatelets.length <= maxStuckPlatelets) {
          return;
        }

        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const woundAreaMargin = 100; // Margen alrededor de la herida para considerar "relevante"

        // Ordenar plaquetas pegadas por timestamp (m√°s antiguas primero)
        // Pero excluir las anchor platelets y las que est√°n cerca de la herida
        const plateletsToConsider = state.stuckPlatelets
          .filter((p) => !p.isAnchor) // No eliminar anchor platelets
          .map((p) => ({
            data: p,
            distance: Math.abs(p.body.position.x - woundX),
            isNearWound:
              p.body.position.x >= woundLeft - woundAreaMargin &&
              p.body.position.x <= woundRight + woundAreaMargin &&
              p.body.position.y >= 20 &&
              p.body.position.y <= 100,
          }))
          .sort((a, b) => {
            // Priorizar eliminar las que est√°n lejos de la herida
            if (a.isNearWound && !b.isNearWound) return 1;
            if (!a.isNearWound && b.isNearWound) return -1;
            // Si ambas est√°n cerca o lejos, ordenar por timestamp (m√°s antiguas primero)
            return (a.data.stuckAt || 0) - (b.data.stuckAt || 0);
          });

        // Calcular cu√°ntas necesitamos eliminar
        const toRemove = state.stuckPlatelets.length - maxStuckPlatelets;

        // Eliminar las m√°s antiguas que est√°n lejos de la herida
        for (let i = 0; i < toRemove && i < plateletsToConsider.length; i++) {
          const plateletData = plateletsToConsider[i].data;

          // Eliminar constraints de fibrina conectados
          for (let j = state.fibrinConstraints.length - 1; j >= 0; j--) {
            const fibrin = state.fibrinConstraints[j];
            if (
              fibrin.pointA === plateletData.body ||
              fibrin.pointB === plateletData.body
            ) {
              removeFibrinConnection(fibrin);
            }
          }

          // Eliminar constraint de la plaqueta
          if (plateletData.constraint) {
            Composite.remove(engine.world, plateletData.constraint);
          }

          // Eliminar el body
          Composite.remove(engine.world, plateletData.body);

          // Eliminar de la lista
          const index = state.stuckPlatelets.indexOf(plateletData);
          if (index > -1) {
            state.stuckPlatelets.splice(index, 1);
          }

          // Eliminar de allBodies
          const bodyIndex = state.allBodies.indexOf(plateletData.body);
          if (bodyIndex > -1) {
            state.allBodies.splice(bodyIndex, 1);
          }
        }
      }

      function cleanupParticles() {
        const toRemove = [];
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Optimized cleanup: iterate backwards for better performance when removing
        for (let i = state.allBodies.length - 1; i >= 0; i--) {
          const body = state.allBodies[i];
          const px = body.position.x;
          const py = body.position.y;

          // Solo eliminar part√≠culas m√≥viles (no pegadas) en la limpieza b√°sica
          const isStuck = state.stuckPlatelets.some((p) => p.body === body);

          if (!isStuck) {
            // Remove particles that exit right (eliminar cuando salen completamente del canvas)
            if (px > CONFIG.canvas.width + 20) {
              toRemove.push(body);
            }
            // Remove particles that exit top (blood loss)
            else if (py < -20) {
              toRemove.push(body);
              state.bloodLoss++;
            }
            // Remove particles that exit through the wound (upward)
            else if (py < 10 && px >= woundLeft - 5 && px <= woundRight + 5) {
              toRemove.push(body);
              state.bloodLoss++;
            }
            // Remove particles way off screen (bottom or left)
            else if (py > CONFIG.canvas.height + 20 || px < -30) {
              toRemove.push(body);
            }
          }
        }

        // Optimized removal: use Map for faster lookups
        const bodySet = new Set(toRemove);

        toRemove.forEach((body) => {
          // Remove associated constraints if it's a stuck platelet
          const plateletIndex = state.stuckPlatelets.findIndex(
            (p) => p.body === body
          );
          if (plateletIndex !== -1) {
            const plateletData = state.stuckPlatelets[plateletIndex];

            // Remove fibrin constraints connected to this platelet (iterate backwards)
            for (let i = state.fibrinConstraints.length - 1; i >= 0; i--) {
              const fibrin = state.fibrinConstraints[i];
              if (fibrin.pointA === body || fibrin.pointB === body) {
                removeFibrinConnection(fibrin);
              }
            }

            // Remove platelet constraint
            if (plateletData.constraint) {
              Composite.remove(engine.world, plateletData.constraint);
            }

            // Remove from stuck platelets list (but not anchor platelets)
            if (!plateletData.isAnchor) {
              state.stuckPlatelets.splice(plateletIndex, 1);
            }
          }

          Composite.remove(engine.world, body);
        });

        // Remove from allBodies array (more efficient)
        state.allBodies = state.allBodies.filter((b) => !bodySet.has(b));

        // Limpieza agresiva: eliminar part√≠culas que est√°n cerca del borde derecho
        // Esto asegura que las part√≠culas se eliminen antes de llegar al l√≠mite m√°ximo
        const aggressiveCleanupThreshold = CONFIG.particles.maxCount * 0.7; // 70% del l√≠mite (105 part√≠culas)
        if (state.allBodies.length > aggressiveCleanupThreshold) {
          const additionalToRemove = [];

          for (let i = state.allBodies.length - 1; i >= 0; i--) {
            const body = state.allBodies[i];
            if (!body || !body.position) continue;

            const px = body.position.x;
            const py = body.position.y;

            // Solo eliminar part√≠culas m√≥viles (no pegadas)
            const isStuck = state.stuckPlatelets.some((p) => p.body === body);
            if (isStuck) continue;

            // Eliminar part√≠culas que est√°n muy cerca del borde derecho (dentro de 30px del final)
            if (px > CONFIG.canvas.width - 30) {
              additionalToRemove.push(body);
            }
            // Tambi√©n eliminar part√≠culas que est√°n muy abajo (fuera de la vista √∫til)
            else if (py > CONFIG.canvas.height - 10) {
              additionalToRemove.push(body);
            }
          }

          // Eliminar las part√≠culas adicionales encontradas
          additionalToRemove.forEach((body) => {
            try {
              Composite.remove(engine.world, body);
              const index = state.allBodies.indexOf(body);
              if (index > -1) {
                state.allBodies.splice(index, 1);
              }
            } catch (e) {
              // Ignorar errores si el body ya fue eliminado
            }
          });
        }
      }

      function setupCollisionEvents() {
        Events.on(engine, "collisionStart", (event) => {
          event.pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            // Check for platelet collision with wound edges or stuck platelets
            handlePlateletCollision(bodyA, bodyB);
            handlePlateletCollision(bodyB, bodyA);

            // Handle weak fibrin barrier collisions - allow occasional passage
            handleFibrinBarrierCollision(bodyA, bodyB);
            handleFibrinBarrierCollision(bodyB, bodyA);
          });
        });
      }

      function handleFibrinBarrierCollision(cell, barrier) {
        // Check if cell (RBC/WBC) collides with fibrin barrier
        if (
          (cell.label !== "rbc" && cell.label !== "wbc") ||
          barrier.label !== "fibrinBarrier"
        ) {
          return;
        }

        // Get fibrin stability from barrier
        const fibrinStability = barrier.fibrinStability || 1.0;

        // Si est√° sellado, bloquear completamente el paso
        if (state.hemostasisAchieved) {
          return; // No permitir paso cuando est√° sellado
        }

        // Weak fibrin occasionally allows cells to pass through
        if (fibrinStability < 0.6) {
          const passThroughChance = (1 - fibrinStability) * 0.4; // Up to 40% chance for very weak fibrin

          if (Math.random() < passThroughChance) {
            // Allow cell to pass through - make barrier temporarily non-collidable
            barrier.collisionFilter.mask = 0x0000; // No collisions

            // Restore collision after a short time
            setTimeout(() => {
              if (barrier.label === "fibrinBarrier") {
                barrier.collisionFilter.mask = 0x0001;
              }
            }, 500);

            // Reduce cell velocity slightly as it passes through
            Body.setVelocity(cell, {
              x: cell.velocity.x * 0.85,
              y: cell.velocity.y * 0.85,
            });
          } else {
            // Reduce bounce effectiveness for weak fibrin
            const bounceReduction = 1 - fibrinStability;
            Body.setVelocity(cell, {
              x: cell.velocity.x * (1 - bounceReduction * 0.3),
              y: cell.velocity.y * (1 - bounceReduction * 0.3),
            });
          }
        }
      }

      function handlePlateletCollision(platelet, other) {
        if (platelet.label !== "platelet" || platelet.isStuck) return;

        const conditionConfig = CONFIG.conditions[state.condition];

        // Check platelet function first
        if (
          !state.treatmentApplied &&
          Math.random() > conditionConfig.plateletFunction
        ) {
          // Platelet dysfunction - let it pass through instead of bouncing
          // Reduce restitution to prevent bouncing and allow passage
          platelet.restitution = 0;
          Body.setVelocity(platelet, {
            x: platelet.velocity.x * 0.95,
            y: platelet.velocity.y * 0.95,
          });
          return;
        }

        const canStick = state.treatmentApplied
          ? true
          : conditionConfig.canStick;
        const adhesionStrength = state.treatmentApplied
          ? 0.95
          : conditionConfig.adhesionStrength;

        // Check if collision is with wound edge or stuck platelet
        const isWoundEdge = other.label === "woundEdge";
        const isStuckPlatelet = other.label === "platelet" && other.isStuck;

        if (isWoundEdge || isStuckPlatelet) {
          // Check if in wound zone
          const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
          const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;

          if (
            platelet.position.x >= woundLeft - 20 &&
            platelet.position.x <= woundRight + 20 &&
            platelet.position.y < 45
          ) {
            // Check aggregation rate for platelet-to-platelet adhesion
            // En vWD sin tratamiento, las plaquetas no se agregan (no hay cemento vWF)
            if (isStuckPlatelet) {
              const aggregationRate = state.treatmentApplied
                ? 0.9
                : conditionConfig.aggregationRate;
              if (Math.random() > aggregationRate) {
                // Failed aggregation - plaquetas rebotan/se separan (sin cemento vWF)
                platelet.restitution = 0.9;
                // En vWD, rebote m√°s fuerte para simular que no hay cemento
                const bounceStrength =
                  state.condition === "vwd" && !state.treatmentApplied
                    ? 1.5
                    : 1.0;
                Body.setVelocity(platelet, {
                  x: platelet.velocity.x * (0.8 * bounceStrength),
                  y: Math.abs(platelet.velocity.y) * (1.2 * bounceStrength) + 1,
                });
                return;
              }
            }

            if (canStick && Math.random() < adhesionStrength) {
              stickPlatelet(platelet, other, conditionConfig);
            } else if (
              !state.treatmentApplied &&
              conditionConfig.adhesionRetryChance
            ) {
              // Retry adhesion chance
              setTimeout(() => {
                if (
                  !platelet.isStuck &&
                  Math.random() < conditionConfig.adhesionRetryChance
                ) {
                  if (canStick && Math.random() < adhesionStrength) {
                    stickPlatelet(platelet, other, conditionConfig);
                  }
                }
              }, 100);
            } else {
              // Las plaquetas que no se adhieren atraviesan en lugar de rebotar
              // Reducir restitution para evitar rebotes y permitir paso
              platelet.restitution = 0;
              Body.setVelocity(platelet, {
                x: platelet.velocity.x * 0.95,
                y: platelet.velocity.y * 0.95,
              });
            }
          }
        }
      }

      function stickPlatelet(platelet, anchor, conditionConfig) {
        if (platelet.isStuck) return;

        platelet.isStuck = true;

        // Apply visual effects based on condition
        const visualEffects =
          conditionConfig.visualEffects ||
          CONFIG.conditions.normal.visualEffects;
        platelet.render.fillStyle = visualEffects.plateletColor || "#808080";

        // Stop movement completely
        Body.setVelocity(platelet, { x: 0, y: 0 });

        // Make platelet completely static so it doesn't move
        Body.setStatic(platelet, true);

        // Create constraint to anchor point - maximum stiffness
        const constraint = Constraint.create({
          bodyA: platelet,
          pointB: anchor.isStatic
            ? { x: anchor.position.x, y: anchor.position.y }
            : null,
          bodyB: anchor.isStatic ? null : anchor,
          stiffness: 1.0, // Maximum stiffness
          damping: 1.0, // Maximum damping
          length: 0,
          render: { visible: false },
        });

        Composite.add(engine.world, constraint);

        const plateletData = {
          body: platelet,
          constraint: constraint,
          hasFibrin: false,
          fibrinConnections: [],
          condition: state.condition,
          stuckAt: Date.now(), // Timestamp para identificar las m√°s antiguas
          isAnchor: false,
        };

        state.stuckPlatelets.push(plateletData);

        // Rastrear primera adhesi√≥n
        if (!state.firstAdhesionTime && state.startTime) {
          state.firstAdhesionTime = Date.now();
        }

        // Limitar el n√∫mero de plaquetas pegadas para mantener rendimiento
        cleanupOldStuckPlatelets();

        // Ocultar cartel cuando hay plaquetas pegadas
        const woundLabel = document.getElementById("wound-label");
        if (state.stuckPlatelets.length > 0) {
          woundLabel.classList.add("hidden");
        }

        // Secuencia: plaquetas primero, luego malla
        // Activar formaci√≥n de fibrina solo despu√©s de umbral de plaquetas
        // Con tratamiento, reducir el umbral m√≠nimo de plaquetas
        const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
        if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
          state.fibrinFormationStarted = true;

          // Try to form fibrin with delay if specified
          // Con tratamiento, reducir significativamente el delay
          const baseDelay = conditionConfig.fibrinFormationDelay || 100;
          const delay = state.treatmentApplied
            ? Math.max(50, baseDelay * 0.3)
            : baseDelay;
          setTimeout(() => {
            if (state.stuckPlatelets.includes(plateletData)) {
              tryFormFibrin(plateletData);
            }
          }, delay);
        }
      }

      function tryFormFibrin(plateletData) {
        const conditionConfig = CONFIG.conditions[state.condition];
        const canFormFibrin = state.treatmentApplied
          ? true
          : conditionConfig.canFormFibrin;

        if (!canFormFibrin) return;

        // Secuencia: plaquetas primero, luego malla - solo formar si ya empez√≥ la formaci√≥n
        if (!state.fibrinFormationStarted) return;

        // Check fibrin formation rate
        const fibrinFormationRate = state.treatmentApplied
          ? 1.0
          : conditionConfig.fibrinFormationRate;
        if (Math.random() > fibrinFormationRate) {
          return; // Failed to form fibrin this time
        }

        // Limit total fibrin connections
        if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections)
          return;

        // Limit connections per platelet
        if (
          plateletData.fibrinConnections.length >=
          CONFIG.fibrin.maxConnectionsPerPlatelet
        )
          return;

        // Check max cluster size for thrombasthenia
        if (conditionConfig.maxPlateletClusterSize) {
          const nearbyCount = state.stuckPlatelets.filter((p) => {
            const dx = p.body.position.x - plateletData.body.position.x;
            const dy = p.body.position.y - plateletData.body.position.y;
            return dx * dx + dy * dy < 400 && p.fibrinConnections.length > 0;
          }).length;
          if (nearbyCount >= conditionConfig.maxPlateletClusterSize) {
            return; // Cannot form larger clusters
          }
        }

        const platelet = plateletData.body;

        // Get fibrin stability from condition - affects connection distance
        const fibrinStability = state.treatmentApplied
          ? 1.0
          : conditionConfig.fibrinStability;

        // When fibrin is weaker, platelets must be closer to form connections
        // Strong fibrin (1.0): can connect up to 90px away, minimum 20px
        // Weak fibrin (0.3): can connect up to 40px away, minimum 8px
        // El tratamiento NO afecta la distancia de conexi√≥n, solo la velocidad de adhesi√≥n
        const baseMaxSearchRadius = 40 + fibrinStability * 50; // 40-90px range
        const maxSearchRadius = baseMaxSearchRadius; // Distancia fija, no afectada por tratamiento
        const minDistance = 8 + fibrinStability * 12; // 8-20px range
        const minDistanceSq = minDistance * minDistance;

        const plateletX = platelet.position.x;
        const plateletY = platelet.position.y;

        // Find nearby stuck platelets (optimized with early exit)
        for (let i = 0; i < state.stuckPlatelets.length; i++) {
          const other = state.stuckPlatelets[i];
          if (other.body === platelet) continue;
          if (plateletData.fibrinConnections.includes(other.body.id)) continue;

          // Limit connections per other platelet too
          if (
            other.fibrinConnections.length >=
            CONFIG.fibrin.maxConnectionsPerPlatelet
          )
            continue;

          // Quick distance check using squared distance (avoid sqrt)
          const dx = other.body.position.x - plateletX;
          const dy = other.body.position.y - plateletY;
          const distSq = dx * dx + dy * dy;
          const searchRadiusSq = maxSearchRadius * maxSearchRadius;

          if (distSq < searchRadiusSq && distSq > minDistanceSq) {
            const dist = Math.sqrt(distSq);

            // Clasificar tipo de cuerda seg√∫n distancia y estabilidad
            let fibrinType = "thin"; // Por defecto peque√±a
            if (dist < 30 && fibrinStability > 0.7) {
              fibrinType = "thick"; // Gruesa: distancia < 30px y estabilidad alta
            } else if (dist < 60 && fibrinStability > 0.4) {
              fibrinType = "medium"; // Mediana: distancia 30-60px y estabilidad media
            }

            // Verificar restricciones seg√∫n condici√≥n
            const canFormThick = !conditionConfig.blockThickCords;
            const canFormMedium = !conditionConfig.blockMediumCords;
            const canFormThin = !conditionConfig.blockThinCords;

            if (
              (fibrinType === "thick" && !canFormThick) ||
              (fibrinType === "medium" && !canFormMedium) ||
              (fibrinType === "thin" && !canFormThin)
            ) {
              continue; // Saltar esta conexi√≥n si est√° bloqueada
            }

            const visualEffects =
              conditionConfig.visualEffects ||
              CONFIG.conditions.normal.visualEffects;

            // Create fibrin constraint with stability-based properties
            const fibrinConstraint = Constraint.create({
              bodyA: platelet,
              bodyB: other.body,
              stiffness: 0.9 * fibrinStability,
              damping: 0.3 * (2 - fibrinStability),
              length: dist * 0.8,
              render: { visible: false },
            });

            Composite.add(engine.world, fibrinConstraint);

            // Create physical body for fibrin barrier (thin rectangle)
            const midX = (platelet.position.x + other.body.position.x) / 2;
            const midY = (platelet.position.y + other.body.position.y) / 2;
            const angle = Math.atan2(
              other.body.position.y - platelet.position.y,
              other.body.position.x - platelet.position.x
            );

            // Create a thin rectangular body as barrier
            // Thickness depends on stability - weaker fibrin = thinner barrier
            const barrierThickness = 2 + fibrinStability * 3; // 2-5px range
            const fibrinBody = Bodies.rectangle(
              midX,
              midY,
              dist,
              barrierThickness,
              {
                isStatic: true, // Static so it acts as a solid barrier
                render: {
                  fillStyle: "transparent", // Invisible, we render it separately
                  visible: false,
                },
                label: "fibrinBarrier",
                restitution: 0.9 * fibrinStability, // Stability affects bounce
                friction: 0.1,
                collisionFilter: {
                  group: 0,
                  category: 0x0002, // Separate category for fibrin
                  mask: 0x0001, // Only collide with RBCs and WBCs
                },
                // Store stability for collision handling
                fibrinStability: fibrinStability,
              }
            );

            Body.setAngle(fibrinBody, angle);
            Composite.add(engine.world, fibrinBody);

            const fibrinData = {
              constraint: fibrinConstraint,
              pointA: platelet,
              pointB: other.body,
              body: fibrinBody,
              glowing: state.treatmentApplied,
              stability: fibrinStability,
              decayRate: conditionConfig.fibrinDecayRate || 0,
              visualColor: "#FFFFFF", // Blanco para las cuerdas (solo la malla horizontal es morada)
              opacity: visualEffects.fibrinOpacity || 1.0,
              fibrinType: fibrinType, // 'thick', 'medium', o 'thin'
              createdAt: Date.now(),
            };

            state.fibrinConstraints.push(fibrinData);
            state.fibrinBodies.push(fibrinBody);

            plateletData.fibrinConnections.push(other.body.id);
            plateletData.hasFibrin = true;
            other.fibrinConnections.push(platelet.id);
            other.hasFibrin = true;

            // Schedule fibrin decay if condition has decay rate
            if (
              conditionConfig.fibrinDecayRate > 0 &&
              !state.treatmentApplied
            ) {
              scheduleFibrinDecay(fibrinData, conditionConfig.fibrinDecayRate);
            }

            // Stop if we've reached the limit
            if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections)
              break;
          }
        }

        // Check if wound is sealed after forming new fibrin connection
        checkWoundSealed();
      }

      function scheduleFibrinDecay(fibrinData, decayRate) {
        // Decay fibrin over time based on decay rate
        const decayInterval = setInterval(() => {
          if (!state.fibrinConstraints.includes(fibrinData)) {
            clearInterval(decayInterval);
            return;
          }

          // Reduce stability over time
          fibrinData.stability -= decayRate * 0.1;

          if (fibrinData.stability <= 0.1 || Math.random() < decayRate) {
            // Remove unstable fibrin
            removeFibrinConnection(fibrinData);
            clearInterval(decayInterval);
          } else {
            // Update constraint properties based on stability
            fibrinData.constraint.stiffness = 0.9 * fibrinData.stability;
            fibrinData.constraint.damping = 0.3 * (2 - fibrinData.stability);
          }
        }, 2000); // Check every 2 seconds
      }

      function removeFibrinConnection(fibrinData) {
        // Remove from world
        Composite.remove(engine.world, fibrinData.constraint);
        if (fibrinData.body) {
          Composite.remove(engine.world, fibrinData.body);
          state.fibrinBodies = state.fibrinBodies.filter(
            (b) => b !== fibrinData.body
          );
        }

        // Remove from arrays
        state.fibrinConstraints = state.fibrinConstraints.filter(
          (f) => f !== fibrinData
        );

        // Update platelet connections
        const plateletA = state.stuckPlatelets.find(
          (p) => p.body === fibrinData.pointA
        );
        const plateletB = state.stuckPlatelets.find(
          (p) => p.body === fibrinData.pointB
        );

        if (plateletA) {
          plateletA.fibrinConnections = plateletA.fibrinConnections.filter(
            (id) => id !== fibrinData.pointB.id
          );
          plateletA.hasFibrin = plateletA.fibrinConnections.length > 0;
        }
        if (plateletB) {
          plateletB.fibrinConnections = plateletB.fibrinConnections.filter(
            (id) => id !== fibrinData.pointA.id
          );
          plateletB.hasFibrin = plateletB.fibrinConnections.length > 0;
        }
      }

      function checkWoundSealed() {
        if (state.hemostasisAchieved) return; // Already sealed

        const conditionConfig = CONFIG.conditions[state.condition];
        // En condiciones patol√≥gicas, requerir tratamiento para sellado completo
        if (conditionConfig.requiresTreatment && !state.treatmentApplied) {
          return; // No sellar sin tratamiento
        }

        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const woundCenterY = 29; // Y position where platelets stick

        // Find platelets on the left side of the wound (including anchor platelets)
        const leftSidePlatelets = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          // Include anchor platelets or platelets near left edge
          return (
            (p.isAnchor && px < woundLeft) ||
            (px < woundLeft + 30 && Math.abs(py - woundCenterY) < 20)
          );
        });

        // Find platelets on the right side of the wound (including anchor platelets)
        const rightSidePlatelets = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          // Include anchor platelets or platelets near right edge
          return (
            (p.isAnchor && px > woundRight) ||
            (px > woundRight - 30 && Math.abs(py - woundCenterY) < 20)
          );
        });

        if (leftSidePlatelets.length === 0 || rightSidePlatelets.length === 0) {
          return; // Need platelets on both sides
        }

        // Check if there's a path from left to right through fibrin connections
        for (let i = 0; i < leftSidePlatelets.length; i++) {
          const leftPlatelet = leftSidePlatelets[i];
          if (hasPathToRight(leftPlatelet, rightSidePlatelets, new Set())) {
            // Wound is sealed!
            state.hemostasisAchieved = true;
            state.clotPercentage = 100;
            // Capturar el momento del cierre de la herida (tiempo de simulaci√≥n acumulado)
            if (!state.woundClosureTime && state.startTime) {
              state.woundClosureTime = accumulatedSimulationTime / 1000; // Guardar tiempo de simulaci√≥n en segundos
            }
            const woundLabel = document.getElementById("wound-label");
            woundLabel.classList.add("healed");
            woundLabel.innerHTML = "‚úì Lesi√≥n Sellada";
            
            // Agregar efecto de pulsaci√≥n al bot√≥n de reiniciar
            const resetBtn = document.getElementById("reset-btn");
            if (resetBtn) {
              resetBtn.classList.add("hemostasis-pulse");
            }
            
            updateUI();
            return;
          }
        }
      }

      function hasPathToRight(currentPlatelet, rightSidePlatelets, visited) {
        // Check if current platelet is on the right side
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;

        if (currentPlatelet.body.position.x > woundRight - 20) {
          return true; // Reached right side
        }

        // Mark as visited
        visited.add(currentPlatelet.body.id);

        // Check all fibrin connections from this platelet
        for (let i = 0; i < state.fibrinConstraints.length; i++) {
          const fibrin = state.fibrinConstraints[i];
          let connectedPlatelet = null;

          // Find which platelet is connected to current one
          if (fibrin.pointA === currentPlatelet.body) {
            connectedPlatelet = state.stuckPlatelets.find(
              (p) => p.body === fibrin.pointB
            );
          } else if (fibrin.pointB === currentPlatelet.body) {
            connectedPlatelet = state.stuckPlatelets.find(
              (p) => p.body === fibrin.pointA
            );
          }

          if (connectedPlatelet && !visited.has(connectedPlatelet.body.id)) {
            // Check if this connection crosses the wound area
            const px1 = currentPlatelet.body.position.x;
            const px2 = connectedPlatelet.body.position.x;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;

            // Connection crosses wound if one point is left and other is right
            if (
              (px1 < woundLeft && px2 > woundRight) ||
              (px2 < woundLeft && px1 > woundRight)
            ) {
              // Direct crossing found
              return true;
            }

            // Continue searching through this connection
            if (
              hasPathToRight(connectedPlatelet, rightSidePlatelets, visited)
            ) {
              return true;
            }
          }
        }

        return false;
      }

      // ==================== RENDERIZADO DEL VASO SANGU√çNEO ====================

      // Cache para el fondo del vaso (se genera una vez y se reutiliza)
      let vesselBackgroundCache = null;

      function renderVesselBackground(event) {
        const ctx = render.context;
        const canvas = render.canvas;
        const width = canvas.width;
        const height = canvas.height;

        // Si el canvas cambi√≥ de tama√±o, regenerar el cache
        if (
          !vesselBackgroundCache ||
          vesselBackgroundCache.width !== width ||
          vesselBackgroundCache.height !== height
        ) {
          const cacheCanvas = document.createElement("canvas");
          cacheCanvas.width = width;
          cacheCanvas.height = height;
          const cacheCtx = cacheCanvas.getContext("2d");

          // Fondo base - gradiente que simula el interior de un vaso sangu√≠neo
          const baseGradient = cacheCtx.createLinearGradient(0, 0, 0, height);
          baseGradient.addColorStop(0, "#1a0505"); // Muy oscuro arriba (cerca de la pared)
          baseGradient.addColorStop(0.15, "#2a0a0a"); // Transici√≥n
          baseGradient.addColorStop(0.35, "#3d1515"); // Zona media-alta
          baseGradient.addColorStop(0.5, "#4a1a1a"); // Centro - m√°s iluminado (flujo sangu√≠neo)
          baseGradient.addColorStop(0.65, "#3d1515"); // Zona media-baja
          baseGradient.addColorStop(0.85, "#2a0a0a"); // Transici√≥n
          baseGradient.addColorStop(1, "#1a0505"); // Muy oscuro abajo (cerca de la pared)

          cacheCtx.fillStyle = baseGradient;
          cacheCtx.fillRect(0, 0, width, height);

          // Agregar gradiente radial central para simular el flujo de sangre (lumen)
          const centerGradient = cacheCtx.createRadialGradient(
            width * 0.4,
            height / 2,
            0,
            width * 0.4,
            height / 2,
            Math.max(width, height) * 0.6
          );
          centerGradient.addColorStop(0, "rgba(139, 30, 30, 0.25)"); // Rojo oscuro en el centro
          centerGradient.addColorStop(0.3, "rgba(100, 20, 20, 0.15)");
          centerGradient.addColorStop(0.6, "rgba(60, 10, 10, 0.08)");
          centerGradient.addColorStop(1, "rgba(0, 0, 0, 0)");

          cacheCtx.fillStyle = centerGradient;
          cacheCtx.fillRect(0, 0, width, height);

          // Agregar efecto de profundidad con sombras en los bordes
          const edgeShadow = cacheCtx.createLinearGradient(0, 0, 0, height);
          edgeShadow.addColorStop(0, "rgba(0, 0, 0, 0.5)");
          edgeShadow.addColorStop(0.1, "rgba(0, 0, 0, 0.1)");
          edgeShadow.addColorStop(0.9, "rgba(0, 0, 0, 0.1)");
          edgeShadow.addColorStop(1, "rgba(0, 0, 0, 0.5)");

          cacheCtx.fillStyle = edgeShadow;
          cacheCtx.fillRect(0, 0, width, height);

          // L√≠neas horizontales sutiles para simular el flujo laminar de la sangre
          cacheCtx.strokeStyle = "rgba(80, 20, 20, 0.08)";
          cacheCtx.lineWidth = 1;
          for (let y = 30; y < height - 30; y += 8) {
            cacheCtx.beginPath();
            // L√≠neas ligeramente onduladas
            cacheCtx.moveTo(0, y);
            for (let x = 0; x < width; x += 50) {
              const wave = Math.sin(x * 0.02 + y * 0.1) * 1.5;
              cacheCtx.lineTo(x, y + wave);
            }
            cacheCtx.stroke();
          }

          vesselBackgroundCache = cacheCanvas;
        }

        // Dibujar el fondo desde el cache (muy r√°pido)
        ctx.drawImage(vesselBackgroundCache, 0, 0);
      }

      function renderVesselWalls(event) {
        const ctx = render.context;
        const canvas = render.canvas;
        const width = canvas.width;
        const height = canvas.height;
        const { thickness } = CONFIG.wall;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        ctx.save();

        // ========== PARED INFERIOR (Endotelio vascular) ==========
        const bottomY = height - thickness;

        // Capa 1: Adventitia (tejido conectivo externo) - m√°s oscuro
        const adventitiaGradient = ctx.createLinearGradient(
          0,
          height - thickness,
          0,
          height
        );
        adventitiaGradient.addColorStop(0, "#2d1a1a");
        adventitiaGradient.addColorStop(0.3, "#3d2222");
        adventitiaGradient.addColorStop(0.7, "#4a2828");
        adventitiaGradient.addColorStop(1, "#3d2222");

        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(0, height - thickness, width, thickness);

        // Capa 2: Media (m√∫sculo liso) - tono medio
        const mediaGradient = ctx.createLinearGradient(
          0,
          height - thickness,
          0,
          height - thickness * 0.4
        );
        mediaGradient.addColorStop(0, "#5a3535");
        mediaGradient.addColorStop(0.5, "#6b4040");
        mediaGradient.addColorStop(1, "#7a4a4a");

        ctx.fillStyle = mediaGradient;
        ctx.fillRect(0, height - thickness, width, thickness * 0.6);

        // Capa 3: Intima/Endotelio (superficie interior) - m√°s rosado/brillante
        const intimaGradient = ctx.createLinearGradient(
          0,
          height - thickness,
          0,
          height - thickness * 0.7
        );
        intimaGradient.addColorStop(0, "#8b5555");
        intimaGradient.addColorStop(0.3, "#a06666");
        intimaGradient.addColorStop(0.7, "#b87777");
        intimaGradient.addColorStop(1, "#c98888");

        ctx.fillStyle = intimaGradient;
        ctx.fillRect(0, height - thickness, width, thickness * 0.3);

        // Brillo sutil en el borde interior (superficie del endotelio)
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, height - thickness);
        ctx.lineTo(width, height - thickness);
        ctx.stroke();

        // Textura del tejido - fibras horizontales
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = 1;
        for (let y = height - thickness + 3; y < height - 2; y += 4) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        // ========== PARED SUPERIOR IZQUIERDA ==========
        const topY = 0;

        // Adventitia
        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(0, 0, woundLeft, thickness);

        // Media
        const topMediaGradient = ctx.createLinearGradient(
          0,
          thickness * 0.4,
          0,
          thickness
        );
        topMediaGradient.addColorStop(0, "#7a4a4a");
        topMediaGradient.addColorStop(0.5, "#6b4040");
        topMediaGradient.addColorStop(1, "#5a3535");

        ctx.fillStyle = topMediaGradient;
        ctx.fillRect(0, thickness * 0.4, woundLeft, thickness * 0.6);

        // Intima
        const topIntimaGradient = ctx.createLinearGradient(
          0,
          thickness * 0.7,
          0,
          thickness
        );
        topIntimaGradient.addColorStop(0, "#c98888");
        topIntimaGradient.addColorStop(0.3, "#b87777");
        topIntimaGradient.addColorStop(0.7, "#a06666");
        topIntimaGradient.addColorStop(1, "#8b5555");

        ctx.fillStyle = topIntimaGradient;
        ctx.fillRect(0, thickness * 0.7, woundLeft, thickness * 0.3);

        // Brillo del endotelio
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, thickness);
        ctx.lineTo(woundLeft, thickness);
        ctx.stroke();

        // Textura
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = 1;
        for (let y = 3; y < thickness - 2; y += 4) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(woundLeft, y);
          ctx.stroke();
        }

        // ========== PARED SUPERIOR DERECHA ==========
        // Adventitia
        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(woundRight, 0, width - woundRight, thickness);

        // Media
        ctx.fillStyle = topMediaGradient;
        ctx.fillRect(
          woundRight,
          thickness * 0.4,
          width - woundRight,
          thickness * 0.6
        );

        // Intima
        ctx.fillStyle = topIntimaGradient;
        ctx.fillRect(
          woundRight,
          thickness * 0.7,
          width - woundRight,
          thickness * 0.3
        );

        // Brillo del endotelio
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(woundRight, thickness);
        ctx.lineTo(width, thickness);
        ctx.stroke();

        // Textura
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = 1;
        for (let y = 3; y < thickness - 2; y += 4) {
          ctx.beginPath();
          ctx.moveTo(woundRight, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        // ========== BORDES DE LA HERIDA ==========
        // Renderizar los bordes de la herida como tejido da√±ado
        const woundEdgeWidth = 6;

        // Borde izquierdo de la herida
        const woundEdgeGradient = ctx.createLinearGradient(
          woundLeft - woundEdgeWidth,
          0,
          woundLeft,
          0
        );
        woundEdgeGradient.addColorStop(0, "#c98888");
        woundEdgeGradient.addColorStop(0.3, "#d46666");
        woundEdgeGradient.addColorStop(0.7, "#e55555");
        woundEdgeGradient.addColorStop(1, "#ff6666");

        ctx.fillStyle = woundEdgeGradient;
        ctx.fillRect(
          woundLeft - woundEdgeWidth / 2,
          0,
          woundEdgeWidth,
          thickness + 5
        );

        // Borde derecho de la herida
        const woundEdgeGradientRight = ctx.createLinearGradient(
          woundRight,
          0,
          woundRight + woundEdgeWidth,
          0
        );
        woundEdgeGradientRight.addColorStop(0, "#ff6666");
        woundEdgeGradientRight.addColorStop(0.3, "#e55555");
        woundEdgeGradientRight.addColorStop(0.7, "#d46666");
        woundEdgeGradientRight.addColorStop(1, "#c98888");

        ctx.fillStyle = woundEdgeGradientRight;
        ctx.fillRect(
          woundRight - woundEdgeWidth / 2,
          0,
          woundEdgeWidth,
          thickness + 5
        );

        // Efecto de "sangrado" en los bordes de la herida
        ctx.strokeStyle = "rgba(255, 80, 80, 0.6)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(woundLeft - 1, 0);
        ctx.lineTo(woundLeft - 1, thickness + 8);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(woundRight + 1, 0);
        ctx.lineTo(woundRight + 1, thickness + 8);
        ctx.stroke();

        // Brillo/reflejo en los bordes de la herida
        ctx.strokeStyle = "rgba(255, 150, 150, 0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(woundLeft - 2, 0);
        ctx.lineTo(woundLeft - 2, thickness + 6);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(woundRight + 2, 0);
        ctx.lineTo(woundRight + 2, thickness + 6);
        ctx.stroke();

        ctx.restore();
      }

      function renderFibrin(event) {
        const ctx = render.context;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const adhesionLineY = 23; // Centro del √°rea de adhesi√≥n (debe coincidir con el √°rea de adhesi√≥n)
        const adhesionZoneHalfWidth = 12; // Mitad del ancho del √°rea de adhesi√≥n

        // Render ointment layer when treatment is applied - ultra simple for performance
        if (state.showOintment) {
          ctx.fillStyle = "rgba(117, 35, 120, 0.35)";
          ctx.fillRect(
            woundLeft,
            adhesionLineY - adhesionZoneHalfWidth,
            woundWidth,
            adhesionZoneHalfWidth * 2
          );
        }

        // Calcular opacidad de la malla morada basada en densidad de plaquetas pegadas en el √°rea de adhesi√≥n
        const stuckPlateletsInWound = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          return (
            px >= woundLeft - 20 &&
            px <= woundRight + 20 &&
            py >= adhesionLineY - adhesionZoneHalfWidth &&
            py <= adhesionLineY + adhesionZoneHalfWidth
          );
        }).length;

        const maxPlatelets = 20; // M√°ximo esperado de plaquetas en la herida
        // La malla morada empieza muy transparente (0.05) y se opaca progresivamente hasta 0.9
        const meshOpacity = Math.min(
          0.9,
          0.05 + (stuckPlateletsInWound / maxPlatelets) * 0.85
        );

        // √Årea de la malla morada coincide con el √°rea de adhesi√≥n
        const meshTopY = adhesionLineY - adhesionZoneHalfWidth;
        const meshHeight = adhesionZoneHalfWidth * 2; // Altura total del √°rea de adhesi√≥n

        // Renderizar malla morada horizontal en la zona de adhesi√≥n que se opaca progresivamente
        // Solo esta √°rea horizontal es morada - las cuerdas son verdes
        if (state.fibrinFormationStarted && stuckPlateletsInWound > 0) {
          ctx.fillStyle = `rgba(117, 35, 120, ${meshOpacity})`; // Morado #752378
          ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
        }

        // Overlay verde cuando est√° sellada
        if (state.hemostasisAchieved) {
          ctx.fillStyle = "rgba(34, 197, 94, 0.3)"; // Verde semitransparente
          ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
        }

        // Render fibrin connections (cuerdas) - optimized for performance
        if (state.fibrinConstraints.length > 0) {
          ctx.save(); // Guardar estado del contexto antes de dibujar cuerdas verdes

          for (let i = 0; i < state.fibrinConstraints.length; i++) {
            const fibrin = state.fibrinConstraints[i];
            const pointA = fibrin.pointA.position;
            const pointB = fibrin.pointB.position;

            // Only draw if both points are still valid
            if (pointA && pointB) {
              const fibrinType = fibrin.fibrinType || "thin";
              let lineWidth, opacity;

              // Configurar grosor y opacidad seg√∫n tipo de cuerda
              switch (fibrinType) {
                case "thick":
                  lineWidth = 7; // Aumentado de 5 a 7px
                  opacity = 0.9;
                  break;
                case "medium":
                  lineWidth = 4; // Aumentado de 3 a 4px
                  opacity = 0.6;
                  break;
                case "thin":
                default:
                  lineWidth = 2; // Aumentado de 1.5 a 2px
                  opacity = 0.4;
                  break;
              }

              // Ajustar opacidad seg√∫n estabilidad
              opacity *= fibrin.stability || 1.0;

              // Color verde para las cuerdas (solo la malla horizontal es morada)
              ctx.strokeStyle = `rgba(34, 197, 94, ${opacity * 0.8})`; // Verde #22C55E con opacidad
              ctx.lineWidth = lineWidth;

              ctx.beginPath();
              ctx.moveTo(pointA.x, pointA.y);
              ctx.lineTo(pointB.x, pointB.y);
              ctx.stroke();
            }
          }

          ctx.restore(); // Restaurar estado del contexto despu√©s de dibujar cuerdas blancas
        }
      }

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16),
            }
          : { r: 0, g: 230, b: 118 };
      }

      function renderVWF(event) {
        const ctx = render.context;

        // Verificar si debe mostrar vWF (cemento entre plaquetas)
        const conditionConfig = CONFIG.conditions[state.condition];
        const shouldShowVWF =
          state.condition === "normal" ||
          state.treatmentApplied ||
          (state.condition === "vwd" && state.treatmentApplied);

        if (!shouldShowVWF || state.stuckPlatelets.length < 2) {
          return; // No mostrar vWF si no hay vWF o menos de 2 plaquetas
        }

        // Dibujar l√≠neas verdes cortas (cemento) entre plaquetas pegadas que est√°n cerca
        const maxVWFDistance = 12; // Distancia m√°xima para mostrar conexi√≥n vWF
        const maxVWFDistanceSq = maxVWFDistance * maxVWFDistance;

        // Asegurar que el color verde se aplique correctamente
        ctx.save(); // Guardar estado del contexto

        // Usar rgba para asegurar que el color verde se aplique correctamente
        ctx.strokeStyle = "rgba(34, 197, 94, 1.0)"; // Verde #22C55E en formato rgba
        ctx.lineWidth = 1.5;
        ctx.lineCap = "round";
        ctx.globalAlpha = 1.0; // Asegurar opacidad completa para el verde

        // Dibujar l√≠neas entre plaquetas cercanas
        for (let i = 0; i < state.stuckPlatelets.length; i++) {
          const plateletA = state.stuckPlatelets[i];
          if (!plateletA.body) continue;

          const posA = plateletA.body.position;

          for (let j = i + 1; j < state.stuckPlatelets.length; j++) {
            const plateletB = state.stuckPlatelets[j];
            if (!plateletB.body) continue;

            const posB = plateletB.body.position;
            const dx = posB.x - posA.x;
            const dy = posB.y - posA.y;
            const distSq = dx * dx + dy * dy;

            // Solo dibujar si est√°n cerca (como cemento entre piedras adyacentes)
            if (distSq < maxVWFDistanceSq && distSq > 4) {
              const dist = Math.sqrt(distSq);
              // Opacidad basada en distancia (m√°s opaco cuanto m√°s cerca)
              const opacity = 0.7 + (1.0 - dist / maxVWFDistance) * 0.3; // Entre 0.7 y 1.0

              // Re-establecer el color verde antes de cada l√≠nea para asegurar que siempre sea verde
              ctx.strokeStyle = `rgba(34, 197, 94, ${opacity})`; // Verde con opacidad variable
              ctx.beginPath();
              ctx.moveTo(posA.x, posA.y);
              ctx.lineTo(posB.x, posB.y);
              ctx.stroke();
            }
          }
        }

        ctx.restore(); // Restaurar estado del contexto
      }

      function renderParticlesCustom(event) {
        const ctx = render.context;

        // Renderizar todas las part√≠culas con estilo personalizado (highlights, sombras, formas)
        // Renderizar solo plaquetas, gl√≥bulos rojos y gl√≥bulos blancos
        state.allBodies.forEach((body) => {
          if (
            !body.label ||
            (body.label !== "platelet" &&
              body.label !== "rbc" &&
              body.label !== "wbc")
          )
            return;

          const x = body.position.x;
          const y = body.position.y;
          const angle = body.angle;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);

          if (body.label === "rbc") {
            // Gl√≥bulo rojo: ovalado con highlight y sombra
            const radiusX = 6;
            const radiusY = 4.5; // M√°s ancho que alto para efecto ovalado

            // Sombra/contorno oscuro
            ctx.beginPath();
            ctx.ellipse(0, 0, radiusX + 0.5, radiusY + 0.5, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(139, 0, 0, 0.3)"; // Rojo muy oscuro para sombra
            ctx.fill();

            // Cuerpo principal rojo oscuro
            ctx.beginPath();
            ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
            ctx.fillStyle = "#B91C1C"; // Rojo oscuro
            ctx.fill();

            // Highlight peque√±o cerca del centro (superior izquierda)
            ctx.beginPath();
            ctx.arc(-1.5, -1, 1.2, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 200, 200, 0.8)"; // Rojo claro/rosa para highlight
            ctx.fill();
          } else if (body.label === "wbc") {
            // Gl√≥bulo blanco: circular con highlight brillante y contorno azul oscuro
            const radius = 10;

            // Contorno azul oscuro para profundidad
            ctx.beginPath();
            ctx.arc(0, 0, radius + 1, 0, Math.PI * 2);
            ctx.strokeStyle = "#4A90E2"; // Azul m√°s oscuro para contorno
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Cuerpo principal azul claro
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#87CEEB"; // Azul claro
            ctx.fill();

            // Highlight brillante blanco en cuadrante superior izquierdo
            const gradient = ctx.createRadialGradient(-3, -3, 0, -3, -3, 4);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.95)"); // Blanco brillante en el centro
            gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.6)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)"); // Transparente hacia afuera

            ctx.beginPath();
            ctx.arc(-3, -3, 4, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Punto de highlight m√°s peque√±o y brillante
            ctx.beginPath();
            ctx.arc(-3, -3, 1.5, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 1)"; // Blanco s√≥lido
            ctx.fill();
          } else if (body.label === "platelet") {
            // Plaqueta: circular gris con highlight sutil
            const radius = 4;

            // Sombra sutil
            ctx.beginPath();
            ctx.arc(0, 0, radius + 0.3, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(100, 100, 100, 0.2)"; // Gris oscuro para sombra
            ctx.fill();

            // Cuerpo principal gris
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#808080"; // Gris medio
            ctx.fill();

            // Highlight peque√±o en cuadrante superior izquierdo
            ctx.beginPath();
            ctx.arc(-1.2, -1.2, 0.8, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(220, 220, 220, 0.7)"; // Gris claro para highlight
            ctx.fill();
          }

          ctx.restore();
        });
      }

      function calculateClotPercentage() {
        // Si la herida est√° sellada (red de fibrina de izquierda a derecha y no pasan part√≠culas), 100%
        if (state.hemostasisAchieved) {
          state.clotPercentage = 100;
          return;
        }

        const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
        const woundWidth = CONFIG.wound.width;
        const woundCenterY = 29; // Y position where platelets stick

        // Optimized coverage calculation
        const segments = 20; // Reduced from 30 for better performance
        const segmentWidth = woundWidth / segments;
        let coveredSegments = 0;
        const coverageThreshold = 15 * 15; // Squared distance for comparison

        // Pre-filter platelets that are actually in the wound area (exclude anchor platelets)
        const relevantPlatelets = state.stuckPlatelets.filter((p) => {
          // Excluir plaquetas anchor del c√°lculo
          if (p.isAnchor) return false;

          const px = p.body.position.x;
          const py = p.body.position.y;
          return (
            px >= woundLeft - 20 &&
            px <= woundLeft + woundWidth + 20 &&
            py >= woundCenterY - 15 &&
            py <= woundCenterY + 15
          );
        });

        for (let i = 0; i < segments; i++) {
          const segmentX = woundLeft + (i + 0.5) * segmentWidth;

          // Check if any stuck platelet covers this segment (optimized)
          const covered = relevantPlatelets.some((p) => {
            const dx = p.body.position.x - segmentX;
            const dy = p.body.position.y - woundCenterY;
            return dx * dx + dy * dy < coverageThreshold;
          });

          if (covered) coveredSegments++;
        }

        state.clotPercentage = Math.min(
          100,
          Math.round((coveredSegments / segments) * 100)
        );

        // Check if wound is sealed by fibrin network crossing left to right
        // Esto detecta cuando la red de fibrina va de izquierda a derecha
        checkWoundSealed();

        // Si est√° sellada, asegurar que el porcentaje sea 100%
        if (state.hemostasisAchieved) {
          state.clotPercentage = 100;
        }
      }

      function updateUI() {
        // Actualizar m√©tricas con animaci√≥n
        const bloodLossEl = document.getElementById("blood-loss");
        const clotPercentageEl = document.getElementById("clot-percentage");

        if (bloodLossEl) {
          const oldValue = parseInt(bloodLossEl.textContent) || 0;
          const newValue = state.bloodLoss;
          bloodLossEl.textContent = newValue;
          if (oldValue !== newValue) {
            bloodLossEl.classList.add("updated");
            setTimeout(() => bloodLossEl.classList.remove("updated"), 400);
          }
        }

        if (clotPercentageEl) {
          const oldValue = parseInt(clotPercentageEl.textContent) || 0;
          const newValue = state.clotPercentage;
          clotPercentageEl.textContent = newValue + "%";
          if (oldValue !== newValue) {
            clotPercentageEl.classList.add("updated");
            setTimeout(() => clotPercentageEl.classList.remove("updated"), 400);
          }
        }

        // Anuncios para lectores de pantalla
        if (state.hemostasisAchieved) {
          // Anunciar hemostasia lograda solo una vez
          if (!state.lastAnnouncedHemostasis) {
            ScreenReaderAnnouncements.announceUrgent(
              "¬°Hemostasia lograda! La herida se ha cerrado completamente."
            );
            state.lastAnnouncedHemostasis = true;
          }
        } else if (state.treatmentApplied) {
          // Anunciar tratamiento aplicado solo una vez
          if (!state.lastAnnouncedTreatment) {
            ScreenReaderAnnouncements.announce(
              `Tratamiento aplicado para condici√≥n ${CONFIG.conditions[state.condition]?.name || 'actual'}`
            );
            state.lastAnnouncedTreatment = true;
          }
        }

        // Actualizar m√©tricas avanzadas solo si la herida no est√° cerrada
        if (!state.hemostasisAchieved) {
          updateAdvancedMetrics();
          updateCharts();
        }

        // Actualizar descripci√≥n textual para lectores de pantalla
        updateSimulationDescription();

        // SISTEMA DE FEEDBACK CONTEXTUAL - Verificar y mostrar feedbacks relevantes
        ContextualFeedback.check(state);
      }

      function updateAdvancedMetrics() {
        // Calcular tiempo de simulaci√≥n (ajustado por timeScale)
        const simulationTimeSeconds = accumulatedSimulationTime / 1000;

        // Tiempo hasta cierre de herida
        const el = document.getElementById("first-adhesion-time");
        if (
          state.hemostasisAchieved &&
          state.woundClosureTime !== null &&
          state.startTime
        ) {
          // Mostrar el tiempo de simulaci√≥n cuando se cerr√≥ la herida (ya est√° en segundos de simulaci√≥n)
          if (el) el.textContent = state.woundClosureTime.toFixed(1) + "s";
        } else if (state.startTime && !state.hemostasisAchieved) {
          // Mostrar tiempo de simulaci√≥n transcurrido mientras la herida est√° abierta
          if (el) el.textContent = simulationTimeSeconds.toFixed(1) + "s";
        } else {
          // Sin datos a√∫n
          if (el) el.textContent = "--";
        }

        // Detener actualizaci√≥n de otras m√©tricas si la herida est√° cerrada
        if (state.hemostasisAchieved) return;

        // Velocidad de formaci√≥n de fibrina (conexiones por minuto)
        if (simulationTimeSeconds > 0) {
          const fibrinPerMinute =
            (state.fibrinConstraints.length / simulationTimeSeconds) * 60;
          const el = document.getElementById("fibrin-rate");
          if (el) el.textContent = fibrinPerMinute.toFixed(1) + "/min";
        }

        // Densidad del co√°gulo (plaquetas por √°rea de herida)
        const woundArea = CONFIG.wound.width * CONFIG.wound.height;
        const clotDensity =
          woundArea > 0
            ? ((state.stuckPlatelets.length / woundArea) * 1000).toFixed(1)
            : 0;
        const el1 = document.getElementById("clot-density");
        if (el1) el1.textContent = clotDensity;

        // Tasa de agregaci√≥n (plaquetas pegadas / total spawnadas)
        const aggregationRate =
          state.totalPlateletsSpawned > 0
            ? (
                (state.stuckPlatelets.length / state.totalPlateletsSpawned) *
                100
              ).toFixed(1)
            : 0;
        const el2 = document.getElementById("aggregation-rate");
        if (el2) el2.textContent = aggregationRate + "%";
      }

      // Gr√°ficos en tiempo real usando Canvas
      const chartConfigs = {
        clot: { color: "#752378", label: "Cierre (%)" },
        bloodLoss: { color: "#DC2626", label: "P√©rdida" },
        fibrin: { color: "#752378", label: "Conexiones" },
      };

      function initCharts() {
        // Esperar a que los elementos existan
        setTimeout(() => {
          const chartIds = ["clot-chart", "blood-loss-chart", "fibrin-chart"];
          chartIds.forEach((chartId) => {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;
            const ctx = canvas.getContext("2d");
            if (canvas.offsetWidth > 0 && canvas.offsetHeight > 0) {
              canvas.width = canvas.offsetWidth * 2; // Retina display
              canvas.height = canvas.offsetHeight * 2;
              ctx.scale(2, 2);
            }
          });
        }, 100);
      }

      function updateCharts() {
        // A√±adir nuevos datos al historial solo si la simulaci√≥n est√° corriendo y no est√° cerrada
        if (
          state.simulationRunning &&
          !state.hemostasisAchieved &&
          state.startTime
        ) {
          // Usar tiempo de simulaci√≥n (ajustado por timeScale) en lugar de tiempo real
          const simulationTimeSeconds = accumulatedSimulationTime / 1000;

          // A√±adir datos al historial (cada segundo de simulaci√≥n)
          const lastTime =
            state.history.time[state.history.time.length - 1] || 0;
          if (simulationTimeSeconds - lastTime >= 1) {
            // Obtener p√©rdida sangu√≠nea directamente del DOM
            const bloodLossEl = document.getElementById("blood-loss");
            const currentBloodLoss = bloodLossEl
              ? parseInt(bloodLossEl.textContent) || 0
              : 0;

            state.history.time.push(simulationTimeSeconds);
            state.history.clotPercentage.push(state.clotPercentage);
            state.history.bloodLoss.push(currentBloodLoss);
            state.history.fibrinConnections.push(
              state.fibrinConstraints.length
            );
            state.history.stuckPlatelets.push(state.stuckPlatelets.length);

            // Limitar historial a √∫ltimos 60 segundos
            const maxHistory = 60;
            if (state.history.time.length > maxHistory) {
              state.history.time.shift();
              state.history.clotPercentage.shift();
              state.history.bloodLoss.shift();
              state.history.fibrinConnections.shift();
              state.history.stuckPlatelets.shift();
            }
          }
        }

        // Preparar datos para gr√°ficos con el valor actual a√±adido
        let clotData = [...state.history.clotPercentage];
        let bloodLossData = [...state.history.bloodLoss];
        let fibrinData = [...state.history.fibrinConnections];

        // Si la simulaci√≥n est√° corriendo, a√±adir el valor actual al final para actualizaci√≥n en tiempo real
        if (
          state.simulationRunning &&
          !state.hemostasisAchieved &&
          state.startTime
        ) {
          clotData.push(state.clotPercentage);

          // Obtener p√©rdida sangu√≠nea actual del DOM
          const bloodLossEl = document.getElementById("blood-loss");
          const currentBloodLoss = bloodLossEl
            ? parseInt(bloodLossEl.textContent) || 0
            : 0;
          bloodLossData.push(currentBloodLoss);

          fibrinData.push(state.fibrinConstraints.length);
        }

        // Dibujar gr√°ficos siempre con datos actualizados en tiempo real
        drawChart("clot-chart", clotData, chartConfigs.clot, 100);
        drawChart(
          "blood-loss-chart",
          bloodLossData,
          chartConfigs.bloodLoss,
          null
        );
        drawChart("fibrin-chart", fibrinData, chartConfigs.fibrin, null);
      }

      function drawChart(chartId, data, config, maxValue) {
        const canvas = document.getElementById(chartId);
        if (!canvas) {
          console.warn("Canvas not found:", chartId);
          return;
        }

        // Asegurar que el canvas est√© inicializado
        if (canvas.width === 0 || canvas.height === 0) {
          const ctx = canvas.getContext("2d");
          canvas.width = canvas.offsetWidth * 2 || 200;
          canvas.height = canvas.offsetHeight * 2 || 140;
          ctx.scale(2, 2);
        }

        const ctx = canvas.getContext("2d");
        const width = canvas.width / 2;
        const height = canvas.height / 2;

        // Limpiar canvas
        ctx.clearRect(0, 0, width, height);

        // Si no hay datos, mostrar gr√°fico vac√≠o con mensaje
        if (!data || data.length === 0) {
          ctx.fillStyle = "#94A3B8";
          ctx.font = "10px Inter";
          ctx.textAlign = "center";
          ctx.fillText("Sin datos", width / 2, height / 2);
          return;
        }

        // Encontrar valores min/max
        const dataMax = maxValue !== null ? maxValue : Math.max(...data, 1);
        const dataMin = 0;
        const range = dataMax - dataMin || 1;

        // Configurar estilo
        ctx.strokeStyle = config.color;
        ctx.fillStyle = config.color;
        ctx.lineWidth = 2;

        // Dibujar l√≠nea
        ctx.beginPath();
        const stepX = width / Math.max(data.length - 1, 1);

        data.forEach((value, index) => {
          const x = index * stepX;
          const y = height - ((value - dataMin) / range) * height;

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        // Relleno bajo la l√≠nea
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.globalAlpha = 0.2;
        ctx.fill();
        ctx.globalAlpha = 1.0;

        // Etiquetas
        ctx.fillStyle = "#64748B";
        ctx.font = "10px Inter";
        ctx.textAlign = "right";
        ctx.fillText(dataMax.toFixed(0), width - 4, 12);
        ctx.textAlign = "left";
        ctx.fillText(config.label, 4, 12);
      }

      // Controles de velocidad
      function setupSpeedControls() {
        const speedSlider = document.getElementById("speed-slider");
        const speedValue = document.getElementById("speed-value");

        if (speedSlider) {
          // Ajustar timeScale: cuando el slider est√° en 1.0, la velocidad real es 0.75
          // Esto hace que la velocidad "normal" (1x) sea m√°s lenta
          const baseSpeed = 0.75;
          state.timeScale = baseSpeed;
          if (speedValue) speedValue.textContent = "1x";

          speedSlider.addEventListener("input", (e) => {
            const sliderValue = parseFloat(e.target.value);
            state.timeScale = baseSpeed * sliderValue;
            if (speedValue) speedValue.textContent = sliderValue + "x";

            // Reiniciar el spawn para aplicar el nuevo intervalo
            if (state.simulationRunning && !state.isPaused) {
              startParticleSpawning();
            }
          });
        }
      }

      // Panel educativo
      function setupEducationalPanel() {
        const toggle = document.getElementById("educational-toggle");
        const panel = document.getElementById("educational-panel");
        const arrow = document.getElementById("educational-arrow");

        if (toggle) {
          toggle.addEventListener("click", () => {
            panel.classList.toggle("expanded");
            if (arrow)
              arrow.textContent = panel.classList.contains("expanded")
                ? "‚ñ≤"
                : "‚ñº";
          });
        }
        
        // No actualizar contenido educativo inicial - quedar√° vac√≠o hasta seleccionar condici√≥n
      }

      // Funci√≥n para actualizar el contenido educativo completo
      function updateEducationalContent() {
        // Obtener contenedor del panel educativo (mantener para compatibilidad)
        const panelContent = document.querySelector('.educational-panel-content');
        
        // Obtener contenedor de la nueva secci√≥n educativa
        const infoContent = document.getElementById('educational-info-content');
        
        // Si no hay ning√∫n contenedor, salir
        if (!panelContent && !infoContent) return;
        
        // Si no hay condici√≥n seleccionada, limpiar el contenido
        if (!state.condition) {
          if (infoContent) {
            infoContent.innerHTML = '';
          }
          if (panelContent) {
            panelContent.innerHTML = '';
          }
          return;
        }
        
        const conditionConfig = CONFIG.conditions[state.condition];
        const educationalContent = conditionConfig.educational || {};

        // Crear HTML con toda la informaci√≥n educativa
        let html = `
          <div class="educational-section">
            <h4>
              Condici√≥n Actual:
              <span id="current-condition-name">${conditionConfig.name}</span>
            </h4>
            <p id="current-condition-desc">
              ${conditionConfig.description}
            </p>
          </div>
        `;

        // Agregar informaci√≥n educativa expandida si est√° disponible
        if (educationalContent.overview) {
          html += `
            <div class="educational-section">
              <h4>üìñ Resumen</h4>
              <p>${educationalContent.overview}</p>
            </div>
          `;
        }

        if (educationalContent.pathophysiology) {
          html += `
            <div class="educational-section">
              <h4>üî¨ Fisiopatolog√≠a</h4>
              <p>${educationalContent.pathophysiology}</p>
            </div>
          `;
        }

        if (educationalContent.symptoms) {
          html += `
            <div class="educational-section">
              <h4>‚ö†Ô∏è S√≠ntomas</h4>
              <p>${educationalContent.symptoms}</p>
            </div>
          `;
        }

        if (educationalContent.causes) {
          html += `
            <div class="educational-section">
              <h4>üîç Causas</h4>
              <p>${educationalContent.causes}</p>
            </div>
          `;
        }

        if (educationalContent.treatment) {
          html += `
            <div class="educational-section">
              <h4>üíä Tratamiento</h4>
              <p>${educationalContent.treatment}</p>
            </div>
          `;
        }

        if (educationalContent.prognosis) {
          html += `
            <div class="educational-section">
              <h4>üìä Pron√≥stico</h4>
              <p>${educationalContent.prognosis}</p>
            </div>
          `;
        }

        if (educationalContent.clinicalNotes) {
          html += `
            <div class="educational-section">
              <h4>üìù Notas Cl√≠nicas</h4>
              <p>${educationalContent.clinicalNotes}</p>
            </div>
          `;
        }

        if (educationalContent.affectedFactors) {
          html += `
            <div class="educational-section">
              <h4>‚öôÔ∏è Factores Afectados</h4>
              <p>${educationalContent.affectedFactors}</p>
            </div>
          `;
        }

        if (educationalContent.cascadePathway) {
          html += `
            <div class="educational-section">
              <h4>üîÑ V√≠a de la Cascada</h4>
              <p>${educationalContent.cascadePathway}</p>
            </div>
          `;
        }

        // Agregar cascada de coagulaci√≥n general (siempre presente)
        html += `
          <div class="educational-section">
            <h4>ü©∏ Cascada de Coagulaci√≥n</h4>
            <p>
              La coagulaci√≥n sangu√≠nea es un proceso complejo que
              involucra m√∫ltiples factores:
            </p>
            <div class="coagulation-cascade">
              <div class="cascade-step">
                <div class="cascade-step-title">V√≠a Intr√≠nseca</div>
                <div>Factores XII, XI, IX, VIII</div>
              </div>
              <div class="cascade-step">
                <div class="cascade-step-title">V√≠a Extr√≠nseca</div>
                <div>Factor VII + Factor Tisular</div>
              </div>
              <div class="cascade-step">
                <div class="cascade-step-title">V√≠a Com√∫n</div>
                <div>Factores X, V, II (Trombina)</div>
              </div>
              <div class="cascade-step">
                <div class="cascade-step-title">
                  Formaci√≥n de Fibrina
                </div>
                <div>Fibrin√≥geno ‚Üí Fibrina</div>
              </div>
            </div>
          </div>
        `;

        // Agregar proceso de hemostasia general
        html += `
          <div class="educational-section">
            <h4>ü©π Proceso de Hemostasia</h4>
            <p>
              <strong>1. Vasoconstricci√≥n:</strong> Los vasos se
              contraen para reducir el flujo sangu√≠neo.
            </p>
            <p>
              <strong>2. Adhesi√≥n Plaquetaria:</strong> Las plaquetas se
              adhieren al col√°geno expuesto usando el factor von
              Willebrand.
            </p>
            <p>
              <strong>3. Agregaci√≥n Plaquetaria:</strong> Las plaquetas
              se unen entre s√≠ formando un tap√≥n primario.
            </p>
            <p>
              <strong>4. Coagulaci√≥n:</strong> La cascada de coagulaci√≥n
              forma fibrina que refuerza el tap√≥n.
            </p>
            <p>
              <strong>5. Retracci√≥n:</strong> El co√°gulo se contrae y
              estabiliza.
            </p>
          </div>
        `;

        // Actualizar el contenido del panel educativo (si existe)
        if (panelContent) {
          panelContent.innerHTML = html;
        }
        
        // Actualizar el contenido de la nueva secci√≥n educativa (si existe)
        if (infoContent) {
          infoContent.innerHTML = html;
        }
      }

      // Tooltips
      function setupTooltips() {
        const triggers = document.querySelectorAll(".tooltip-trigger");

        triggers.forEach((trigger) => {
          const tooltip = trigger.parentElement.querySelector(".tooltip");

          trigger.addEventListener("mouseenter", () => {
            if (tooltip) tooltip.classList.add("visible");
          });

          trigger.addEventListener("mouseleave", () => {
            if (tooltip) tooltip.classList.remove("visible");
          });
        });
      }

      function applyTreatment() {
        // Verificar que la simulaci√≥n se haya iniciado al menos una vez
        // (puede estar corriendo o pausada)
        if (!state.startTime) {
          if (typeof ScreenReaderAnnouncements !== 'undefined') {
            ScreenReaderAnnouncements.announce("Debes iniciar la simulaci√≥n antes de aplicar tratamiento");
          }
          return;
        }
        
        // Verificar que no se haya aplicado ya
        if (state.treatmentApplied) return;

        state.treatmentApplied = true;
        state.showOintment = true;

        // Marcar el paso 3 como completado
        // Actualizar wizard para marcar todos los pasos (1, 2 y 3) como completados
        document.querySelectorAll(".wizard-step").forEach((el, index) => {
          const stepNum = index + 1;
          el.classList.remove("active", "completed");
          if (stepNum <= 3) {
            el.classList.add("completed");
          }
        });
        state.currentStep = 3;

        // Show treatment indicator
        const indicator = document.getElementById("treatment-indicator");
        indicator.classList.add("visible");
        setTimeout(() => {
          indicator.classList.remove("visible");
        }, 2000);

        // Update button
        const btn = document.getElementById("treatment-btn");
        btn.classList.add("applied");
        btn.classList.remove("wizard-step-3-active"); // Remover efecto de aura pulsante
        btn.innerHTML = "‚úì Tratamiento Aplicado";
        btn.disabled = true;

        // Apply treatment effects based on condition
        const condition = CONFIG.conditions[state.condition];

        switch (state.condition) {
          case "hemophilia":
          case "hemophiliaSevere":
            // Factor VIII/IX replacement - enables fibrin formation
            applyFactorReplacement();
            break;

          case "vwd":
            // Desmopresina or vWF concentrate - improves platelet adhesion
            applyVWFReplacement();
            break;

          case "thrombocytopenia":
            // Platelet transfusion - increases platelet count
            applyPlateletTransfusion();
            break;

          case "thrombasthenia":
            // Platelet transfusion - provides functional platelets
            applyPlateletTransfusion();
            break;

          case "anticoagulated":
            // Vitamin K or PCC - reverses anticoagulation (similar a hemofilia)
            applyFactorReplacement();
            break;

          case "factorDeficiency":
            // Factor VII replacement - elimina el retraso de generaci√≥n
            // Las plaquetas ya pegadas forman fibrina inmediatamente
            state.stuckPlatelets.forEach((plateletData) => {
              if (!plateletData.hasFibrin) {
                setTimeout(() => tryFormFibrin(plateletData), 50);
                setTimeout(() => tryFormFibrin(plateletData), 150);
              }
            });
            // Eliminar retraso para futuras formaciones
            condition.fibrinFormationDelay = 0;
            break;

          default:
            // Generic treatment - improves all parameters
            applyGenericTreatment();
        }

        // For all conditions, try to form additional fibrin connections
        // Con tratamiento, intentar formar fibrina m√°s frecuentemente
        const retryInterval = state.treatmentApplied ? 100 : 200;
        const maxRetries = state.treatmentApplied ? 5 : 3;

        let retryCount = 0;
        const tryFormFibrinRepeatedly = () => {
          if (retryCount < maxRetries && !state.hemostasisAchieved) {
            state.stuckPlatelets.forEach((plateletData) => {
              tryFormFibrin(plateletData);
            });
            retryCount++;
            setTimeout(tryFormFibrinRepeatedly, retryInterval);
          }
        };

        setTimeout(tryFormFibrinRepeatedly, retryInterval);

        updateUI();
      }

      function applyFactorReplacement() {
        // Factor VIII/IX replacement for hemophilia/anticoagulated
        // Las plaquetas ya pegadas "disparan" instant√°neamente hilos verdes fuertes
        const condition = CONFIG.conditions[state.condition];

        // Form fibrin on all existing stuck platelets immediately
        state.stuckPlatelets.forEach((plateletData) => {
          if (!plateletData.hasFibrin) {
            // Intentar formar fibrina m√∫ltiples veces para asegurar conexiones
            setTimeout(() => tryFormFibrin(plateletData), 50);
            setTimeout(() => tryFormFibrin(plateletData), 150);
            setTimeout(() => tryFormFibrin(plateletData), 300);
          }
        });

        // Make all existing fibrin stable and glowing (verde fuerte)
        state.fibrinConstraints.forEach((f) => {
          f.glowing = true;
          f.stability = 1.0; // Fibrina fuerte
          f.decayRate = 0;
          f.visualColor = "#00E676"; // Verde s√≥lido
          f.opacity = 1.0;
          // Actualizar stiffness del constraint
          if (f.constraint) {
            f.constraint.stiffness = 0.9; // Stiffness fuerte
          }
        });
      }

      function applyVWFReplacement() {
        // Desmopresina or vWF concentrate for von Willebrand disease
        // Las plaquetas flotantes cambian sus propiedades f√≠sicas y empiezan a pegarse inmediatamente
        const condition = CONFIG.conditions[state.condition];

        // Cambiar propiedades f√≠sicas de todas las plaquetas flotantes
        state.allBodies.forEach((body) => {
          if (body.label === "platelet" && !body.isStuck) {
            // Cambiar restituci√≥n para que se peguen (reducir rebote)
            body.restitution = 0.5; // Rebote normal
            body.isSticky = true; // Permitir adhesi√≥n
            Body.setVelocity(body, {
              x: body.velocity.x * 0.8, // Reducir velocidad para facilitar adhesi√≥n
              y: body.velocity.y * 0.8,
            });
          }
        });

        // Update visual effects - platelets return to normal color
        state.stuckPlatelets.forEach((platelet) => {
          platelet.body.render.fillStyle = "#808080";
        });
      }

      function applyPlateletTransfusion() {
        // Platelet transfusion for thrombocytopenia/thrombasthenia
        const condition = CONFIG.conditions[state.condition];
        
        if (state.condition === "thrombocytopenia") {
          // Trombocitopenia: Inyecta una r√°faga ("bolus") de nuevas plaquetas al flujo
          const bolusCount = 20; // R√°faga de 20 plaquetas
          for (let i = 0; i < bolusCount; i++) {
            setTimeout(() => {
              createParticle("platelet");
            }, i * 50); // Espaciar ligeramente la creaci√≥n
          }
        } else if (state.condition === "thrombasthenia") {
          // Trombastenia: Las plaquetas flotantes cambian propiedades y empiezan a agregarse
          state.allBodies.forEach((body) => {
            if (body.label === "platelet" && !body.isStuck) {
              body.isSticky = true;
              // Permitir agregaci√≥n ahora
            }
          });
          // Tambi√©n aumentar ratio temporalmente para nuevas plaquetas funcionales
          const originalRatio = condition.plateletRatio;
          condition.plateletRatio = 0.30; // Normal
          setTimeout(() => {
            condition.plateletRatio = originalRatio;
          }, 10000);
        }
      }

      function reverseAnticoagulation() {
        // Vitamin K or Prothrombin Complex Concentrate (PCC)
        // Improves fibrin stability and formation
        state.fibrinConstraints.forEach((f) => {
          f.stability = Math.min(1.0, f.stability + 0.3);
          f.decayRate = 0;
          f.visualColor = "#00E676";
          f.opacity = 1.0;
        });
      }

      function applyGenericTreatment() {
        // Generic treatment - improves all parameters slightly
        state.fibrinConstraints.forEach((f) => {
          f.stability = Math.min(1.0, f.stability + 0.2);
          f.glowing = true;
        });
      }

      function setCondition(condition) {
        state.condition = condition;
        state.treatmentApplied = false;
        state.simulationRunning = false;

        // Update UI
        document.querySelectorAll(".condition-btn").forEach((btn) => {
          const isActive = btn.dataset.condition === condition;
          btn.classList.toggle("active", isActive);
          btn.setAttribute("aria-checked", isActive ? "true" : "false");
        });

        // Actualizar ARIA
        updateConditionARIA();

        // Actualizar panel educativo con informaci√≥n completa
        updateEducationalContent();

        // Reset simulation
        initSimulation();

        // Actualizar wizard - paso 2 (iniciar simulaci√≥n)
        updateWizardStep(2);

        // Habilitar bot√≥n de inicio
        const startBtn = document.getElementById("start-btn");
        const pauseBtn = document.getElementById("pause-btn");
        if (startBtn) {
          startBtn.disabled = false;
        }
        if (pauseBtn) {
          pauseBtn.disabled = true; // Deshabilitar pausa cuando no hay simulaci√≥n corriendo
        }
        
        // Deshabilitar bot√≥n de tratamiento hasta que se inicie la simulaci√≥n
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          treatmentBtn.disabled = true;
        }

        // Anunciar cambio de condici√≥n
        const conditionConfig = CONFIG.conditions[condition];
        ScreenReaderAnnouncements.announce(
          `Condici√≥n cambiada a: ${conditionConfig.name}`
        );
      }

      function toggleSimulation() {
        if (!state.simulationRunning) {
          // Iniciar simulaci√≥n
          state.simulationRunning = true;
          state.isPaused = false;
          state.startTime = Date.now();
          state.firstAdhesionTime = null;
          state.woundClosureTime = null;
          state.totalPlateletsSpawned = 0;
          state.history = {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          };
          // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
          lastPhysicsTime = 0;
          accumulatedTime = 0;

          // Asegurar que timeScale tenga un valor v√°lido
          if (!state.timeScale || state.timeScale <= 0) {
            state.timeScale = 1.0;
          }

          // Reiniciar el spawn para asegurar que funcione
          startParticleSpawning();

          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitar bot√≥n de inicio cuando est√° corriendo
          }
          if (pauseBtn) {
            pauseBtn.disabled = false; // Habilitar bot√≥n de pausa cuando est√° corriendo
          }
          
          // Habilitar bot√≥n de tratamiento cuando la simulaci√≥n est√° corriendo
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied) {
            treatmentBtn.disabled = false;
          }
          
          // Si el tratamiento ya se aplic√≥, marcar todos los pasos como completados
          // Si no, avanzar al paso 3
          if (state.treatmentApplied) {
            document.querySelectorAll(".wizard-step").forEach((el, index) => {
              const stepNum = index + 1;
              el.classList.remove("active", "completed");
              if (stepNum <= 3) {
                el.classList.add("completed");
              }
            });
            state.currentStep = 3;
          } else {
            updateWizardStep(3);
          }
        } else {
          // Pausar simulaci√≥n
          state.simulationRunning = false;
          state.isPaused = true;
          // No usar Runner.stop() - usamos nuestro propio loop
          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = false; // Habilitar bot√≥n de inicio cuando est√° pausada
          }
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar bot√≥n de pausa cuando est√° pausada
          }
          
          // El bot√≥n de tratamiento permanece habilitado cuando la simulaci√≥n est√° pausada
          // (siempre que se haya iniciado al menos una vez y no se haya aplicado ya)
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied && state.startTime) {
            treatmentBtn.disabled = false;
          }
        }
      }

      function updateWizardStep(step) {
        state.currentStep = step;
        document.querySelectorAll(".wizard-step").forEach((el, index) => {
          const stepNum = index + 1;
          el.classList.remove("active", "completed");
          if (stepNum < step) {
            el.classList.add("completed");
          } else if (stepNum === step) {
            el.classList.add("active");
          }
        });
        
        // Agregar/remover efecto de aura en condiciones cuando el paso 1 est√° activo
        const conditionsSidebar = document.querySelector(".conditions-sidebar");
        if (conditionsSidebar) {
          if (step === 1) {
            conditionsSidebar.classList.add("wizard-step-1-active");
          } else {
            conditionsSidebar.classList.remove("wizard-step-1-active");
          }
        }
        
        // Agregar/remover efecto de aura en bot√≥n de iniciar cuando el paso 2 est√° activo
        const startBtn = document.getElementById("start-btn");
        if (startBtn) {
          if (step === 2) {
            startBtn.classList.add("wizard-step-2-active");
          } else {
            startBtn.classList.remove("wizard-step-2-active");
          }
        }
        
        // Agregar/remover efecto de aura en bot√≥n de tratamiento cuando el paso 3 est√° activo
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          if (step === 3) {
            treatmentBtn.classList.add("wizard-step-3-active");
          } else {
            treatmentBtn.classList.remove("wizard-step-3-active");
          }
        }
      }

      // Event Listeners
      document.addEventListener("DOMContentLoaded", () => {
        initSimulation();

        // Inicializar sistemas de accesibilidad PRIMERO
        ScreenReaderAnnouncements.init();
        KeyboardNavigation.init();
        AccessibilityPanel.init();

        // Condition buttons
        document.querySelectorAll(".condition-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            setCondition(btn.dataset.condition);
          });
        });

        // Treatment button
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          treatmentBtn.addEventListener("click", applyTreatment);
          treatmentBtn.disabled = true; // Deshabilitado hasta iniciar simulaci√≥n
        }

        // Start button
        const startBtn = document.getElementById("start-btn");
        if (startBtn) {
          startBtn.addEventListener("click", toggleSimulation);
          startBtn.disabled = true; // Deshabilitado hasta seleccionar condici√≥n
        }

        // Pause button
        const pauseBtn = document.getElementById("pause-btn");
        if (pauseBtn) {
          pauseBtn.addEventListener("click", toggleSimulation);
        }

        // Reset button
        document.getElementById("reset-btn").addEventListener("click", () => {
          state.simulationRunning = false;
          state.isPaused = false;
          state.lastAnnouncedHemostasis = false;
          state.lastAnnouncedTreatment = false;
          state.condition = null;
          
          // Limpiar contenido educativo
          const infoContent = document.getElementById('educational-info-content');
          if (infoContent) {
            infoContent.innerHTML = '';
          }
          
          // No necesitamos detener el runner porque usamos nuestro propio loop
          initSimulation();
          
          // Desactivar todas las condiciones
          document.querySelectorAll(".condition-btn").forEach((btn) => {
            btn.classList.remove("active");
            btn.setAttribute("aria-checked", "false");
          });
          
          // Resetear wizard al paso 1
          updateWizardStep(1);
          
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitado hasta seleccionar condici√≥n
          }
          
          const pauseBtn = document.getElementById("pause-btn");
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar pausa al resetear
          }
          
          // Resetear bot√≥n de tratamiento
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn) {
            treatmentBtn.classList.remove("applied");
            treatmentBtn.disabled = true; // Deshabilitado hasta iniciar simulaci√≥n
            treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"
              />
            </svg>
            Administrar Tratamiento`;
          }
          
          // Remover efecto de pulsaci√≥n del bot√≥n de reiniciar
          const resetBtn = document.getElementById("reset-btn");
          if (resetBtn) {
            resetBtn.classList.remove("hemostasis-pulse");
          }
          
          state.treatmentApplied = false;
          
          // Actualizar UI inmediatamente para mostrar valores reseteados
          updateUI();
          ScreenReaderAnnouncements.announce("Simulaci√≥n reiniciada");
        });

        // Inicializar controles avanzados
        initCharts();
        setupSpeedControls();
        setupEducationalPanel();
        setupTooltips();

        // Inicializar sistema de feedback contextual
        ContextualFeedback.init();

        // Inicializar tutorial interactivo
        InteractiveTutorial.init();

        // Inicializar wizard - empezar en paso 1 sin condici√≥n activa
        updateWizardStep(1);

        // No activar ninguna condici√≥n por defecto
        // El bot√≥n de inicio permanece deshabilitado hasta que se seleccione una condici√≥n

        // Actualizar ARIA inicial
        updateConditionARIA();

        // Inicializar actualizaci√≥n peri√≥dica de descripci√≥n
        setInterval(updateSimulationDescription, 2000);

        // Mejorar canvas para accesibilidad
        const canvas = document.getElementById("simulation-canvas");
        if (canvas) {
          canvas.setAttribute("role", "img");
          canvas.setAttribute("aria-label", "Simulaci√≥n de coagulaci√≥n sangu√≠nea");
          canvas.setAttribute("tabindex", "0");
        }
      });
    </script>
  </body>
</html>
