<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Laboratorio Virtual de Hemostasia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <main class="main-container" id="main-content" role="main">

      <!-- Layout principal de tres columnas -->
      <div class="simulator-layout">
        <!-- Columna izquierda: Condiciones Clínicas -->
        <aside class="conditions-sidebar" role="complementary" aria-label="Condiciones clínicas">
          <div class="panel-card" role="region">
            <div class="condition-grid" role="radiogroup">
            <button 
              class="condition-btn" 
              data-condition="normal"
              role="radio"
              aria-checked="false"
              aria-describedby="normal-desc"
            >
              <div class="condition-name">Normal</div>
              <div class="condition-desc" id="normal-desc">
                Coagulación fisiológica normal - Todos los factores funcionan
                correctamente
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="hemophilia"
              role="radio"
              aria-checked="false"
              aria-describedby="hemophilia-desc"
            >
              <div class="condition-name">Hemofilia A/B</div>
              <div class="condition-desc" id="hemophilia-desc">
                Déficit Factor VIII/IX - Las plaquetas se adhieren pero la
                fibrina se forma muy lentamente y es inestable
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="vwd"
              role="radio"
              aria-checked="false"
              aria-describedby="vwd-desc"
            >
              <div class="condition-name">von Willebrand</div>
              <div class="condition-desc" id="vwd-desc">
                Déficit Factor vWF - Las plaquetas tienen dificultad para
                adherirse a la herida
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="factorDeficiency"
              role="radio"
              aria-checked="false"
              aria-describedby="factorDeficiency-desc"
            >
              <div class="condition-name">Déficit de otros factores</div>
              <div class="condition-desc" id="factorDeficiency-desc">
                Déficit de factores de coagulación - Formación de fibrina reducida
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="thrombocytopenia"
              role="radio"
              aria-checked="false"
              aria-describedby="thrombocytopenia-desc"
            >
              <div class="condition-name">Plaquetopenia</div>
              <div class="condition-desc" id="thrombocytopenia-desc">
                Recuento bajo de plaquetas - Pocas plaquetas disponibles para
                formar el coágulo
              </div>
            </button>
            <button 
              class="condition-btn" 
              data-condition="thrombasthenia"
              role="radio"
              aria-checked="false"
              aria-describedby="thrombasthenia-desc"
            >
              <div class="condition-name">Plaquetopatía</div>
              <div class="condition-desc" id="thrombasthenia-desc">
                Déficit glicoproteína IIb/IIIa - Las plaquetas se adhieren pero
                no se agregan entre sí
              </div>
            </button>
          </div>
        </div>
        </aside>

        <!-- Columna central: Simulador -->
        <section class="viewer-section">
          
          <div class="viewer-container">
            <!-- Leyenda dentro del visor -->
            <div class="legend">
              <div class="legend-item tooltip-container">
                <div class="legend-dot platelet"></div>
                <span class="tooltip-trigger">Plaquetas</span>
                <div class="tooltip">
                  Células sanguíneas pequeñas que se adhieren a la herida y forman
                  el tapón inicial. Se activan al contacto con el colágeno expuesto.
                </div>
              </div>
              <div class="legend-item tooltip-container">
                <div class="legend-dot rbc"></div>
                <span class="tooltip-trigger">Glóbulos Rojos</span>
                <div class="tooltip">
                  Eritrocitos que transportan oxígeno. No participan directamente en
                  la coagulación pero pueden quedar atrapados en el coágulo.
                </div>
              </div>
              <div class="legend-item tooltip-container">
                <div class="legend-dot wbc"></div>
                <span class="tooltip-trigger">Glóbulos Blancos</span>
                <div class="tooltip">
                  Leucocitos que participan en la respuesta inmune. Pueden ayudar en
                  la limpieza de la herida.
                </div>
              </div>
              <div class="legend-item tooltip-container">
                <div class="legend-dot fibrin"></div>
                <span class="tooltip-trigger">Red de Fibrina</span>
                <div class="tooltip">
                  Proteína formada a partir del fibrinógeno por acción de la
                  trombina. Crea una malla que refuerza el tapón plaquetario.
                </div>
              </div>
              <div class="legend-item tooltip-container">
                <div class="legend-dot vwf"></div>
                <span class="tooltip-trigger">Factor von Willebrand</span>
                <div class="tooltip">
                  Proteína que media la adhesión de las plaquetas al colágeno
                  expuesto. Esencial para el inicio de la hemostasia.
                </div>
              </div>
            </div>
            
            <div class="viewer-labels">
              <div class="label label-wound" id="wound-label" role="status" aria-live="polite">
                Lesión Activa
              </div>
            </div>
            <div class="treatment-indicator" id="treatment-indicator" role="status" aria-live="assertive" aria-atomic="true">
              Tratamiento Administrado
            </div>


            <canvas 
              id="simulation-canvas"
            ></canvas>

            <!-- Métricas dentro del simulador (lado derecho) -->
            <div class="viewer-metrics">
              <div class="metric-box">
                <div class="metric-value blood-loss" id="blood-loss">0</div>
                <div class="metric-label">Pérdida Sanguínea</div>
              </div>
              <div class="metric-box">
                <div class="metric-value clot-progress" id="clot-percentage">
                  0%
                </div>
                <div class="metric-label">Cierre de la Herida</div>
              </div>
            </div>
          </div>

          <!-- Contenedor de botones de control -->
          <div class="simulation-controls-row">
            <button 
              class="start-btn control-btn-large" 
              id="start-btn"
              aria-label="Iniciar la simulación"
              title="Iniciar simulación (Alt+S)"
            >
              <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
              </svg>
              Iniciar Simulación
            </button>
            <button 
              class="pause-btn control-btn-small" 
              id="pause-btn"
              aria-label="Pausar la simulación"
              title="Pausar simulación"
              disabled
            >
              <svg class="btn-icon pause-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
              </svg>
              Pausar
            </button>
            <button 
              class="reset-btn control-btn-small" 
              id="reset-btn"
              aria-label="Reiniciar la simulación"
              title="Reiniciar simulación (Alt+R)"
            >
              <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
              </svg>
              Reiniciar
            </button>
            <div class="speed-control control-speed">
              <label>
                <svg class="speed-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                </svg>
                Velocidad:
              </label>
              <input
                type="range"
                class="speed-slider"
                id="speed-slider"
                min="0.25"
                max="2"
                step="0.25"
                value="1"
              />
              <span id="speed-value">1x</span>
            </div>
            <button 
              class="treatment-btn control-btn-large" 
              id="treatment-btn"
              aria-label="Administrar tratamiento médico"
              title="Aplicar tratamiento (Alt+T)"
            >
              Administrar Tratamiento
            </button>
          </div>


        </section>

      </div>
    </main>


    <script>
      // Matter.js modules
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Body,
        Composite,
        Constraint,
        Events,
        Vector,
      } = Matter;



      // Actualizar estados ARIA de condiciones
      function updateConditionARIA() {
        document.querySelectorAll('.condition-btn').forEach(btn => {
          const isActive = btn.classList.contains('active');
          btn.setAttribute('aria-checked', isActive);
        });
      }



      // Simulation Configuration
      const CONFIG = {
        canvas: {
          width: 1300,
          height: 300,
        },
        wound: {
          x: 550, // Center
          width: 300,
          height: 20,
        },
        wall: {
          thickness: 30, // Increased thickness to prevent particles from passing through
          color: "#FDA4AF",
        },
        physics: {
          flowForce: 0.000175, // Base: promedio entre 0.00015 y 0.00020
          flowForceMin: 0.00008, // Mínimo muy reducido para pulso extremadamente dramático
          flowForceMax: 0.00045, // Máximo muy aumentado para hacer el pulso extremadamente visible (5.6x diferencia)
          suctionForce: -0.00050, // Vertical hacia arriba (negativo) - aumentado más
          suctionRadius: 180,
        },
        particles: {
          maxCount: 150, // Reduced for better performance
          spawnRate: 3, // Increased spawn rate for more particles
          plateletRatio: 0.30, // 30% para efectos didácticos
          rbcRatio: 0.65, // 65% - mayoría en sangre real
          wbcRatio: 0.05, // 5%
        },
        fibrin: {
          maxConnections: 200, // Limit fibrin connections to prevent performance issues
          maxConnectionsPerPlatelet: 8, // Limit connections per platelet
        },
        stuckPlatelets: {
          maxCount: 80, // Límite máximo de plaquetas pegadas para mantener rendimiento
        },
        conditions: {
          normal: {
            name: "Normal",
            description:
              "Coagulación fisiológica normal - Todos los factores funcionan correctamente",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregación: SÍ
            fibrinFormationRate: 1.0,
            fibrinStability: 1.0, // Fibrina FUERTE (stiffness: 0.9) - Resultado: Tapón sólido verde
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            bleedingTime: 3,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676", // Verde sólido
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La coagulación normal es un proceso fisiológico complejo que permite detener el sangrado tras una lesión vascular. Todos los componentes del sistema hemostático funcionan de manera coordinada.",
              pathophysiology: "En condiciones normales, la hemostasia primaria (adhesión y agregación plaquetaria) y secundaria (cascada de coagulación) trabajan en sinergia. Las plaquetas se adhieren al colágeno expuesto mediante el factor von Willebrand (vWF), se agregan entre sí, y la cascada de coagulación genera trombina que convierte el fibrinógeno en fibrina, formando una red estable que refuerza el tapón plaquetario.",
              symptoms: "No hay síntomas anormales. El tiempo de sangrado es normal (2-4 minutos) y la formación del coágulo es eficiente y estable.",
              causes: "Estado fisiológico normal. No hay déficit ni alteración de factores de coagulación.",
              treatment: "No requiere tratamiento. El sistema hemostático funciona correctamente.",
              prognosis: "Excelente. La coagulación ocurre de manera eficiente, minimizando la pérdida sanguínea y permitiendo la cicatrización adecuada.",
              clinicalNotes: "Este es el estado de referencia para comparar otras condiciones. Los tiempos normales de coagulación son: tiempo de sangrado 2-4 min, tiempo de protrombina (PT) 11-13 seg, tiempo de tromboplastina parcial (PTT) 25-35 seg.",
              affectedFactors: "Ninguno - todos los factores funcionan normalmente",
              cascadePathway: "Ambas vías (intrínseca y extrínseca) funcionan correctamente, convergiendo en la vía común que genera trombina eficientemente.",
            },
          },
          hemophilia: {
            name: "Hemofilia A/B",
            description:
              "Déficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ (Se forma el tapón blanco)
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregación: SÍ
            fibrinFormationRate: 0.1, // Probabilidad 10% - MUY DÉBIL o INEXISTENTE
            fibrinStability: 0.001, // MUY DÉBIL (stiffness: 0.001) - La fuerza de succión lo rompe
            fibrinDecayRate: 0.05, // Decaimiento rápido
            fibrinFormationDelay: 1500,
            bleedingTime: 30,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF6B6B", // Rojo para indicar débil
              fibrinGlow: false,
              fibrinOpacity: 0.3, // Muy transparente
            },
            educational: {
              overview: "La hemofilia es un trastorno hemorrágico hereditario causado por déficit de Factor VIII (Hemofilia A) o Factor IX (Hemofilia B). Es la coagulopatía hereditaria más común, afectando principalmente a varones.",
              pathophysiology: "El déficit de Factor VIII o IX interrumpe la vía intrínseca de la cascada de coagulación. Las plaquetas se adhieren normalmente formando el tapón primario, pero la generación de trombina está severamente reducida. Sin suficiente trombina, el fibrinógeno no se convierte eficientemente en fibrina, resultando en coágulos débiles e inestables que se desintegran fácilmente.",
              symptoms: "Sangrado prolongado tras lesiones menores, hemartrosis (sangrado en articulaciones), hematomas espontáneos, sangrado post-quirúrgico severo. El tiempo de sangrado puede ser normal, pero el tiempo de tromboplastina parcial (PTT) está prolongado.",
              causes: "Mutaciones genéticas en el cromosoma X que codifican para Factor VIII (Hemofilia A) o Factor IX (Hemofilia B). Patrón de herencia ligado al cromosoma X (afecta principalmente varones).",
              treatment: "Tratamiento de reemplazo con concentrados de Factor VIII o IX según el tipo. En casos leves puede usarse desmopresina (DDAVP) para Hemofilia A. Tratamiento profiláctico en casos severos. Tratamiento de episodios hemorrágicos agudos.",
              prognosis: "Con tratamiento adecuado, los pacientes pueden llevar una vida relativamente normal. Sin tratamiento, el sangrado recurrente puede causar artropatía hemofílica, anemia crónica y complicaciones graves.",
              clinicalNotes: "Hemofilia A (déficit Factor VIII) es más común que Hemofilia B (déficit Factor IX). La severidad depende del nivel de factor: severa (<1%), moderada (1-5%), leve (5-40%). El PTT está prolongado mientras que el PT es normal.",
              affectedFactors: "Factor VIII (Hemofilia A) o Factor IX (Hemofilia B) - componentes críticos de la vía intrínseca",
              cascadePathway: "Vía intrínseca defectuosa. El Factor VIII actúa como cofactor del Factor IX activado. Sin estos factores, la generación de trombina es insuficiente.",
            },
          },
          vwd: {
            name: "Enfermedad de Von Willebrand",
            description:
              "Déficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida",
            plateletRatio: 0.30, // Spawn normal
            canStick: false, // Adhesión: NO - Fallo en el "pegamento" (vWF)
            canFormFibrin: true,
            stickProbability: 0.0, // No pueden adherirse
            plateletFunction: 0.4,
            adhesionStrength: 0.0,
            aggregationRate: 0.0, // Sin agregación porque no hay adhesión
            fibrinFormationRate: 0.0, // No se forma porque no hay adhesión
            fibrinStability: 0.0,
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            plateletBounceFactor: 0.9, // Rebote alto (restitution: 0.9) - rebotan contra la pared
            adhesionRetryChance: 0.0,
            bleedingTime: 15,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676",
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La enfermedad de Von Willebrand (EvW) es el trastorno hemorrágico hereditario más común, afectando aproximadamente al 1% de la población. Se caracteriza por déficit o disfunción del factor von Willebrand (vWF).",
              pathophysiology: "El factor von Willebrand actúa como 'pegamento' que permite que las plaquetas se adhieran al colágeno expuesto en la pared vascular lesionada. También transporta y estabiliza el Factor VIII en plasma. Sin vWF funcional, las plaquetas no pueden adherirse al sitio de la lesión, impidiendo la formación del tapón primario y, por tanto, la iniciación de la cascada de coagulación.",
              symptoms: "Sangrado mucocutáneo (epistaxis, sangrado gingival, menorragia), sangrado prolongado tras cirugía menor, hematomas fáciles, tiempo de sangrado prolongado. Los síntomas suelen ser más leves que en hemofilia.",
              causes: "Mutaciones genéticas en el gen VWF localizado en el cromosoma 12. Puede ser heredada de forma autosómica dominante (tipo 1 y 2) o recesiva (tipo 3). Tipo 1: déficit cuantitativo parcial; Tipo 2: defectos cualitativos; Tipo 3: déficit completo severo.",
              treatment: "Desmopresina (DDAVP) para tipos 1 y 2A leves - aumenta la liberación de vWF endógeno. Concentrados de vWF/Factor VIII para casos severos o cuando DDAVP no es efectivo. Ácido tranexámico como coadyuvante para sangrado mucocutáneo.",
              prognosis: "Generalmente buena. La mayoría de los pacientes tienen síntomas leves y pueden manejar episodios hemorrágicos con tratamiento adecuado. Los casos severos requieren manejo similar a hemofilia.",
              clinicalNotes: "Existen tres tipos principales: Tipo 1 (déficit parcial, 75% de casos), Tipo 2 (defectos cualitativos, 20-25%), Tipo 3 (déficit severo, raro). El tiempo de sangrado está prolongado y el Factor VIII puede estar reducido.",
              affectedFactors: "Factor von Willebrand (vWF) - esencial para la adhesión plaquetaria y estabilización del Factor VIII",
              cascadePathway: "Fallo en la hemostasia primaria. Sin adhesión plaquetaria, no se inicia adecuadamente la cascada de coagulación, aunque los factores de coagulación pueden estar normales.",
            },
          },
          thrombocytopenia: {
            name: "Trombocitopenia",
            description:
              "Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el coágulo",
            plateletRatio: 0.075, // Spawn BAJO (5-10%, promedio 7.5%)
            canStick: true, // Funcionalidad normal
            canFormFibrin: true, // El "cemento" (fibrina) funciona bien
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 1.0, // Normal - si logran juntarse, tejen fibrina
            fibrinStability: 1.0, // Normal
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            spawnRateMultiplier: 0.3,
            bleedingTime: 20,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#00E676",
              fibrinGlow: false,
              fibrinOpacity: 1.0,
            },
            educational: {
              overview: "La trombocitopenia es una condición caracterizada por un recuento bajo de plaquetas (<150,000/μL). Las plaquetas existentes funcionan normalmente, pero su número insuficiente dificulta la formación adecuada del tapón hemostático.",
              pathophysiology: "Con pocas plaquetas circulantes, aunque cada plaqueta funcione correctamente, no hay suficientes células para cubrir el área de la lesión y formar un tapón primario efectivo. La cascada de coagulación puede funcionar normalmente, pero sin un tapón plaquetario adecuado, la formación de fibrina es limitada o ineficaz.",
              symptoms: "Petequias (pequeñas manchas rojas en la piel), púrpura (manchas moradas), equimosis (hematomas), sangrado mucocutáneo, sangrado prolongado tras lesiones menores. El riesgo de sangrado aumenta significativamente con recuentos <50,000/μL y es severo con <20,000/μL.",
              causes: "Múltiples causas: disminución de producción (anemia aplásica, leucemia, déficit de vitamina B12/folato), aumento de destrucción (púrpura trombocitopénica inmune, trombocitopenia inducida por fármacos), secuestro esplénico, consumo excesivo (coagulación intravascular diseminada).",
              treatment: "Depende de la causa: corticosteroides o inmunoglobulina IV para trombocitopenia inmune, transfusión de plaquetas para sangrado activo o recuentos muy bajos, esplenectomía en casos refractarios, tratamiento de la causa subyacente.",
              prognosis: "Varía según la causa. La trombocitopenia inmune aguda en niños suele resolverse espontáneamente. Las formas crónicas requieren manejo a largo plazo. Con tratamiento adecuado, la mayoría de los pacientes pueden mantener recuentos seguros.",
              clinicalNotes: "Recuento normal: 150,000-450,000/μL. Leve: 100,000-150,000/μL (sangrado menor). Moderada: 50,000-100,000/μL (sangrado con trauma). Severa: <50,000/μL (sangrado espontáneo). El tiempo de sangrado está prolongado proporcionalmente al déficit.",
              affectedFactors: "Ningún factor de coagulación está afectado - el problema es cuantitativo (número de plaquetas) no cualitativo (función)",
              cascadePathway: "La cascada de coagulación funciona normalmente, pero la hemostasia primaria es inadecuada debido al número insuficiente de plaquetas para formar el tapón inicial.",
            },
          },
          hemophiliaSevere: {
            name: "Hemofilia Severa",
            description:
              "Déficit grave Factor VIII/IX (<1%) - Sin formación de fibrina, sangrado prolongado",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ (Se forma tapón blanco)
            canFormFibrin: false, // Fibrina: CERO
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9, // Agregación: SÍ
            fibrinFormationRate: 0.0, // CERO
            fibrinStability: 0.0, // CERO
            fibrinDecayRate: 0.2,
            fibrinFormationDelay: 0,
            bleedingTime: 60,
            blockThickCords: true,
            blockMediumCords: true,
            blockThinCords: true, // Bloquear todas las cuerdas
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF0000",
              fibrinGlow: false,
              fibrinOpacity: 0.0, // Invisible porque no se forma
            },
            educational: {
              overview: "La hemofilia severa se define por niveles de Factor VIII o IX <1% de lo normal. Representa la forma más grave de hemofilia, con sangrado espontáneo frecuente y riesgo significativo de complicaciones hemorrágicas graves.",
              pathophysiology: "Con niveles prácticamente indetectables de Factor VIII o IX, la vía intrínseca de coagulación está completamente bloqueada. El tapón plaquetario primario se forma normalmente, pero sin generación de trombina, no hay conversión de fibrinógeno a fibrina. Los coágulos que se forman son extremadamente débiles y se desintegran rápidamente, resultando en sangrado prolongado o recurrente.",
              symptoms: "Sangrado espontáneo frecuente (sin trauma aparente), hemartrosis recurrente que puede llevar a artropatía hemofílica, hematomas extensos, sangrado intracraneal (complicación grave), sangrado post-quirúrgico severo, sangrado gastrointestinal o genitourinario.",
              causes: "Mutaciones genéticas severas en los genes de Factor VIII (Hemofilia A severa) o Factor IX (Hemofilia B severa) que resultan en producción mínima o nula del factor. Patrón de herencia ligado al cromosoma X.",
              treatment: "Tratamiento profiláctico regular con concentrados de Factor VIII/IX (2-3 veces por semana) para prevenir sangrados. Tratamiento de episodios hemorrágicos agudos con dosis altas. En algunos casos, terapia génica experimental. Manejo multidisciplinario incluyendo fisioterapia para prevenir artropatía.",
              prognosis: "Sin tratamiento, la esperanza de vida está significativamente reducida debido a complicaciones hemorrágicas. Con tratamiento profiláctico adecuado, los pacientes pueden llevar vidas relativamente normales, aunque requieren atención médica continua. La artropatía hemofílica es una complicación común a largo plazo.",
              clinicalNotes: "Niveles de factor <1% definen hemofilia severa. El PTT está muy prolongado (>60 segundos). Los pacientes requieren tratamiento profiláctico para prevenir sangrados espontáneos. El desarrollo de inhibidores (anticuerpos contra el factor) es una complicación grave que afecta al 20-30% de pacientes con Hemofilia A severa.",
              affectedFactors: "Factor VIII o Factor IX prácticamente ausentes (<1% de actividad normal) - bloqueo completo de la vía intrínseca",
              cascadePathway: "Vía intrínseca completamente bloqueada. Sin Factor VIII/IX, no hay activación del Factor X, resultando en ausencia total de generación de trombina y formación de fibrina.",
            },
          },
          thrombasthenia: {
            name: "Trombastenia de Glanzmann",
            description:
              "Déficit glicoproteína IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre sí",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión (Pared): SÍ - Se pegan al tejido
            canFormFibrin: true,
            stickProbability: 0.9,
            plateletFunction: 0.2,
            adhesionStrength: 0.85, // Se pegan a la pared
            aggregationRate: 0.0, // Agregación (Plaqueta-Plaqueta): NO
            fibrinFormationRate: 0.0, // No se forma porque no hay agregación
            fibrinStability: 0.0,
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 0,
            maxPlateletClusterSize: 1, // Solo una plaqueta por posición - no agregación
            bleedingTime: 25,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: true,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FFA500",
              fibrinGlow: false,
              fibrinOpacity: 0.0, // No se forma fibrina
            },
            educational: {
              overview: "La trombastenia de Glanzmann es un trastorno hemorrágico hereditario raro caracterizado por déficit o disfunción del complejo glicoproteína IIb/IIIa (GPIIb/IIIa), el receptor principal de fibrinógeno en las plaquetas.",
              pathophysiology: "Las plaquetas pueden adherirse normalmente a la pared vascular mediante vWF y otros receptores, pero no pueden agregarse entre sí porque el receptor GPIIb/IIIa está ausente o disfuncional. Este receptor es esencial para que las plaquetas se unan mediante puentes de fibrinógeno. Sin agregación, no se forma un tapón plaquetario efectivo, y aunque la cascada de coagulación funcione, sin un tapón adecuado la formación de fibrina es limitada.",
              symptoms: "Sangrado mucocutáneo severo (epistaxis, gingivorragia, menorragia), púrpura, equimosis, sangrado prolongado tras cirugía o trauma. El tiempo de sangrado está muy prolongado. Las plaquetas no se agregan en respuesta a agonistas como ADP, trombina o colágeno.",
              causes: "Mutaciones en los genes ITGA2B (codifica GPIIb) o ITGB3 (codifica GPIIIa) localizados en el cromosoma 17. Herencia autosómica recesiva. Tipo I: ausencia completa del complejo; Tipo II: presencia pero disfunción del complejo.",
              treatment: "Transfusión de plaquetas para episodios hemorrágicos agudos o antes de procedimientos quirúrgicos. Ácido tranexámico como coadyuvante. Desmopresina puede tener efecto limitado. En casos refractarios, factor VIIa recombinante. Evitar antiagregantes plaquetarios.",
              prognosis: "Es un trastorno crónico que requiere manejo de por vida. Con tratamiento adecuado de episodios hemorrágicos, los pacientes pueden llevar vidas relativamente normales, aunque el sangrado puede ser severo. La menorragia puede ser particularmente problemática en mujeres.",
              clinicalNotes: "El recuento plaquetario es normal, pero la agregación plaquetaria está ausente o severamente reducida. El tiempo de sangrado está muy prolongado (>20 minutos). La prueba de agregación plaquetaria muestra ausencia de respuesta a todos los agonistas. Es más común en poblaciones con consanguinidad.",
              affectedFactors: "Glicoproteína IIb/IIIa (GPIIb/IIIa) - receptor de fibrinógeno esencial para la agregación plaquetaria",
              cascadePathway: "La cascada de coagulación puede funcionar normalmente, pero sin agregación plaquetaria no se forma un tapón primario efectivo, limitando la iniciación y eficacia de la formación de fibrina.",
            },
          },
          factorDeficiency: {
            name: "Déficit Factor VII",
            description:
              "Déficit Factor VII - Vía extrínseca defectuosa, formación de fibrina reducida",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: SÍ - Las plaquetas se pegan
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 1.0, // Normal después del retraso
            fibrinStability: 0.9, // Normal después del retraso
            fibrinDecayRate: 0.0,
            fibrinFormationDelay: 4000, // Retraso 3-5 segundos extra (4000ms) tras la adhesión
            bleedingTime: 12,
            blockThickCords: false,
            blockMediumCords: false,
            blockThinCords: false,
            requiresTreatment: false,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FFD700",
              fibrinGlow: false,
              fibrinOpacity: 0.9,
            },
            educational: {
              overview: "El déficit de Factor VII es un trastorno hemorrágico hereditario raro que afecta la vía extrínseca de la coagulación. El Factor VII es el primer factor activado en la vía extrínseca cuando se expone el factor tisular tras una lesión.",
              pathophysiology: "El Factor VII, junto con el factor tisular (FT), inicia la vía extrínseca activando el Factor X. Con déficit de Factor VII, esta activación inicial está retrasada o reducida. La vía intrínseca puede compensar parcialmente, pero hay un retraso significativo en la generación de trombina y formación de fibrina. Las plaquetas funcionan normalmente, pero el refuerzo de fibrina tarda más en formarse.",
              symptoms: "Sangrado variable según la severidad del déficit. Puede incluir sangrado mucocutáneo, hemartrosis (menos común que en hemofilia), sangrado post-quirúrgico, menorragia. Los síntomas suelen ser más leves que en hemofilia. El tiempo de protrombina (PT) está prolongado mientras que el PTT puede ser normal.",
              causes: "Mutaciones en el gen F7 localizado en el cromosoma 13 que codifica el Factor VII. Herencia autosómica recesiva. Puede ser congénito (raro) o adquirido (asociado a enfermedad hepática, déficit de vitamina K, o uso de warfarina).",
              treatment: "Concentrados de Factor VII recombinante o plasma fresco congelado para episodios hemorrágicos. En casos leves puede no requerir tratamiento profiláctico. El tratamiento de reemplazo es efectivo pero de corta duración (vida media corta del Factor VII).",
              prognosis: "Generalmente buena. Los pacientes con déficit leve pueden tener síntomas mínimos. Los casos severos requieren tratamiento de episodios hemorrágicos pero pueden llevar vidas relativamente normales con manejo adecuado.",
              clinicalNotes: "El PT está prolongado mientras que el PTT es normal (patrón inverso a hemofilia). El déficit de Factor VII es el más común de los déficits de factores de la vía extrínseca, aunque sigue siendo raro. La vida media del Factor VII es corta (4-6 horas), requiriendo dosis frecuentes en tratamiento.",
              affectedFactors: "Factor VII - componente crítico de la vía extrínseca que inicia la activación del Factor X",
              cascadePathway: "Vía extrínseca defectuosa o retrasada. La vía intrínseca puede compensar parcialmente, pero hay un retraso en la generación inicial de trombina, resultando en formación tardía de fibrina.",
            },
          },
          anticoagulated: {
            name: "Anticoagulado (Warfarina)",
            description:
              "Anticoagulación oral - Factores dependientes de vitamina K reducidos, fibrina inestable",
            plateletRatio: 0.30, // Spawn normal
            canStick: true, // Adhesión: Normal
            canFormFibrin: true,
            stickProbability: 0.95,
            plateletFunction: 1.0,
            adhesionStrength: 0.95,
            aggregationRate: 0.9,
            fibrinFormationRate: 0.3, // ESCASA - probabilidad baja
            fibrinStability: 0.3, // DÉBIL (stiffness baja) - similar a hemofilia leve
            fibrinDecayRate: 0.08, // Decaimiento rápido
            fibrinFormationDelay: 800,
            bleedingTime: 8,
            visualEffects: {
              plateletColor: "#808080",
              fibrinColor: "#FF6347",
              fibrinGlow: false,
              fibrinOpacity: 0.5, // Más transparente
            },
            educational: {
              overview: "La anticoagulación con warfarina es un tratamiento común para prevenir trombosis en pacientes con fibrilación auricular, prótesis valvulares cardíacas, o historia de tromboembolismo. La warfarina inhibe la síntesis de factores de coagulación dependientes de vitamina K.",
              pathophysiology: "La warfarina bloquea la enzima vitamina K epóxido reductasa, impidiendo la carboxilación de los factores II, VII, IX y X (factores dependientes de vitamina K). Sin esta modificación post-traduccional, estos factores no pueden unirse al calcio y fosfolípidos, reduciendo su actividad. Esto resulta en generación reducida de trombina y formación de fibrina débil e inestable. Las plaquetas funcionan normalmente, pero el refuerzo de fibrina es insuficiente.",
              symptoms: "Aumento del riesgo de sangrado, especialmente con sobredosificación. Puede presentar sangrado mucocutáneo, hematomas fáciles, sangrado prolongado tras procedimientos, hemorragia gastrointestinal o intracraneal (complicación grave). El tiempo de protrombina (PT/INR) está prolongado.",
              causes: "Uso terapéutico de warfarina para prevención de trombosis. La dosis se ajusta según el INR objetivo (generalmente 2-3 para mayoría de indicaciones, 2.5-3.5 para prótesis valvulares mecánicas). Interacciones con múltiples fármacos y alimentos pueden afectar los niveles.",
              treatment: "Para sangrado menor: suspender warfarina temporalmente. Para sangrado mayor o INR muy elevado: vitamina K oral o IV para revertir la anticoagulación, concentrado de complejo protrombínico (PCC) para reversión rápida en emergencias, plasma fresco congelado como alternativa. Monitoreo regular de INR para ajuste de dosis.",
              prognosis: "Con monitoreo adecuado y mantenimiento del INR en rango terapéutico, el riesgo de sangrado es bajo. Sin embargo, requiere monitoreo regular y ajuste de dosis. El riesgo de sangrado aumenta con INR >4.5. Los pacientes deben evitar traumatismos y ser cuidadosos con interacciones farmacológicas.",
              clinicalNotes: "El INR (International Normalized Ratio) es el parámetro de monitoreo estándar. Rango terapéutico típico: 2-3. La warfarina tiene inicio de acción lento (2-3 días) y vida media larga (36-42 horas). Requiere 5-7 días para alcanzar efecto completo y similar tiempo para revertirse. Interacciones comunes con antibióticos, AINEs, y alimentos ricos en vitamina K.",
              affectedFactors: "Factores II (protrombina), VII, IX y X - todos dependientes de vitamina K para su activación funcional",
              cascadePathway: "Ambas vías (intrínseca y extrínseca) están afectadas porque comparten factores dependientes de vitamina K. La generación de trombina está reducida, resultando en formación de fibrina débil e inestable.",
            },
          },
        },
      };

      // Game State
      let state = {
        condition: "normal",
        treatmentApplied: false,
        bloodLoss: 0,
        clotPercentage: 0,
        hemostasisAchieved: false,
        stuckPlatelets: [],
        fibrinConstraints: [],
        fibrinBodies: [], // Physical bodies for fibrin network
        allBodies: [],
        showOintment: false,
        fibrinStarted: false,
        simulationRunning: false, // Control manual de simulación
        startTime: null,
        plateletsSpawned: 0,
        // Controles de velocidad
        timeScale: 1.0,
        isPaused: false,
      };

      // Spawn timing for fixed interval
      let spawnInterval = null;
      let lastSpawnTime = 0;
      // spawnIntervalCounter removido
      let actualSpawnIntervals = []; // Array para calcular el intervalo promedio
      const SPAWN_INTERVAL_MS = 125; // Intervalo variable entre 100-150ms (promedio 125ms)

      // Performance optimization: frame counters for throttling
      let frameCount = 0;
      const CLEANUP_INTERVAL = 5; // Cleanup every 5 frames (más frecuente para mejor limpieza)
      const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames

      // Fixed timestep loop variables - garantizar velocidad constante independiente del FPS
      let physicsLoopId = null;
      let renderLoopId = null;
      let lastPhysicsTime = 0;
      const FIXED_TIMESTEP = 1000 / 60; // 16.67ms = 60 FPS fijo para física
      let accumulatedTime = 0;
      let accumulatedSimulationTime = 0; // Tiempo de simulación acumulado (ajustado por timeScale)
      let lastSimulationTimeUpdate = 0; // Última vez que se actualizó el tiempo de simulación

      // Matter.js Setup
      let engine, render, runner;

      function initSimulation() {
        // Clear spawn timeout
        if (spawnInterval !== null) {
          clearTimeout(spawnInterval);
          spawnInterval = null;
        }
        // spawnIntervalCounter removido

        lastSpawnTime = 0;
        actualSpawnIntervals = [];
        spawnStats = {
          lastSpawnCount: 0,
          totalSpawned: 0,
          spawnHistory: [],
        };

        // Reset state (preservar propiedades nuevas)
        state = {
          condition: state.condition,
          treatmentApplied: false,
          bloodLoss: 0,
          clotPercentage: 0,
          hemostasisAchieved: false,
          stuckPlatelets: [],
          fibrinConstraints: [],
          fibrinBodies: [],
          allBodies: [],
          showOintment: false,
          fibrinStarted: false,
          simulationRunning: false,
          startTime: null,
          plateletsSpawned: 0,
          // Controles de velocidad (base speed = 0.75, slider 1.0 = velocidad normal más lenta)
          timeScale: state.timeScale || 0.75,
          isPaused: false,
        };

        // FPS counter removed

        // Clear previous engine events
        if (engine) {
          Events.off(engine, "beforeUpdate");
          Events.off(engine, "afterUpdate");
          Events.off(engine, "collisionStart");
          // Remove anchor platelets before clearing world
          if (state.stuckPlatelets) {
            state.stuckPlatelets.forEach((plateletData) => {
              if (plateletData.isAnchor && plateletData.body) {
                Composite.remove(engine.world, plateletData.body);
              }
            });
          }
          Composite.clear(engine.world);
          Engine.clear(engine);
        }
        if (render) {
          Events.off(render, "afterRender");
          Render.stop(render);
        }
        // No necesitamos detener el runner porque usamos nuestro propio loop
        // if (runner) {
        //     Runner.stop(runner);
        // }

        // Reset canvas
        const canvas = document.getElementById("simulation-canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Reset state
        state.fibrinStarted = false;
        state.simulationRunning = false;

        // Resetear tiempo acumulado de simulación
        accumulatedSimulationTime = 0;
        lastSimulationTimeUpdate = 0;

        // Reset UI elements
        const woundLabel = document.getElementById("wound-label");
        woundLabel.classList.remove("healed", "hidden");
        woundLabel.innerHTML = "Lesión Activa";
        
        // Remover efecto de pulsación del botón de reiniciar
        const resetBtn = document.getElementById("reset-btn");
        if (resetBtn) {
          resetBtn.classList.remove("hemostasis-pulse");
        }

        const treatmentBtn = document.getElementById("treatment-btn");
        treatmentBtn.classList.remove("applied");
        treatmentBtn.innerHTML = `Administrar Tratamiento`;
        treatmentBtn.disabled = false;

        // Resetear tiempo hasta cierre de herida
        const adhesionTimeEl = document.getElementById(
          "first-adhesion-time"
        );
        if (adhesionTimeEl) {
          adhesionTimeEl.textContent = "--";
        }


        // Create engine with zero gravity
        engine = Engine.create();
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 0;

        // Create renderer using existing canvas
        const canvasEl = document.getElementById("simulation-canvas");

        // Guardar el ancho original del canvas
        const originalCanvasWidth = CONFIG.canvas.width;
        const fixedCanvasHeight = CONFIG.canvas.height; // 300px fijo

        // Ajustar tamaño del canvas según el tamaño de la pantalla
        // Mantener altura fija, solo ajustar ancho
        const updateCanvasSize = () => {
          const container = canvasEl.parentElement;
          const containerWidth = container.clientWidth;
          const maxWidth = Math.min(originalCanvasWidth, containerWidth - 32); // 32px de padding

          // Obtener el tamaño visual real del canvas (considerando zoom del navegador)
          const rect = canvasEl.getBoundingClientRect();
          const visualWidth = rect.width;
          const visualHeight = rect.height;

          // Ajustar el tamaño interno del canvas para que coincida exactamente con el tamaño visual
          // Esto asegura que el canvas se renderice correctamente incluso con zoom
          // Usar el tamaño visual directamente sin escalar con DPR para evitar problemas de zoom
          canvasEl.width = Math.round(visualWidth);
          canvasEl.height = Math.round(visualHeight);

          // Usar el tamaño visual como tamaño lógico para la física
          const logicalWidth = visualWidth;
          const logicalHeight = visualHeight;

          // Actualizar CONFIG para que la física use el nuevo tamaño lógico
          CONFIG.canvas.width = logicalWidth;
          CONFIG.canvas.height = logicalHeight;

          // Mantener la herida siempre centrada
          CONFIG.wound.x = logicalWidth / 2;

          // Actualizar el renderer si ya existe
          if (render) {
            render.options.width = logicalWidth;
            render.options.height = logicalHeight;
            render.canvas.width = canvasEl.width;
            render.canvas.height = canvasEl.height;
            // Obtener el contexto fresco después de cambiar el tamaño del canvas
            render.context = canvasEl.getContext("2d");
          }

          // Invalidar el cache del fondo del vaso para que se regenere con el nuevo tamaño
          vesselBackgroundCache = null;

          // Si el engine ya existe, necesitamos recrear las paredes con el nuevo tamaño
          if (engine && state.simulationRunning === false) {
            // Solo recrear si la simulación no está corriendo
            // Las paredes se recrearán en el siguiente initSimulation
          }
        };

        updateCanvasSize();

        // Actualizar tamaño cuando cambia el tamaño de la ventana o el zoom
        let resizeTimeout;
        const handleResize = () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            updateCanvasSize();
            // Si la simulación está corriendo, reiniciar para aplicar los cambios
            if (state.simulationRunning) {
              const wasRunning = state.simulationRunning;
              state.simulationRunning = false;
              initSimulation();
              if (wasRunning) {
                setTimeout(() => {
                  state.simulationRunning = true;
                  lastPhysicsTime = 0;
                  accumulatedTime = 0;
                }, 100);
              }
            }
          }, 250);
        };

        window.addEventListener("resize", handleResize);

        // Detectar cambios de zoom usando ResizeObserver
        const resizeObserver = new ResizeObserver(() => {
          handleResize();
        });
        resizeObserver.observe(canvasEl);

        render = Render.create({
          canvas: canvasEl,
          engine: engine,
          options: {
            width: canvasEl.width,
            height: canvasEl.height,
            wireframes: false,
            background: "transparent", // Fondo transparente - dibujamos nosotros
            // Desacoplar el renderer del timestep de la física
            // El renderer se actualiza a su propio ritmo, pero la física siempre usa timestep fijo
            // Usar pixelRatio 1 para evitar que Matter.js escale el canvas internamente
            // Ya estamos manejando el tamaño manualmente para soportar zoom
            pixelRatio: 1,
          },
        });

        // Asegurar que el engine siempre use timestep fijo
        engine.timing.timeScale = 1.0;
        engine.timing.timestamp = 0;

        // Create vessel walls
        createVesselWalls();

        // Start engine and renderer with fixed timestep
        // Configurar el engine para usar timestep fijo
        engine.timing.timeScale = 1.0; // Asegurar que el timeScale sea 1.0

        // Crear Runner pero NO ejecutarlo automáticamente
        // Usaremos nuestro propio loop con timestep fijo garantizado
        runner = Runner.create({
          delta: FIXED_TIMESTEP,
          isFixed: true,
          enabled: false, // Deshabilitar el loop automático
        });

        // Loop de renderizado independiente (puede ejecutarse a cualquier FPS)
        function renderLoop() {
          if (render) {
            Render.world(render);
          }
          renderLoopId = requestAnimationFrame(renderLoop);
        }

        // Iniciar el loop de renderizado (siempre activo)
        renderLoop();

        // Loop de física con timestep fijo (solo se ejecuta cuando simulationRunning = true)
        function physicsLoop(currentTime) {
          if (!state.simulationRunning) {
            physicsLoopId = requestAnimationFrame(physicsLoop);
            return;
          }

          // Calcular tiempo transcurrido desde el último frame
          if (lastPhysicsTime === 0) {
            lastPhysicsTime = currentTime;
          }

          const deltaTime = currentTime - lastPhysicsTime;
          lastPhysicsTime = currentTime;

          // Acumular tiempo y ejecutar pasos de física a intervalos fijos
          accumulatedTime += deltaTime;

          // Acumular tiempo de simulación ajustado por timeScale (solo cuando está corriendo y no pausada)
          if (!state.isPaused && state.simulationRunning) {
            const timeScale = state.timeScale || 1.0;
            accumulatedSimulationTime += deltaTime * timeScale;
          }

          // Ejecutar tantos pasos de física como sean necesarios para mantener timestep fijo
          // Ajustar el número de pasos según timeScale para acelerar la simulación
          const timeScale = state.timeScale || 1.0;
          const maxSteps = 5; // Limitar pasos por frame para evitar "spiral of death"
          let stepsExecuted = 0;

          // Ejecutar múltiples pasos según timeScale, pero mantener timestep fijo
          // Esto acelera la simulación sin afectar la estabilidad física
          const stepsToExecute = Math.max(1, Math.ceil(timeScale));

          while (
            accumulatedTime >= FIXED_TIMESTEP &&
            stepsExecuted < maxSteps
          ) {
            // Solo ejecutar física si no está pausada
            if (!state.isPaused && state.simulationRunning) {
              // Ejecutar múltiples pasos de física con timestep fijo para acelerar la simulación
              // En lugar de escalar el timestep, ejecutamos más pasos por iteración
              // Esto mantiene la física estable pero acelera la simulación
              for (let i = 0; i < stepsToExecute; i++) {
                Engine.update(engine, FIXED_TIMESTEP);
              }
            }
            // Restar el tiempo correspondiente a los pasos ejecutados
            accumulatedTime -= FIXED_TIMESTEP;
            stepsExecuted++;
          }

          // Si acumulamos demasiado tiempo, resetear para evitar lag
          if (accumulatedTime > FIXED_TIMESTEP * 5) {
            accumulatedTime = 0;
          }

          physicsLoopId = requestAnimationFrame(physicsLoop);
        }

        // Iniciar el loop de física (siempre activo, pero solo procesa cuando simulationRunning = true)
        // Resetear variables de tiempo
        lastPhysicsTime = 0;
        accumulatedTime = 0;

        // Iniciar el loop de física
        if (!physicsLoopId) {
          physicsLoopId = requestAnimationFrame(physicsLoop);
        }

        // Estado inicial: simulación no corriendo
        state.simulationRunning = false;

        // Setup collision events
        setupCollisionEvents();

        // Start particle spawning
        startParticleSpawning();

        // Reset frame counter
        frameCount = 0;

        // Update loop for forces - use fixed timestep for frame-independent forces
        // Con isFixed: true, el Runner ejecuta pasos de física a intervalos fijos
        // Cada paso siempre es de 16.67ms, independientemente del FPS del renderer
        Events.on(engine, "beforeUpdate", () => {
          // Solo actualizar si la simulación está corriendo y no está pausada
          if (!state.simulationRunning || state.isPaused) return;

          frameCount++;
          // Aplicar fuerzas con timestep fijo (el timeScale se maneja ejecutando múltiples pasos de física)
          // Esto asegura que las fuerzas de adhesión funcionen correctamente independientemente de la velocidad
          applyForces(runner.delta);

          // Update fibrin barrier positions to follow platelets (every 3 frames for performance)
          if (frameCount % 3 === 0 && state.fibrinConstraints.length > 0) {
            state.fibrinConstraints.forEach((fibrin) => {
              if (fibrin.body && fibrin.pointA && fibrin.pointB) {
                const midX =
                  (fibrin.pointA.position.x + fibrin.pointB.position.x) / 2;
                const midY =
                  (fibrin.pointA.position.y + fibrin.pointB.position.y) / 2;
                const dist = Vector.magnitude(
                  Vector.sub(fibrin.pointB.position, fibrin.pointA.position)
                );
                const angle = Math.atan2(
                  fibrin.pointB.position.y - fibrin.pointA.position.y,
                  fibrin.pointB.position.x - fibrin.pointA.position.x
                );

                Body.setPosition(fibrin.body, { x: midX, y: midY });
                Body.setAngle(fibrin.body, angle);
                // Update width to match distance
                const currentWidth =
                  fibrin.body.bounds.max.x - fibrin.body.bounds.min.x;
                if (Math.abs(currentWidth - dist) > 1) {
                  Body.scale(fibrin.body, dist / currentWidth, 1);
                }
              }
            });
          }

          // Throttle expensive operations
          if (frameCount % CLEANUP_INTERVAL === 0) {
            cleanupParticles();
            // También limpiar plaquetas pegadas antiguas periódicamente
            cleanupOldStuckPlatelets();
          }
          if (frameCount % UI_UPDATE_INTERVAL === 0) {
            calculateClotPercentage();
            updateUI();
          }

          // vWF se renderiza como líneas entre plaquetas (no necesita actualización)
        });

        // Custom render - todo en afterRender, en orden: fondo, paredes, fibrina, vWF, partículas
        Events.on(render, "afterRender", renderVesselBackground);
        Events.on(render, "afterRender", renderVesselWalls);
        Events.on(render, "afterRender", renderFibrin);
        Events.on(render, "afterRender", renderVWF); // vWF se renderiza después de las cuerdas
        Events.on(render, "afterRender", renderParticlesCustom);

        // Update UI
        updateUI();
      }

      // FPS Counter removido

      function createVesselWalls() {
        const { width, height } = CONFIG.canvas;
        const { thickness, color } = CONFIG.wall;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;

        // Bottom wall (solid) - with bounce and collision filter
        const bottomWall = Bodies.rectangle(
          width / 2,
          height - thickness / 2,
          width,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Top wall - Left segment - with bounce and collision filter
        const leftWallWidth = woundX - woundWidth / 2;
        const topWallLeft = Bodies.rectangle(
          leftWallWidth / 2,
          thickness / 2,
          leftWallWidth,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Top wall - Right segment - with bounce and collision filter
        const rightWallStart = woundX + woundWidth / 2;
        const rightWallWidth = width - rightWallStart;
        const topWallRight = Bodies.rectangle(
          rightWallStart + rightWallWidth / 2,
          thickness / 2,
          rightWallWidth,
          thickness,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "wall",
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        // Wound edge markers (left and right edges of wound)
        const woundEdgeLeft = Bodies.rectangle(
          woundX - woundWidth / 2,
          thickness / 2,
          6,
          thickness + 10,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "woundEdge",
            isSensor: false,
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        const woundEdgeRight = Bodies.rectangle(
          woundX + woundWidth / 2,
          thickness / 2,
          6,
          thickness + 10,
          {
            isStatic: true,
            render: { visible: false }, // Renderizado personalizado
            label: "woundEdge",
            isSensor: false,
            restitution: 0.8, // Higher restitution for stronger bounce
            friction: 0.1,
            collisionFilter: {
              category: 0x0004, // Wall category
              mask: 0xffffffff, // Collide with everything
            },
          }
        );

        Composite.add(engine.world, [
          bottomWall,
          topWallLeft,
          topWallRight,
          woundEdgeLeft,
          woundEdgeRight,
        ]);

        // Create invisible anchor platelets on each side of the wound
        createInvisibleAnchorPlatelets(woundX, woundWidth, thickness);
      }

      function createInvisibleAnchorPlatelets(
        woundX,
        woundWidth,
        wallThickness
      ) {
        const adhesionLineY = 23; // Same Y position as the adhesion line
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Left anchor platelet - positioned just inside the left edge of the wound
        const leftAnchorX = woundLeft + 2;
        const leftAnchor = Bodies.circle(leftAnchorX, adhesionLineY + 6, 4, {
          isStatic: true,
          render: { fillStyle: "transparent", visible: false },
          label: "platelet",
          isStuck: true,
          isAnchor: true, // Mark as anchor platelet
        });

        // Right anchor platelet - positioned just inside the right edge of the wound
        const rightAnchorX = woundRight - 10;
        const rightAnchor = Bodies.circle(rightAnchorX, adhesionLineY + 6, 4, {
          isStatic: true,
          render: { fillStyle: "transparent", visible: false },
          label: "platelet",
          isStuck: true,
          isAnchor: true, // Mark as anchor platelet
        });

        Composite.add(engine.world, [leftAnchor, rightAnchor]);

        // Add to stuck platelets list so they can form fibrin connections
        const leftAnchorData = {
          body: leftAnchor,
          constraint: null,
          hasFibrin: false,
          fibrinConnections: [],
          isAnchor: true,
        };

        const rightAnchorData = {
          body: rightAnchor,
          constraint: null,
          hasFibrin: false,
          fibrinConnections: [],
          isAnchor: true,
        };

        state.stuckPlatelets.push(leftAnchorData, rightAnchorData);

        // Try to form fibrin connections from anchor platelets after a delay
        setTimeout(() => {
          if (state.stuckPlatelets.includes(leftAnchorData)) {
            tryFormFibrin(leftAnchorData);
          }
          if (state.stuckPlatelets.includes(rightAnchorData)) {
            tryFormFibrin(rightAnchorData);
          }
        }, 200);
      }

      function createParticle(type) {
        const y = 50 + Math.random() * 200;
        const x = -10;

        let body;

        switch (type) {
          case "platelet":
            // En Von Willebrand, las plaquetas tienen alta restitución (rebotan)
            const conditionConfig = CONFIG.conditions[state.condition];
            const plateletRestitution = 
              (state.condition === "vwd" && !state.treatmentApplied) 
                ? 0.9 // Alta restitución para vWD - rebotan en lugar de adherirse
                : 0.5; // Rebote medio normal
            
            body = Bodies.circle(x, y, 4, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "platelet",
              restitution: plateletRestitution,
              friction: 0.1,
              frictionAir: 0.02, // Reducido para que se muevan más rápido, pero aún suficiente para adhesión
              density: 0.001,
              isSticky: true,
              isStuck: false,
              collisionFilter: {
                group: 0,
                category: 0x0001,
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            // Rastrear plaquetas spawnadas
            state.plateletsSpawned++;
            break;

          case "rbc":
            // Glóbulos rojos: usar círculo pero renderizar como elipse en custom render
            body = Bodies.circle(x, y, 6, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "rbc",
              restitution: 0.5, // Rebote medio - ligero, relleno visual
              friction: 0.05,
              frictionAir: 0.01,
              density: 0.0008, // Ligero
              collisionFilter: {
                group: 0,
                category: 0x0001, // RBC category
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            break;

          case "wbc":
            body = Bodies.circle(x, y, 10, {
              render: {
                fillStyle: "transparent",
                strokeStyle: "transparent",
                visible: false, // No renderizar con Matter.js - solo custom
              },
              label: "wbc",
              restitution: 0.7,
              friction: 0.1,
              frictionAir: 0.03,
              density: 0.04, // Pesado - obstáculo visual
              collisionFilter: {
                group: 0,
                category: 0x0001, // WBC category
                mask: 0x0002 | 0x0004, // Collide with fibrin barriers and walls
              },
            });
            break;
        }

        if (body) {
          // Aplicar velocidad inicial basada en la fuerza del flujo para que aparezcan ya con velocidad normal
          // Calcular velocidad inicial basada en la fuerza promedio del flujo
          // Simula que la partícula ya ha estado acelerándose por un tiempo
          const flowForceAvg = (CONFIG.physics.flowForceMin + CONFIG.physics.flowForceMax) / 2;
          // Velocidad inicial: simula ~1 segundo de aceleración previa
          // v = a * t, donde a = F/m y t = tiempo de aceleración
          const accelerationTime = 1.0; // 1 segundo de aceleración previa
          const acceleration = flowForceAvg / body.mass; // a = F/m
          const initialVelocityX = acceleration * accelerationTime;
          
          Body.setVelocity(body, {
            x: Math.max(0.02, initialVelocityX), // Mínimo para asegurar movimiento visible
            y: 0, // Sin velocidad vertical inicial
          });
          
          Composite.add(engine.world, body);
          state.allBodies.push(body);
        }

        return body;
      }

      // Variables para tracking de spawn
      let spawnStats = {
        lastSpawnCount: 0,
        totalSpawned: 0,
        spawnHistory: [], // Últimos 10 conteos de spawn
      };

      function startParticleSpawning() {
        // Clear any existing timeout
        if (spawnInterval !== null) {
          clearTimeout(spawnInterval);
          spawnInterval = null;
        }
        // spawnIntervalCounter removido

        lastSpawnTime = performance.now();
        actualSpawnIntervals = [];
        spawnStats = {
          lastSpawnCount: 0,
          totalSpawned: 0,
          spawnHistory: [],
        };

        // Función para spawnear partículas
        const spawnParticles = () => {
          // Solo spawnear si la simulación está corriendo
          if (!state.simulationRunning) {
            return;
          }

          const currentTime = performance.now();
          const actualInterval = currentTime - lastSpawnTime;

          // Registrar el intervalo real para el contador
          actualSpawnIntervals.push(actualInterval);
          if (actualSpawnIntervals.length > 20) {
            actualSpawnIntervals.shift(); // Mantener solo los últimos 20
          }

          let spawnedThisCycle = 0;

          // Contar solo partículas móviles (no pegadas) para el límite de spawn
          const mobileBodies = state.allBodies.filter((b) => {
            return !state.stuckPlatelets.some((p) => p.body === b);
          });

          if (mobileBodies.length < CONFIG.particles.maxCount) {
            const conditionConfig = CONFIG.conditions[state.condition];
            const plateletRatio = conditionConfig.plateletRatio;

            // Apply spawn rate multiplier for conditions like thrombocytopenia
            const spawnMultiplier = conditionConfig.spawnRateMultiplier || 1.0;
            const spawnCount = Math.max(
              1,
              Math.floor(CONFIG.particles.spawnRate * spawnMultiplier)
            );

            for (let i = 0; i < spawnCount; i++) {
              // Verificar límite con partículas móviles actualizadas
              const currentMobileCount = state.allBodies.filter((b) => {
                return !state.stuckPlatelets.some((p) => p.body === b);
              }).length;
              if (currentMobileCount >= CONFIG.particles.maxCount) break;

              const rand = Math.random();

              if (rand < plateletRatio) {
                createParticle("platelet");
                spawnedThisCycle++;
              } else if (rand < plateletRatio + CONFIG.particles.rbcRatio) {
                createParticle("rbc");
                spawnedThisCycle++;
              } else {
                createParticle("wbc");
                spawnedThisCycle++;
              }
            }
          }

          // Registrar estadísticas de spawn
          spawnStats.lastSpawnCount = spawnedThisCycle;
          spawnStats.totalSpawned += spawnedThisCycle;
          spawnStats.spawnHistory.push(spawnedThisCycle);
          if (spawnStats.spawnHistory.length > 10) {
            spawnStats.spawnHistory.shift();
          }

          lastSpawnTime = currentTime;
        };

        // Función recursiva que mantiene intervalo constante en tiempo real (8-10 partículas/segundo)
        const scheduleNextSpawn = () => {
          if (!state.simulationRunning) return;

          // Intervalo variable entre 100-150ms (promedio 125ms) - siempre constante en tiempo real
          // Esto garantiza 8-10 partículas por segundo independientemente de la velocidad de simulación
          const variableInterval = 100 + Math.random() * 50; // 100-150ms

          spawnInterval = setTimeout(() => {
            spawnParticles();
            scheduleNextSpawn(); // Programar siguiente spawn con nuevo intervalo
          }, variableInterval);
        };

        // Iniciar el ciclo de spawn solo si la simulación está corriendo
        if (state.simulationRunning) {
          scheduleNextSpawn();
        }

        // Contador de spawn removido
      }

      function toggleSimulation() {
        if (!state.simulationRunning) {
          // Iniciar simulación
          state.simulationRunning = true;
          state.isPaused = false;
          state.startTime = Date.now();
          state.adhesionTime = null;
          state.closureTime = null;
          state.plateletsSpawned = 0;
          state.history = {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          };
          // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
          lastPhysicsTime = 0;
          accumulatedTime = 0;

          // Asegurar que timeScale tenga un valor válido
          if (!state.timeScale || state.timeScale <= 0) {
            state.timeScale = 1.0;
          }

          // Reiniciar el spawn para asegurar que funcione
          startParticleSpawning();

          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitar botón de inicio cuando está corriendo
          }
          if (pauseBtn) {
            pauseBtn.disabled = false; // Habilitar botón de pausa cuando está corriendo
          }
          
          // Habilitar botón de tratamiento cuando la simulación está corriendo
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied) {
            treatmentBtn.disabled = false;
          }
          
        } else {
          // Pausar simulación
          state.simulationRunning = false;
          state.isPaused = true;
          // No usar Runner.stop() - usamos nuestro propio loop
          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = false; // Habilitar botón de inicio cuando está pausada
          }
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar botón de pausa cuando está pausada
          }
          
          // El botón de tratamiento permanece habilitado cuando la simulación está pausada
          // (siempre que se haya iniciado al menos una vez y no se haya aplicado ya)
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied && state.startTime) {
            treatmentBtn.disabled = false;
          }
          
        }
      }

      function applyForces(timestep = 16.67) {
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Invisible adhesion line parameters - positioned at wound opening
        const adhesionLineY = 23; // Y position center of the adhesion zone
        const adhesionLineThreshold = 25; // Width of adhesion zone (más ancho para efecto de profundidad)
        const adhesionDetectionThreshold = 8; // Umbral más estricto para detectar adhesión (solo cuando está muy cerca)

        // IMPORTANTE: Con Runner.isFixed = true y delta = 16.67ms,
        // el timestep siempre es constante independientemente del FPS del renderer.
        // El Runner ejecuta pasos de física a intervalos fijos, y cada paso siempre es de 16.67ms.
        // Por lo tanto, timeScale siempre debe ser 1.0 para mantener velocidad constante.
        // NO escalamos por el timestep real porque ya está fijo en 16.67ms.
        const timeScale = 1.0; // Siempre 1.0 porque el timestep es fijo

        state.allBodies.forEach((body) => {
          // Skip stuck platelets and static bodies
          if (body.isStuck || body.isStatic) return;

          // Prevent particles from passing through walls by checking bounds
          const { width, height } = CONFIG.canvas;
          const wallThickness = CONFIG.wall.thickness;
          const particleRadius =
            body.circleRadius ||
            (body.label === "rbc" ? 6 : body.label === "wbc" ? 10 : 4);

          // Check bottom wall
          if (body.position.y > height - wallThickness - particleRadius) {
            Body.setPosition(body, {
              x: body.position.x,
              y: height - wallThickness - particleRadius - 0.1,
            });
            Body.setVelocity(body, {
              x: body.velocity.x,
              y: Math.min(0, body.velocity.y * -0.8), // Bounce up
            });
          }

          // Check top walls (left and right segments)
          const woundX = CONFIG.wound.x;
          const woundWidth = CONFIG.wound.width;
          const woundLeft = woundX - woundWidth / 2;
          const woundRight = woundX + woundWidth / 2;

          if (body.position.y < wallThickness + particleRadius) {
            // Check if particle is in wound area
            if (body.position.x < woundLeft || body.position.x > woundRight) {
              // Outside wound - push back from top wall
              Body.setPosition(body, {
                x: body.position.x,
                y: wallThickness + particleRadius + 0.1,
              });
              Body.setVelocity(body, {
                x: body.velocity.x,
                y: Math.max(0, body.velocity.y * -0.8), // Bounce down
              });
            }
          }

          // Laminar flow force (right) con pulso cardíaco (sístole/diástole)
          // Simular pulso cardíaco con función seno: oscila entre flowForceMin y flowForceMax
          // Usar tiempo de simulación acumulado (ajustado por timeScale) para que el pulso se acelere/ralentice con la velocidad
          const heartRate = 0.6; // Latidos por segundo (36 bpm) - muy lento para ser extremadamente visible
          const currentTime = accumulatedSimulationTime / 1000; // Tiempo de simulación en segundos (ajustado por timeScale)
          const pulseFactor = Math.sin(currentTime * heartRate * Math.PI * 2);
          // Mapear seno (-1 a 1) al rango de fuerzas (min a max)
          // Calcular fuerza con pulso: oscila suavemente entre min y max
          // Cuando pulseFactor = -1 → flowForce = min
          // Cuando pulseFactor = 1 → flowForce = max
          const pulseRange = CONFIG.physics.flowForceMax - CONFIG.physics.flowForceMin;
          const flowForce = CONFIG.physics.flowForceMin + 
            (pulseRange / 2) * (1 + pulseFactor); // Mapea seno(-1 a 1) a (min a max)
          
          // Aplicar fuerza laminar con pulso
          Body.applyForce(body, body.position, {
            x: flowForce * body.mass * timeScale,
            y: 0,
          });

          // Suction force (vertical hacia arriba) - solo bajo la herida
          // Desactivar succión cuando la herida está cerrada
          if (!state.hemostasisAchieved) {
            // Aplicar succión vertical hacia arriba en el área de la herida
            // Área de succión desplazada un poco a la izquierda
            const suctionOffset = 35; // Desplazamiento hacia la izquierda
            const suctionLeft = woundLeft - suctionOffset;
            const suctionRight = woundRight - suctionOffset;
            
            if (
              body.position.x > suctionLeft &&
              body.position.x < suctionRight &&
              body.position.y < 250
            ) {
              const distanceToWound = Math.abs(body.position.y - 20);
              // Succión más fuerte cerca de la herida, disminuye con la distancia
              const suctionStrength =
                Math.abs(CONFIG.physics.suctionForce) * (1 - distanceToWound / 230);

              Body.applyForce(body, body.position, {
                x: 0,
                y: CONFIG.physics.suctionForce * body.mass * timeScale, // Vertical hacia arriba (negativo)
              });
            }
          }

          // FIBRIN NET BOUNCE - Make RBCs and WBCs bounce off fibrin network
          if (
            (body.label === "rbc" || body.label === "wbc") &&
            state.fibrinConstraints.length > 0
          ) {
            const cellRadius = body.label === "rbc" ? 6 : 10;
            const bounceThreshold = cellRadius + 6; // Increased detection threshold
            const bounceStrength = body.label === "rbc" ? 0.008 : 0.012; // Much stronger bounce force
            const cellPos = body.position;

            // Only check fibrin near the wound area for performance
            const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2 - 30;
            const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2 + 30;

            if (
              cellPos.x >= woundLeft &&
              cellPos.x <= woundRight &&
              cellPos.y < 120
            ) {
              for (let i = 0; i < state.fibrinConstraints.length; i++) {
                const fibrin = state.fibrinConstraints[i];
                const pointA = fibrin.pointA.position;
                const pointB = fibrin.pointB.position;

                if (!pointA || !pointB) continue;

                // Quick bounds check - skip if fibrin line is far from cell
                const minX = Math.min(pointA.x, pointB.x);
                const maxX = Math.max(pointA.x, pointB.x);
                const minY = Math.min(pointA.y, pointB.y);
                const maxY = Math.max(pointA.y, pointB.y);

                if (
                  cellPos.x < minX - bounceThreshold ||
                  cellPos.x > maxX + bounceThreshold ||
                  cellPos.y < minY - bounceThreshold ||
                  cellPos.y > maxY + bounceThreshold
                ) {
                  continue;
                }

                // Calculate distance from cell to fibrin line segment
                const lineVec = Vector.sub(pointB, pointA);
                const lineLength = Vector.magnitude(lineVec);

                if (lineLength < 0.1) continue; // Skip very short lines

                const toCell = Vector.sub(cellPos, pointA);
                const lineLengthSq = lineLength * lineLength;
                const t = Math.max(
                  0,
                  Math.min(1, Vector.dot(toCell, lineVec) / lineLengthSq)
                );
                const closestPoint = Vector.add(
                  pointA,
                  Vector.mult(lineVec, t)
                );
                const distVec = Vector.sub(cellPos, closestPoint);
                const distance = Vector.magnitude(distVec);
                const bounceThresholdSq = bounceThreshold * bounceThreshold;
                const distanceSq = distance * distance;

                // If cell is close to fibrin line, apply bounce force (or allow passage if weak)
                if (distanceSq < bounceThresholdSq && distance > 0.1) {
                  // Get fibrin stability - affects barrier effectiveness
                  const fibrinStability = fibrin.stability || 1.0;

                  // Si está sellado, bloquear completamente el paso
                  const passThroughChance = state.hemostasisAchieved
                    ? 0
                    : (1 - fibrinStability) * 0.3; // Up to 30% chance for very weak fibrin

                  if (Math.random() < passThroughChance) {
                    // Cell passes through weak fibrin - reduce velocity slightly
                    Body.setVelocity(body, {
                      x: body.velocity.x * 0.9,
                      y: body.velocity.y * 0.9,
                    });
                    continue; // Skip bounce for this fibrin connection
                  }

                  // Normalize distance vector to get bounce direction
                  const bounceDir = {
                    x: distVec.x / distance,
                    y: distVec.y / distance,
                  };

                  // Calculate velocity component towards the line
                  const velocityDot =
                    body.velocity.x * bounceDir.x +
                    body.velocity.y * bounceDir.y;

                  // Only apply bounce if moving towards the line
                  if (velocityDot < 0) {
                    // Bounce force reduced by stability - weaker fibrin = weaker bounce
                    const proximityFactor = 1 - distance / bounceThreshold;
                    const stabilityMultiplier = 0.3 + fibrinStability * 0.7; // 0.3-1.0 range
                    const bounceForce =
                      bounceStrength *
                      proximityFactor *
                      proximityFactor *
                      stabilityMultiplier;

                    // Scale bounce force by timestep for frame independence (use timeScale from function scope)
                    Body.applyForce(body, body.position, {
                      x: bounceDir.x * bounceForce * body.mass * 10 * timeScale,
                      y: bounceDir.y * bounceForce * body.mass * 10 * timeScale,
                    });

                    // Invert velocity component - effectiveness depends on stability
                    const bounceFactor =
                      0.5 + fibrinStability * 0.3 + proximityFactor * 0.2; // 0.5-1.0 range
                    Body.setVelocity(body, {
                      x:
                        body.velocity.x -
                        bounceDir.x * velocityDot * bounceFactor,
                      y:
                        body.velocity.y -
                        bounceDir.y * velocityDot * bounceFactor,
                    });

                    // Push cell away from the line - less effective for weak fibrin
                    const pushDistance =
                      (bounceThreshold - distance) * 0.3 * fibrinStability;
                    Body.setPosition(body, {
                      x: body.position.x + bounceDir.x * pushDistance,
                      y: body.position.y + bounceDir.y * pushDistance,
                    });
                  }
                }
              }
            }
          }

          // INVISIBLE ADHESION LINE - Check if platelet crosses the invisible line
          if (body.label === "platelet" && !body.isStuck) {
            const inWoundZone =
              body.position.x > woundLeft && body.position.x < woundRight;
            // Usar umbral más estricto para detectar adhesión (solo cuando está muy cerca del centro)
            const distanceFromCenter = Math.abs(
              body.position.y - adhesionLineY
            );
            const nearAdhesionLine = distanceFromCenter < adhesionLineThreshold; // Área amplia para variación
            const veryCloseToCenter = distanceFromCenter < 8; // Solo adherir cuando está muy cerca del centro

            if (inWoundZone && nearAdhesionLine && veryCloseToCenter) {
              const conditionConfig = CONFIG.conditions[state.condition];
              const canStick = state.treatmentApplied
                ? true
                : conditionConfig.canStick;
              // Reducir probabilidad base de adhesión
              const stickProb = state.treatmentApplied
                ? 0.7
                : conditionConfig.stickProbability * 0.3;

              // Check platelet function first
              if (
                !state.treatmentApplied &&
                Math.random() > conditionConfig.plateletFunction
              ) {
                // Platelet dysfunction - let it pass through fibrin network instead of bouncing
                // Reduce restitution to prevent bouncing and allow passage
                body.restitution = 0;
                Body.setVelocity(body, {
                  x: body.velocity.x * 0.95,
                  y: body.velocity.y * 0.95,
                });
                return;
              }

              // Fuerza de adhesión ajustada (un poco más alta que antes)
              const baseAdhesionStrength = state.treatmentApplied
                ? 0.5
                : conditionConfig.adhesionStrength * 0.2;

              // Añadir factor de distancia: más cerca del centro = mayor probabilidad
              // Solo adherir si está muy cerca del centro (dentro de 6px)
              const distanceFactor = Math.max(0.3, 1 - distanceFromCenter / 6); // Factor moderado
              const finalAdhesionStrength =
                baseAdhesionStrength * distanceFactor;

              // Añadir factor de velocidad: plaquetas más lentas tienen mayor probabilidad
              const speed = Math.sqrt(
                body.velocity.x * body.velocity.x +
                  body.velocity.y * body.velocity.y
              );
              const speedFactor = Math.max(0.5, 1 - speed / 0.4); // Factor de velocidad moderado
              const finalAdhesionWithSpeed =
                finalAdhesionStrength * speedFactor;

              if (canStick && Math.random() < finalAdhesionWithSpeed) {
                // Stick to the invisible line
                stickPlateletToLine(body, adhesionLineY, conditionConfig);
              } else if (
                !state.treatmentApplied &&
                conditionConfig.adhesionRetryChance
              ) {
                // Retry adhesion chance
                setTimeout(() => {
                  if (
                    !body.isStuck &&
                    Math.random() < conditionConfig.adhesionRetryChance
                  ) {
                    if (canStick && Math.random() < adhesionStrength) {
                      stickPlateletToLine(body, adhesionLineY, conditionConfig);
                    }
                  }
                }, 100);
              } else {
                // Las plaquetas que no se adhieren atraviesan la malla en lugar de rebotar
                // Reducir restitution para evitar rebotes y permitir paso
                body.restitution = 0;
                Body.setVelocity(body, {
                  x: body.velocity.x * 0.95,
                  y: body.velocity.y * 0.95,
                });
              }
            }
          }
        });

        // For hemophilia and conditions with unstable fibrin - apply extra force to dislodge weakly attached platelets
        const conditionConfig = CONFIG.conditions[state.condition];
        if (
          (state.condition === "hemophilia" ||
            state.condition === "hemophiliaSevere" ||
            conditionConfig.fibrinStability < 0.5) &&
          !state.treatmentApplied
        ) {
          state.stuckPlatelets.forEach((platelet) => {
            if (
              !platelet.hasFibrin ||
              platelet.fibrinConnections.length === 0
            ) {
              // Gradually increase dislodge force for platelets without fibrin support - scaled by timestep
              const dislodgeForce =
                0.00015 * (1 - conditionConfig.fibrinStability);
              Body.applyForce(platelet.body, platelet.body.position, {
                x: 0,
                y:
                  -dislodgeForce *
                  platelet.body.mass *
                  (1 + Math.random()) *
                  timeScale,
              });
            }
          });
        }
      }

      function stickPlateletToLine(platelet, lineY, conditionConfig) {
        if (platelet.isStuck) return;

        platelet.isStuck = true;

        // Apply visual effects based on condition
        const visualEffects =
          conditionConfig.visualEffects ||
          CONFIG.conditions.normal.visualEffects;
        platelet.render.fillStyle = visualEffects.plateletColor || "#808080";

        // Stop movement and position within the adhesion zone (efecto de profundidad)
        Body.setVelocity(platelet, { x: 0, y: 0 });
        // Variar la posición Y dentro del área de adhesión para crear profundidad
        // Las plaquetas pueden adherirse en un rango simétrico alrededor de la línea central
        const adhesionZoneHalfWidth = 12; // Mitad del ancho del área de adhesión
        const adhesionZoneTop = lineY - adhesionZoneHalfWidth;
        const adhesionZoneBottom = lineY + adhesionZoneHalfWidth;
        // Posición aleatoria dentro del área de adhesión, con distribución normal centrada
        // Usar la posición actual de la plaqueta como referencia, pero limitada al área de adhesión
        const currentY = platelet.position.y;
        const targetY = Math.max(
          adhesionZoneTop,
          Math.min(adhesionZoneBottom, currentY)
        );
        // Añadir pequeña variación aleatoria para efecto de profundidad
        const randomVariation = (Math.random() - 0.5) * 4; // Variación de ±2 píxeles
        const stickY = Math.max(
          adhesionZoneTop,
          Math.min(adhesionZoneBottom, targetY + randomVariation)
        );
        Body.setPosition(platelet, { x: platelet.position.x, y: stickY });

        // Make platelet completely static so it doesn't move
        Body.setStatic(platelet, true);

        // Create constraint to the adhesion point - maximum stiffness
        const constraint = Constraint.create({
          bodyA: platelet,
          pointB: { x: platelet.position.x, y: stickY },
          stiffness: 1.0, // Maximum stiffness
          damping: 1.0, // Maximum damping
          length: 0,
          render: { visible: false },
        });

        Composite.add(engine.world, constraint);

        const plateletData = {
          body: platelet,
          constraint: constraint,
          hasFibrin: false,
          fibrinConnections: [],
          condition: state.condition,
          stuckAt: Date.now(), // Timestamp para identificar las más antiguas
          isAnchor: false,
        };

        state.stuckPlatelets.push(plateletData);

        // Rastrear primera adhesión
        if (!state.adhesionTime && state.startTime) {
          state.adhesionTime = Date.now();
        }

        // Limitar el número de plaquetas pegadas para mantener rendimiento
        cleanupOldStuckPlatelets();

        // Ocultar cartel cuando hay plaquetas pegadas
        const woundLabel = document.getElementById("wound-label");
        if (state.stuckPlatelets.length > 0) {
          woundLabel.classList.add("hidden");
        }

        // Secuencia: plaquetas primero, luego malla
        // Activar formación de fibrina solo después de umbral de plaquetas
        // Con tratamiento, reducir el umbral mínimo de plaquetas
        const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
        if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
          state.fibrinStarted = true;

          // Try to form fibrin after delay if specified
          // Con tratamiento, reducir significativamente el delay
          const baseDelay = conditionConfig.fibrinFormationDelay || 150;
          const delay = state.treatmentApplied
            ? Math.max(50, baseDelay * 0.3)
            : baseDelay;
          setTimeout(() => {
            if (state.stuckPlatelets.includes(plateletData)) {
              tryFormFibrin(plateletData);

              // Also try to form fibrin from nearby anchor platelets
              state.stuckPlatelets.forEach((other) => {
                if (other.isAnchor && other.body) {
                  const dist = Vector.magnitude(
                    Vector.sub(plateletData.body.position, other.body.position)
                  );
                  if (dist < 80) {
                    tryFormFibrin(other);
                  }
                }
              });
            }
          }, delay);
        }
      }

      function cleanupOldStuckPlatelets() {
        const maxStuckPlatelets = CONFIG.stuckPlatelets.maxCount;

        // Si no excedemos el límite, no hacer nada
        if (state.stuckPlatelets.length <= maxStuckPlatelets) {
          return;
        }

        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const woundAreaMargin = 100; // Margen alrededor de la herida para considerar "relevante"

        // Ordenar plaquetas pegadas por timestamp (más antiguas primero)
        // Pero excluir las anchor platelets y las que están cerca de la herida
        const plateletsToConsider = state.stuckPlatelets
          .filter((p) => !p.isAnchor) // No eliminar anchor platelets
          .map((p) => ({
            data: p,
            distance: Math.abs(p.body.position.x - woundX),
            isNearWound:
              p.body.position.x >= woundLeft - woundAreaMargin &&
              p.body.position.x <= woundRight + woundAreaMargin &&
              p.body.position.y >= 20 &&
              p.body.position.y <= 100,
          }))
          .sort((a, b) => {
            // Priorizar eliminar las que están lejos de la herida
            if (a.isNearWound && !b.isNearWound) return 1;
            if (!a.isNearWound && b.isNearWound) return -1;
            // Si ambas están cerca o lejos, ordenar por timestamp (más antiguas primero)
            return (a.data.stuckAt || 0) - (b.data.stuckAt || 0);
          });

        // Calcular cuántas necesitamos eliminar
        const toRemove = state.stuckPlatelets.length - maxStuckPlatelets;

        // Eliminar las más antiguas que están lejos de la herida
        for (let i = 0; i < toRemove && i < plateletsToConsider.length; i++) {
          const plateletData = plateletsToConsider[i].data;

          // Eliminar constraints de fibrina conectados
          for (let j = state.fibrinConstraints.length - 1; j >= 0; j--) {
            const fibrin = state.fibrinConstraints[j];
            if (
              fibrin.pointA === plateletData.body ||
              fibrin.pointB === plateletData.body
            ) {
              removeFibrinConnection(fibrin);
            }
          }

          // Eliminar constraint de la plaqueta
          if (plateletData.constraint) {
            Composite.remove(engine.world, plateletData.constraint);
          }

          // Eliminar el body
          Composite.remove(engine.world, plateletData.body);

          // Eliminar de la lista
          const index = state.stuckPlatelets.indexOf(plateletData);
          if (index > -1) {
            state.stuckPlatelets.splice(index, 1);
          }

          // Eliminar de allBodies
          const bodyIndex = state.allBodies.indexOf(plateletData.body);
          if (bodyIndex > -1) {
            state.allBodies.splice(bodyIndex, 1);
          }
        }
      }

      function cleanupParticles() {
        const toRemove = [];
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        // Optimized cleanup: iterate backwards for better performance when removing
        for (let i = state.allBodies.length - 1; i >= 0; i--) {
          const body = state.allBodies[i];
          const px = body.position.x;
          const py = body.position.y;

          // Solo eliminar partículas móviles (no pegadas) en la limpieza básica
          const isStuck = state.stuckPlatelets.some((p) => p.body === body);

          if (!isStuck) {
            // Remove particles that exit right (eliminar cuando salen completamente del canvas)
            if (px > CONFIG.canvas.width + 20) {
              toRemove.push(body);
            }
            // Remove particles that exit top (blood loss)
            else if (py < -20) {
              toRemove.push(body);
              state.bloodLoss++;
            }
            // Remove particles that exit through the wound (upward)
            else if (py < 10 && px >= woundLeft - 5 && px <= woundRight + 5) {
              toRemove.push(body);
              state.bloodLoss++;
            }
            // Remove particles way off screen (bottom or left)
            else if (py > CONFIG.canvas.height + 20 || px < -30) {
              toRemove.push(body);
            }
          }
        }

        // Optimized removal: use Map for faster lookups
        const bodySet = new Set(toRemove);

        toRemove.forEach((body) => {
          // Remove associated constraints if it's a stuck platelet
          const plateletIndex = state.stuckPlatelets.findIndex(
            (p) => p.body === body
          );
          if (plateletIndex !== -1) {
            const plateletData = state.stuckPlatelets[plateletIndex];

            // Remove fibrin constraints connected to this platelet (iterate backwards)
            for (let i = state.fibrinConstraints.length - 1; i >= 0; i--) {
              const fibrin = state.fibrinConstraints[i];
              if (fibrin.pointA === body || fibrin.pointB === body) {
                removeFibrinConnection(fibrin);
              }
            }

            // Remove platelet constraint
            if (plateletData.constraint) {
              Composite.remove(engine.world, plateletData.constraint);
            }

            // Remove from stuck platelets list (but not anchor platelets)
            if (!plateletData.isAnchor) {
              state.stuckPlatelets.splice(plateletIndex, 1);
            }
          }

          Composite.remove(engine.world, body);
        });

        // Remove from allBodies array (more efficient)
        state.allBodies = state.allBodies.filter((b) => !bodySet.has(b));

        // Limpieza agresiva: eliminar partículas que están cerca del borde derecho
        // Esto asegura que las partículas se eliminen antes de llegar al límite máximo
        const aggressiveCleanupThreshold = CONFIG.particles.maxCount * 0.7; // 70% del límite (105 partículas)
        if (state.allBodies.length > aggressiveCleanupThreshold) {
          const additionalToRemove = [];

          for (let i = state.allBodies.length - 1; i >= 0; i--) {
            const body = state.allBodies[i];
            if (!body || !body.position) continue;

            const px = body.position.x;
            const py = body.position.y;

            // Solo eliminar partículas móviles (no pegadas)
            const isStuck = state.stuckPlatelets.some((p) => p.body === body);
            if (isStuck) continue;

            // Eliminar partículas que están muy cerca del borde derecho (dentro de 30px del final)
            if (px > CONFIG.canvas.width - 30) {
              additionalToRemove.push(body);
            }
            // También eliminar partículas que están muy abajo (fuera de la vista útil)
            else if (py > CONFIG.canvas.height - 10) {
              additionalToRemove.push(body);
            }
          }

          // Eliminar las partículas adicionales encontradas
          additionalToRemove.forEach((body) => {
            try {
              Composite.remove(engine.world, body);
              const index = state.allBodies.indexOf(body);
              if (index > -1) {
                state.allBodies.splice(index, 1);
              }
            } catch (e) {
              // Ignorar errores si el body ya fue eliminado
            }
          });
        }
      }

      function setupCollisionEvents() {
        Events.on(engine, "collisionStart", (event) => {
          event.pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            // Check for platelet collision with wound edges or stuck platelets
            handlePlateletCollision(bodyA, bodyB);
            handlePlateletCollision(bodyB, bodyA);

            // Handle weak fibrin barrier collisions - allow occasional passage
            handleFibrinBarrierCollision(bodyA, bodyB);
            handleFibrinBarrierCollision(bodyB, bodyA);
          });
        });
      }

      function handleFibrinBarrierCollision(cell, barrier) {
        // Check if cell (RBC/WBC) collides with fibrin barrier
        if (
          (cell.label !== "rbc" && cell.label !== "wbc") ||
          barrier.label !== "fibrinBarrier"
        ) {
          return;
        }

        // Get fibrin stability from barrier
        const fibrinStability = barrier.fibrinStability || 1.0;

        // Si está sellado, bloquear completamente el paso
        if (state.hemostasisAchieved) {
          return; // No permitir paso cuando está sellado
        }

        // Weak fibrin occasionally allows cells to pass through
        if (fibrinStability < 0.6) {
          const passThroughChance = (1 - fibrinStability) * 0.4; // Up to 40% chance for very weak fibrin

          if (Math.random() < passThroughChance) {
            // Allow cell to pass through - make barrier temporarily non-collidable
            barrier.collisionFilter.mask = 0x0000; // No collisions

            // Restore collision after a short time
            setTimeout(() => {
              if (barrier.label === "fibrinBarrier") {
                barrier.collisionFilter.mask = 0x0001;
              }
            }, 500);

            // Reduce cell velocity slightly as it passes through
            Body.setVelocity(cell, {
              x: cell.velocity.x * 0.85,
              y: cell.velocity.y * 0.85,
            });
          } else {
            // Reduce bounce effectiveness for weak fibrin
            const bounceReduction = 1 - fibrinStability;
            Body.setVelocity(cell, {
              x: cell.velocity.x * (1 - bounceReduction * 0.3),
              y: cell.velocity.y * (1 - bounceReduction * 0.3),
            });
          }
        }
      }

      function handlePlateletCollision(platelet, other) {
        if (platelet.label !== "platelet" || platelet.isStuck) return;

        const conditionConfig = CONFIG.conditions[state.condition];

        // Check platelet function first
        if (
          !state.treatmentApplied &&
          Math.random() > conditionConfig.plateletFunction
        ) {
          // Platelet dysfunction - let it pass through instead of bouncing
          // Reduce restitution to prevent bouncing and allow passage
          platelet.restitution = 0;
          Body.setVelocity(platelet, {
            x: platelet.velocity.x * 0.95,
            y: platelet.velocity.y * 0.95,
          });
          return;
        }

        const canStick = state.treatmentApplied
          ? true
          : conditionConfig.canStick;
        const adhesionStrength = state.treatmentApplied
          ? 0.95
          : conditionConfig.adhesionStrength;

        // Check if collision is with wound edge or stuck platelet
        const isWoundEdge = other.label === "woundEdge";
        const isStuckPlatelet = other.label === "platelet" && other.isStuck;

        if (isWoundEdge || isStuckPlatelet) {
          // Check if in wound zone
          const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
          const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;

          if (
            platelet.position.x >= woundLeft - 20 &&
            platelet.position.x <= woundRight + 20 &&
            platelet.position.y < 45
          ) {
            // Check aggregation rate for platelet-to-platelet adhesion
            // En vWD sin tratamiento, las plaquetas no se agregan (no hay cemento vWF)
            if (isStuckPlatelet) {
              const aggregationRate = state.treatmentApplied
                ? 0.9
                : conditionConfig.aggregationRate;
              if (Math.random() > aggregationRate) {
                // Failed aggregation - plaquetas rebotan/se separan (sin cemento vWF)
                platelet.restitution = 0.9;
                // En vWD, rebote más fuerte para simular que no hay cemento
                const bounceStrength =
                  state.condition === "vwd" && !state.treatmentApplied
                    ? 1.5
                    : 1.0;
                Body.setVelocity(platelet, {
                  x: platelet.velocity.x * (0.8 * bounceStrength),
                  y: Math.abs(platelet.velocity.y) * (1.2 * bounceStrength) + 1,
                });
                return;
              }
            }

            if (canStick && Math.random() < adhesionStrength) {
              stickPlatelet(platelet, other, conditionConfig);
            } else if (
              !state.treatmentApplied &&
              conditionConfig.adhesionRetryChance
            ) {
              // Retry adhesion chance
              setTimeout(() => {
                if (
                  !platelet.isStuck &&
                  Math.random() < conditionConfig.adhesionRetryChance
                ) {
                  if (canStick && Math.random() < adhesionStrength) {
                    stickPlatelet(platelet, other, conditionConfig);
                  }
                }
              }, 100);
            } else {
              // Las plaquetas que no se adhieren atraviesan en lugar de rebotar
              // Reducir restitution para evitar rebotes y permitir paso
              platelet.restitution = 0;
              Body.setVelocity(platelet, {
                x: platelet.velocity.x * 0.95,
                y: platelet.velocity.y * 0.95,
              });
            }
          }
        }
      }

      function stickPlatelet(platelet, anchor, conditionConfig) {
        if (platelet.isStuck) return;

        platelet.isStuck = true;

        // Apply visual effects based on condition
        const visualEffects =
          conditionConfig.visualEffects ||
          CONFIG.conditions.normal.visualEffects;
        platelet.render.fillStyle = visualEffects.plateletColor || "#808080";

        // Stop movement completely
        Body.setVelocity(platelet, { x: 0, y: 0 });

        // Make platelet completely static so it doesn't move
        Body.setStatic(platelet, true);

        // Create constraint to anchor point - maximum stiffness
        const constraint = Constraint.create({
          bodyA: platelet,
          pointB: anchor.isStatic
            ? { x: anchor.position.x, y: anchor.position.y }
            : null,
          bodyB: anchor.isStatic ? null : anchor,
          stiffness: 1.0, // Maximum stiffness
          damping: 1.0, // Maximum damping
          length: 0,
          render: { visible: false },
        });

        Composite.add(engine.world, constraint);

        const plateletData = {
          body: platelet,
          constraint: constraint,
          hasFibrin: false,
          fibrinConnections: [],
          condition: state.condition,
          stuckAt: Date.now(), // Timestamp para identificar las más antiguas
          isAnchor: false,
        };

        state.stuckPlatelets.push(plateletData);

        // Rastrear primera adhesión
        if (!state.adhesionTime && state.startTime) {
          state.adhesionTime = Date.now();
        }

        // Limitar el número de plaquetas pegadas para mantener rendimiento
        cleanupOldStuckPlatelets();

        // Ocultar cartel cuando hay plaquetas pegadas
        const woundLabel = document.getElementById("wound-label");
        if (state.stuckPlatelets.length > 0) {
          woundLabel.classList.add("hidden");
        }

        // Secuencia: plaquetas primero, luego malla
        // Activar formación de fibrina solo después de umbral de plaquetas
        // Con tratamiento, reducir el umbral mínimo de plaquetas
        const minPlateletsForFibrin = state.treatmentApplied ? 2 : 3;
        if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
          state.fibrinStarted = true;

          // Try to form fibrin with delay if specified
          // Con tratamiento, reducir significativamente el delay
          const baseDelay = conditionConfig.fibrinFormationDelay || 100;
          const delay = state.treatmentApplied
            ? Math.max(50, baseDelay * 0.3)
            : baseDelay;
          setTimeout(() => {
            if (state.stuckPlatelets.includes(plateletData)) {
              tryFormFibrin(plateletData);
            }
          }, delay);
        }
      }

      function tryFormFibrin(plateletData) {
        const conditionConfig = CONFIG.conditions[state.condition];
        const canFormFibrin = state.treatmentApplied
          ? true
          : conditionConfig.canFormFibrin;

        if (!canFormFibrin) return;

        // Secuencia: plaquetas primero, luego malla - solo formar si ya empezó la formación
        if (!state.fibrinStarted) return;

        // Check fibrin formation rate
        const fibrinRate = state.treatmentApplied
          ? 1.0
          : conditionConfig.fibrinFormationRate; // Note: keeping config name as is
        if (Math.random() > fibrinRate) {
          return; // Failed to form fibrin this time
        }

        // Limit total fibrin connections
        if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections)
          return;

        // Limit connections per platelet
        if (
          plateletData.fibrinConnections.length >=
          CONFIG.fibrin.maxConnectionsPerPlatelet
        )
          return;

        // Check max cluster size for thrombasthenia
        if (conditionConfig.maxPlateletClusterSize) {
          const nearbyCount = state.stuckPlatelets.filter((p) => {
            const dx = p.body.position.x - plateletData.body.position.x;
            const dy = p.body.position.y - plateletData.body.position.y;
            return dx * dx + dy * dy < 400 && p.fibrinConnections.length > 0;
          }).length;
          if (nearbyCount >= conditionConfig.maxPlateletClusterSize) {
            return; // Cannot form larger clusters
          }
        }

        const platelet = plateletData.body;

        // Get fibrin stability from condition - affects connection distance
        const fibrinStability = state.treatmentApplied
          ? 1.0
          : conditionConfig.fibrinStability;

        // When fibrin is weaker, platelets must be closer to form connections
        // Strong fibrin (1.0): can connect up to 90px away, minimum 20px
        // Weak fibrin (0.3): can connect up to 40px away, minimum 8px
        // El tratamiento NO afecta la distancia de conexión, solo la velocidad de adhesión
        const baseMaxSearchRadius = 40 + fibrinStability * 50; // 40-90px range
        const maxSearchRadius = baseMaxSearchRadius; // Distancia fija, no afectada por tratamiento
        const minDistance = 8 + fibrinStability * 12; // 8-20px range
        const minDistanceSq = minDistance * minDistance;

        const plateletX = platelet.position.x;
        const plateletY = platelet.position.y;

        // Find nearby stuck platelets (optimized with early exit)
        for (let i = 0; i < state.stuckPlatelets.length; i++) {
          const other = state.stuckPlatelets[i];
          if (other.body === platelet) continue;
          if (plateletData.fibrinConnections.includes(other.body.id)) continue;

          // Limit connections per other platelet too
          if (
            other.fibrinConnections.length >=
            CONFIG.fibrin.maxConnectionsPerPlatelet
          )
            continue;

          // Quick distance check using squared distance (avoid sqrt)
          const dx = other.body.position.x - plateletX;
          const dy = other.body.position.y - plateletY;
          const distSq = dx * dx + dy * dy;
          const searchRadiusSq = maxSearchRadius * maxSearchRadius;

          if (distSq < searchRadiusSq && distSq > minDistanceSq) {
            const dist = Math.sqrt(distSq);

            // Clasificar tipo de cuerda según distancia y estabilidad
            let fibrinType = "thin"; // Por defecto pequeña
            if (dist < 30 && fibrinStability > 0.7) {
              fibrinType = "thick"; // Gruesa: distancia < 30px y estabilidad alta
            } else if (dist < 60 && fibrinStability > 0.4) {
              fibrinType = "medium"; // Mediana: distancia 30-60px y estabilidad media
            }

            // Verificar restricciones según condición
            const canFormThick = !conditionConfig.blockThickCords;
            const canFormMedium = !conditionConfig.blockMediumCords;
            const canFormThin = !conditionConfig.blockThinCords;

            if (
              (fibrinType === "thick" && !canFormThick) ||
              (fibrinType === "medium" && !canFormMedium) ||
              (fibrinType === "thin" && !canFormThin)
            ) {
              continue; // Saltar esta conexión si está bloqueada
            }

            const visualEffects =
              conditionConfig.visualEffects ||
              CONFIG.conditions.normal.visualEffects;

            // Create fibrin constraint with stability-based properties
            const fibrinConstraint = Constraint.create({
              bodyA: platelet,
              bodyB: other.body,
              stiffness: 0.9 * fibrinStability,
              damping: 0.3 * (2 - fibrinStability),
              length: dist * 0.8,
              render: { visible: false },
            });

            Composite.add(engine.world, fibrinConstraint);

            // Create physical body for fibrin barrier (thin rectangle)
            const midX = (platelet.position.x + other.body.position.x) / 2;
            const midY = (platelet.position.y + other.body.position.y) / 2;
            const angle = Math.atan2(
              other.body.position.y - platelet.position.y,
              other.body.position.x - platelet.position.x
            );

            // Create a thin rectangular body as barrier
            // Thickness depends on stability - weaker fibrin = thinner barrier
            const barrierThickness = 2 + fibrinStability * 3; // 2-5px range
            const fibrinBody = Bodies.rectangle(
              midX,
              midY,
              dist,
              barrierThickness,
              {
                isStatic: true, // Static so it acts as a solid barrier
                render: {
                  fillStyle: "transparent", // Invisible, we render it separately
                  visible: false,
                },
                label: "fibrinBarrier",
                restitution: 0.9 * fibrinStability, // Stability affects bounce
                friction: 0.1,
                collisionFilter: {
                  group: 0,
                  category: 0x0002, // Separate category for fibrin
                  mask: 0x0001, // Only collide with RBCs and WBCs
                },
                // Store stability for collision handling
                fibrinStability: fibrinStability,
              }
            );

            Body.setAngle(fibrinBody, angle);
            Composite.add(engine.world, fibrinBody);

            const fibrinData = {
              constraint: fibrinConstraint,
              pointA: platelet,
              pointB: other.body,
              body: fibrinBody,
              glowing: state.treatmentApplied,
              stability: fibrinStability,
              decayRate: conditionConfig.fibrinDecayRate || 0,
              visualColor: "#FFFFFF", // Blanco para las cuerdas (solo la malla horizontal es morada)
              opacity: visualEffects.fibrinOpacity || 1.0,
              fibrinType: fibrinType, // 'thick', 'medium', o 'thin'
              createdAt: Date.now(),
            };

            state.fibrinConstraints.push(fibrinData);
            state.fibrinBodies.push(fibrinBody);

            plateletData.fibrinConnections.push(other.body.id);
            plateletData.hasFibrin = true;
            other.fibrinConnections.push(platelet.id);
            other.hasFibrin = true;

            // Schedule fibrin decay if condition has decay rate
            if (
              conditionConfig.fibrinDecayRate > 0 &&
              !state.treatmentApplied
            ) {
              scheduleFibrinDecay(fibrinData, conditionConfig.fibrinDecayRate);
            }

            // Stop if we've reached the limit
            if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections)
              break;
          }
        }

        // Check if wound is sealed after forming new fibrin connection
        checkWoundSealed();
      }

      function scheduleFibrinDecay(fibrinData, decayRate) {
        // Decay fibrin over time based on decay rate
        const decayInterval = setInterval(() => {
          if (!state.fibrinConstraints.includes(fibrinData)) {
            clearInterval(decayInterval);
            return;
          }

          // Reduce stability over time
          fibrinData.stability -= decayRate * 0.1;

          if (fibrinData.stability <= 0.1 || Math.random() < decayRate) {
            // Remove unstable fibrin
            removeFibrinConnection(fibrinData);
            clearInterval(decayInterval);
          } else {
            // Update constraint properties based on stability
            fibrinData.constraint.stiffness = 0.9 * fibrinData.stability;
            fibrinData.constraint.damping = 0.3 * (2 - fibrinData.stability);
          }
        }, 2000); // Check every 2 seconds
      }

      function removeFibrinConnection(fibrinData) {
        // Remove from world
        Composite.remove(engine.world, fibrinData.constraint);
        if (fibrinData.body) {
          Composite.remove(engine.world, fibrinData.body);
          state.fibrinBodies = state.fibrinBodies.filter(
            (b) => b !== fibrinData.body
          );
        }

        // Remove from arrays
        state.fibrinConstraints = state.fibrinConstraints.filter(
          (f) => f !== fibrinData
        );

        // Update platelet connections
        const plateletA = state.stuckPlatelets.find(
          (p) => p.body === fibrinData.pointA
        );
        const plateletB = state.stuckPlatelets.find(
          (p) => p.body === fibrinData.pointB
        );

        if (plateletA) {
          plateletA.fibrinConnections = plateletA.fibrinConnections.filter(
            (id) => id !== fibrinData.pointB.id
          );
          plateletA.hasFibrin = plateletA.fibrinConnections.length > 0;
        }
        if (plateletB) {
          plateletB.fibrinConnections = plateletB.fibrinConnections.filter(
            (id) => id !== fibrinData.pointA.id
          );
          plateletB.hasFibrin = plateletB.fibrinConnections.length > 0;
        }
      }

      function checkWoundSealed() {
        if (state.hemostasisAchieved) return; // Already sealed

        const conditionConfig = CONFIG.conditions[state.condition];
        // En condiciones patológicas, requerir tratamiento para sellado completo
        if (conditionConfig.requiresTreatment && !state.treatmentApplied) {
          return; // No sellar sin tratamiento
        }

        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const woundCenterY = 29; // Y position where platelets stick

        // Find platelets on the left side of the wound (including anchor platelets)
        const leftSidePlatelets = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          // Include anchor platelets or platelets near left edge
          return (
            (p.isAnchor && px < woundLeft) ||
            (px < woundLeft + 30 && Math.abs(py - woundCenterY) < 20)
          );
        });

        // Find platelets on the right side of the wound (including anchor platelets)
        const rightSidePlatelets = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          // Include anchor platelets or platelets near right edge
          return (
            (p.isAnchor && px > woundRight) ||
            (px > woundRight - 30 && Math.abs(py - woundCenterY) < 20)
          );
        });

        if (leftSidePlatelets.length === 0 || rightSidePlatelets.length === 0) {
          return; // Need platelets on both sides
        }

        // Check if there's a path from left to right through fibrin connections
        for (let i = 0; i < leftSidePlatelets.length; i++) {
          const leftPlatelet = leftSidePlatelets[i];
          if (hasPathToRight(leftPlatelet, rightSidePlatelets, new Set())) {
            // Wound is sealed!
            state.hemostasisAchieved = true;
            state.clotPercentage = 100;
            // Capturar el momento del cierre de la herida (tiempo de simulación acumulado)
            if (!state.closureTime && state.startTime) {
              state.closureTime = accumulatedSimulationTime / 1000; // Guardar tiempo de simulación en segundos
            }
            const woundLabel = document.getElementById("wound-label");
            woundLabel.classList.add("healed");
            woundLabel.innerHTML = "Lesión Sellada";
            
            // Agregar efecto de pulsación al botón de reiniciar
            const resetBtn = document.getElementById("reset-btn");
            if (resetBtn) {
              resetBtn.classList.add("hemostasis-pulse");
            }
            
            updateUI();
            return;
          }
        }
      }

      function hasPathToRight(currentPlatelet, rightSidePlatelets, visited) {
        // Check if current platelet is on the right side
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;

        if (currentPlatelet.body.position.x > woundRight - 20) {
          return true; // Reached right side
        }

        // Mark as visited
        visited.add(currentPlatelet.body.id);

        // Check all fibrin connections from this platelet
        for (let i = 0; i < state.fibrinConstraints.length; i++) {
          const fibrin = state.fibrinConstraints[i];
          let connectedPlatelet = null;

          // Find which platelet is connected to current one
          if (fibrin.pointA === currentPlatelet.body) {
            connectedPlatelet = state.stuckPlatelets.find(
              (p) => p.body === fibrin.pointB
            );
          } else if (fibrin.pointB === currentPlatelet.body) {
            connectedPlatelet = state.stuckPlatelets.find(
              (p) => p.body === fibrin.pointA
            );
          }

          if (connectedPlatelet && !visited.has(connectedPlatelet.body.id)) {
            // Check if this connection crosses the wound area
            const px1 = currentPlatelet.body.position.x;
            const px2 = connectedPlatelet.body.position.x;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;

            // Connection crosses wound if one point is left and other is right
            if (
              (px1 < woundLeft && px2 > woundRight) ||
              (px2 < woundLeft && px1 > woundRight)
            ) {
              // Direct crossing found
              return true;
            }

            // Continue searching through this connection
            if (
              hasPathToRight(connectedPlatelet, rightSidePlatelets, visited)
            ) {
              return true;
            }
          }
        }

        return false;
      }

      // ==================== RENDERIZADO DEL VASO SANGUÍNEO ====================

      // Cache para el fondo del vaso (se genera una vez y se reutiliza)
      let vesselBackgroundCache = null;

      function renderVesselBackground(event) {
        const ctx = render.context;
        const canvas = render.canvas;
        const width = canvas.width;
        const height = canvas.height;

        // Si el canvas cambió de tamaño, regenerar el cache
        if (
          !vesselBackgroundCache ||
          vesselBackgroundCache.width !== width ||
          vesselBackgroundCache.height !== height
        ) {
          const cacheCanvas = document.createElement("canvas");
          cacheCanvas.width = width;
          cacheCanvas.height = height;
          const cacheCtx = cacheCanvas.getContext("2d");

          // Fondo base - gradiente que simula el interior de un vaso sanguíneo
          const baseGradient = cacheCtx.createLinearGradient(0, 0, 0, height);
          baseGradient.addColorStop(0, "#1a0505"); // Muy oscuro arriba (cerca de la pared)
          baseGradient.addColorStop(0.15, "#2a0a0a"); // Transición
          baseGradient.addColorStop(0.35, "#3d1515"); // Zona media-alta
          baseGradient.addColorStop(0.5, "#4a1a1a"); // Centro - más iluminado (flujo sanguíneo)
          baseGradient.addColorStop(0.65, "#3d1515"); // Zona media-baja
          baseGradient.addColorStop(0.85, "#2a0a0a"); // Transición
          baseGradient.addColorStop(1, "#1a0505"); // Muy oscuro abajo (cerca de la pared)

          cacheCtx.fillStyle = baseGradient;
          cacheCtx.fillRect(0, 0, width, height);

          // Agregar gradiente radial central para simular el flujo de sangre (lumen)
          const centerGradient = cacheCtx.createRadialGradient(
            width * 0.4,
            height / 2,
            0,
            width * 0.4,
            height / 2,
            Math.max(width, height) * 0.6
          );
          centerGradient.addColorStop(0, "rgba(139, 30, 30, 0.25)"); // Rojo oscuro en el centro
          centerGradient.addColorStop(0.3, "rgba(100, 20, 20, 0.15)");
          centerGradient.addColorStop(0.6, "rgba(60, 10, 10, 0.08)");
          centerGradient.addColorStop(1, "rgba(0, 0, 0, 0)");

          cacheCtx.fillStyle = centerGradient;
          cacheCtx.fillRect(0, 0, width, height);

          // Agregar efecto de profundidad con sombras en los bordes
          const edgeShadow = cacheCtx.createLinearGradient(0, 0, 0, height);
          edgeShadow.addColorStop(0, "rgba(0, 0, 0, 0.5)");
          edgeShadow.addColorStop(0.1, "rgba(0, 0, 0, 0.1)");
          edgeShadow.addColorStop(0.9, "rgba(0, 0, 0, 0.1)");
          edgeShadow.addColorStop(1, "rgba(0, 0, 0, 0.5)");

          cacheCtx.fillStyle = edgeShadow;
          cacheCtx.fillRect(0, 0, width, height);

          // Líneas horizontales sutiles para simular el flujo laminar de la sangre
          cacheCtx.strokeStyle = "rgba(80, 20, 20, 0.08)";
          cacheCtx.lineWidth = 1;
          for (let y = 30; y < height - 30; y += 8) {
            cacheCtx.beginPath();
            // Líneas ligeramente onduladas
            cacheCtx.moveTo(0, y);
            for (let x = 0; x < width; x += 50) {
              const wave = Math.sin(x * 0.02 + y * 0.1) * 1.5;
              cacheCtx.lineTo(x, y + wave);
            }
            cacheCtx.stroke();
          }

          vesselBackgroundCache = cacheCanvas;
        }

        // Dibujar el fondo desde el cache (muy rápido)
        ctx.drawImage(vesselBackgroundCache, 0, 0);
      }

      function renderVesselWalls(event) {
        const ctx = render.context;
        const canvas = render.canvas;
        const width = canvas.width;
        const height = canvas.height;
        const { thickness } = CONFIG.wall;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;

        ctx.save();

        // ========== PARED INFERIOR (Endotelio vascular) ==========
        const bottomY = height - thickness;

        // Capa 1: Adventitia (tejido conectivo externo) - más oscuro
        const adventitiaGradient = ctx.createLinearGradient(
          0,
          height - thickness,
          0,
          height
        );
        adventitiaGradient.addColorStop(0, "#2d1a1a");
        adventitiaGradient.addColorStop(0.3, "#3d2222");
        adventitiaGradient.addColorStop(0.7, "#4a2828");
        adventitiaGradient.addColorStop(1, "#3d2222");

        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(0, height - thickness, width, thickness);

        // Capa 2: Media (músculo liso) - tono medio
        const mediaGradient = ctx.createLinearGradient(
          0,
          height - thickness,
          0,
          height - thickness * 0.4
        );
        mediaGradient.addColorStop(0, "#5a3535");
        mediaGradient.addColorStop(0.5, "#6b4040");
        mediaGradient.addColorStop(1, "#7a4a4a");

        ctx.fillStyle = mediaGradient;
        ctx.fillRect(0, height - thickness, width, thickness * 0.6);

        // Capa 3: Intima/Endotelio (superficie interior) - más rosado/brillante
        const intimaGradient = ctx.createLinearGradient(
          0,
          height - thickness,
          0,
          height - thickness * 0.7
        );
        intimaGradient.addColorStop(0, "#8b5555");
        intimaGradient.addColorStop(0.3, "#a06666");
        intimaGradient.addColorStop(0.7, "#b87777");
        intimaGradient.addColorStop(1, "#c98888");

        ctx.fillStyle = intimaGradient;
        ctx.fillRect(0, height - thickness, width, thickness * 0.3);

        // Brillo sutil en el borde interior (superficie del endotelio)
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, height - thickness);
        ctx.lineTo(width, height - thickness);
        ctx.stroke();

        // Textura del tejido - fibras horizontales
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = 1;
        for (let y = height - thickness + 3; y < height - 2; y += 4) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        // ========== PARED SUPERIOR IZQUIERDA ==========
        const topY = 0;

        // Adventitia
        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(0, 0, woundLeft, thickness);

        // Media
        const topMediaGradient = ctx.createLinearGradient(
          0,
          thickness * 0.4,
          0,
          thickness
        );
        topMediaGradient.addColorStop(0, "#7a4a4a");
        topMediaGradient.addColorStop(0.5, "#6b4040");
        topMediaGradient.addColorStop(1, "#5a3535");

        ctx.fillStyle = topMediaGradient;
        ctx.fillRect(0, thickness * 0.4, woundLeft, thickness * 0.6);

        // Intima
        const topIntimaGradient = ctx.createLinearGradient(
          0,
          thickness * 0.7,
          0,
          thickness
        );
        topIntimaGradient.addColorStop(0, "#c98888");
        topIntimaGradient.addColorStop(0.3, "#b87777");
        topIntimaGradient.addColorStop(0.7, "#a06666");
        topIntimaGradient.addColorStop(1, "#8b5555");

        ctx.fillStyle = topIntimaGradient;
        ctx.fillRect(0, thickness * 0.7, woundLeft, thickness * 0.3);

        // Brillo del endotelio
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, thickness);
        ctx.lineTo(woundLeft, thickness);
        ctx.stroke();

        // Textura
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = 1;
        for (let y = 3; y < thickness - 2; y += 4) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(woundLeft, y);
          ctx.stroke();
        }

        // ========== PARED SUPERIOR DERECHA ==========
        // Adventitia
        ctx.fillStyle = adventitiaGradient;
        ctx.fillRect(woundRight, 0, width - woundRight, thickness);

        // Media
        ctx.fillStyle = topMediaGradient;
        ctx.fillRect(
          woundRight,
          thickness * 0.4,
          width - woundRight,
          thickness * 0.6
        );

        // Intima
        ctx.fillStyle = topIntimaGradient;
        ctx.fillRect(
          woundRight,
          thickness * 0.7,
          width - woundRight,
          thickness * 0.3
        );

        // Brillo del endotelio
        ctx.strokeStyle = "rgba(255, 200, 180, 0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(woundRight, thickness);
        ctx.lineTo(width, thickness);
        ctx.stroke();

        // Textura
        ctx.strokeStyle = "rgba(100, 50, 50, 0.15)";
        ctx.lineWidth = 1;
        for (let y = 3; y < thickness - 2; y += 4) {
          ctx.beginPath();
          ctx.moveTo(woundRight, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        // ========== BORDES DE LA HERIDA ==========
        // Renderizar los bordes de la herida como tejido dañado
        const woundEdgeWidth = 6;

        // Borde izquierdo de la herida
        const woundEdgeGradient = ctx.createLinearGradient(
          woundLeft - woundEdgeWidth,
          0,
          woundLeft,
          0
        );
        woundEdgeGradient.addColorStop(0, "#c98888");
        woundEdgeGradient.addColorStop(0.3, "#d46666");
        woundEdgeGradient.addColorStop(0.7, "#e55555");
        woundEdgeGradient.addColorStop(1, "#ff6666");

        ctx.fillStyle = woundEdgeGradient;
        ctx.fillRect(
          woundLeft - woundEdgeWidth / 2,
          0,
          woundEdgeWidth,
          thickness + 5
        );

        // Borde derecho de la herida
        const woundEdgeGradientRight = ctx.createLinearGradient(
          woundRight,
          0,
          woundRight + woundEdgeWidth,
          0
        );
        woundEdgeGradientRight.addColorStop(0, "#ff6666");
        woundEdgeGradientRight.addColorStop(0.3, "#e55555");
        woundEdgeGradientRight.addColorStop(0.7, "#d46666");
        woundEdgeGradientRight.addColorStop(1, "#c98888");

        ctx.fillStyle = woundEdgeGradientRight;
        ctx.fillRect(
          woundRight - woundEdgeWidth / 2,
          0,
          woundEdgeWidth,
          thickness + 5
        );

        // Efecto de "sangrado" en los bordes de la herida
        ctx.strokeStyle = "rgba(255, 80, 80, 0.6)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(woundLeft - 1, 0);
        ctx.lineTo(woundLeft - 1, thickness + 8);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(woundRight + 1, 0);
        ctx.lineTo(woundRight + 1, thickness + 8);
        ctx.stroke();

        // Brillo/reflejo en los bordes de la herida
        ctx.strokeStyle = "rgba(255, 150, 150, 0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(woundLeft - 2, 0);
        ctx.lineTo(woundLeft - 2, thickness + 6);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(woundRight + 2, 0);
        ctx.lineTo(woundRight + 2, thickness + 6);
        ctx.stroke();

        ctx.restore();
      }

      function renderFibrin(event) {
        const ctx = render.context;
        const woundX = CONFIG.wound.x;
        const woundWidth = CONFIG.wound.width;
        const woundLeft = woundX - woundWidth / 2;
        const woundRight = woundX + woundWidth / 2;
        const adhesionLineY = 23; // Centro del área de adhesión (debe coincidir con el área de adhesión)
        const adhesionZoneHalfWidth = 12; // Mitad del ancho del área de adhesión

        // Render ointment layer when treatment is applied - ultra simple for performance
        if (state.showOintment) {
          ctx.fillStyle = "rgba(117, 35, 120, 0.35)";
          ctx.fillRect(
            woundLeft,
            adhesionLineY - adhesionZoneHalfWidth,
            woundWidth,
            adhesionZoneHalfWidth * 2
          );
        }

        // Calcular opacidad de la malla morada basada en densidad de plaquetas pegadas en el área de adhesión
        const stuckPlateletsInWound = state.stuckPlatelets.filter((p) => {
          const px = p.body.position.x;
          const py = p.body.position.y;
          return (
            px >= woundLeft - 20 &&
            px <= woundRight + 20 &&
            py >= adhesionLineY - adhesionZoneHalfWidth &&
            py <= adhesionLineY + adhesionZoneHalfWidth
          );
        }).length;

        const maxPlatelets = 20; // Máximo esperado de plaquetas en la herida
        // La malla morada empieza muy transparente (0.05) y se opaca progresivamente hasta 0.9
        const meshOpacity = Math.min(
          0.9,
          0.05 + (stuckPlateletsInWound / maxPlatelets) * 0.85
        );

        // Área de la malla morada coincide con el área de adhesión
        const meshTopY = adhesionLineY - adhesionZoneHalfWidth;
        const meshHeight = adhesionZoneHalfWidth * 2; // Altura total del área de adhesión

        // Renderizar malla morada horizontal en la zona de adhesión que se opaca progresivamente
        // Solo esta área horizontal es morada - las cuerdas son verdes
        if (state.fibrinStarted && stuckPlateletsInWound > 0) {
          ctx.fillStyle = `rgba(117, 35, 120, ${meshOpacity})`; // Morado #752378
          ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
        }

        // Overlay verde cuando está sellada
        if (state.hemostasisAchieved) {
          ctx.fillStyle = "rgba(34, 197, 94, 0.3)"; // Verde semitransparente
          ctx.fillRect(woundLeft, meshTopY, woundWidth, meshHeight);
        }

        // Render fibrin connections (cuerdas) - optimized for performance
        if (state.fibrinConstraints.length > 0) {
          ctx.save(); // Guardar estado del contexto antes de dibujar cuerdas verdes

          for (let i = 0; i < state.fibrinConstraints.length; i++) {
            const fibrin = state.fibrinConstraints[i];
            const pointA = fibrin.pointA.position;
            const pointB = fibrin.pointB.position;

            // Only draw if both points are still valid
            if (pointA && pointB) {
              const fibrinType = fibrin.fibrinType || "thin";
              let lineWidth, opacity;

              // Configurar grosor y opacidad según tipo de cuerda
              switch (fibrinType) {
                case "thick":
                  lineWidth = 7; // Aumentado de 5 a 7px
                  opacity = 0.9;
                  break;
                case "medium":
                  lineWidth = 4; // Aumentado de 3 a 4px
                  opacity = 0.6;
                  break;
                case "thin":
                default:
                  lineWidth = 2; // Aumentado de 1.5 a 2px
                  opacity = 0.4;
                  break;
              }

              // Ajustar opacidad según estabilidad
              opacity *= fibrin.stability || 1.0;

              // Color verde para las cuerdas (solo la malla horizontal es morada)
              ctx.strokeStyle = `rgba(34, 197, 94, ${opacity * 0.8})`; // Verde #22C55E con opacidad
              ctx.lineWidth = lineWidth;

              ctx.beginPath();
              ctx.moveTo(pointA.x, pointA.y);
              ctx.lineTo(pointB.x, pointB.y);
              ctx.stroke();
            }
          }

          ctx.restore(); // Restaurar estado del contexto después de dibujar cuerdas blancas
        }
      }

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16),
            }
          : { r: 0, g: 230, b: 118 };
      }

      function renderVWF(event) {
        const ctx = render.context;

        // Verificar si debe mostrar vWF (cemento entre plaquetas)
        const conditionConfig = CONFIG.conditions[state.condition];
        const shouldShowVWF =
          state.condition === "normal" ||
          state.treatmentApplied ||
          (state.condition === "vwd" && state.treatmentApplied);

        if (!shouldShowVWF || state.stuckPlatelets.length < 2) {
          return; // No mostrar vWF si no hay vWF o menos de 2 plaquetas
        }

        // Dibujar líneas verdes cortas (cemento) entre plaquetas pegadas que están cerca
        const maxVWFDistance = 12; // Distancia máxima para mostrar conexión vWF
        const maxVWFDistanceSq = maxVWFDistance * maxVWFDistance;

        // Asegurar que el color verde se aplique correctamente
        ctx.save(); // Guardar estado del contexto

        // Usar rgba para asegurar que el color verde se aplique correctamente
        ctx.strokeStyle = "rgba(34, 197, 94, 1.0)"; // Verde #22C55E en formato rgba
        ctx.lineWidth = 1.5;
        ctx.lineCap = "round";
        ctx.globalAlpha = 1.0; // Asegurar opacidad completa para el verde

        // Dibujar líneas entre plaquetas cercanas
        for (let i = 0; i < state.stuckPlatelets.length; i++) {
          const plateletA = state.stuckPlatelets[i];
          if (!plateletA.body) continue;

          const posA = plateletA.body.position;

          for (let j = i + 1; j < state.stuckPlatelets.length; j++) {
            const plateletB = state.stuckPlatelets[j];
            if (!plateletB.body) continue;

            const posB = plateletB.body.position;
            const dx = posB.x - posA.x;
            const dy = posB.y - posA.y;
            const distSq = dx * dx + dy * dy;

            // Solo dibujar si están cerca (como cemento entre piedras adyacentes)
            if (distSq < maxVWFDistanceSq && distSq > 4) {
              const dist = Math.sqrt(distSq);
              // Opacidad basada en distancia (más opaco cuanto más cerca)
              const opacity = 0.7 + (1.0 - dist / maxVWFDistance) * 0.3; // Entre 0.7 y 1.0

              // Re-establecer el color verde antes de cada línea para asegurar que siempre sea verde
              ctx.strokeStyle = `rgba(34, 197, 94, ${opacity})`; // Verde con opacidad variable
              ctx.beginPath();
              ctx.moveTo(posA.x, posA.y);
              ctx.lineTo(posB.x, posB.y);
              ctx.stroke();
            }
          }
        }

        ctx.restore(); // Restaurar estado del contexto
      }

      function renderParticlesCustom(event) {
        const ctx = render.context;

        // Renderizar todas las partículas con estilo personalizado (highlights, sombras, formas)
        // Renderizar solo plaquetas, glóbulos rojos y glóbulos blancos
        state.allBodies.forEach((body) => {
          if (
            !body.label ||
            (body.label !== "platelet" &&
              body.label !== "rbc" &&
              body.label !== "wbc")
          )
            return;

          const x = body.position.x;
          const y = body.position.y;
          const angle = body.angle;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);

          if (body.label === "rbc") {
            // Glóbulo rojo: ovalado con highlight y sombra
            const radiusX = 6;
            const radiusY = 4.5; // Más ancho que alto para efecto ovalado

            // Sombra/contorno oscuro
            ctx.beginPath();
            ctx.ellipse(0, 0, radiusX + 0.5, radiusY + 0.5, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(139, 0, 0, 0.3)"; // Rojo muy oscuro para sombra
            ctx.fill();

            // Cuerpo principal rojo oscuro
            ctx.beginPath();
            ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
            ctx.fillStyle = "#B91C1C"; // Rojo oscuro
            ctx.fill();

            // Highlight pequeño cerca del centro (superior izquierda)
            ctx.beginPath();
            ctx.arc(-1.5, -1, 1.2, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 200, 200, 0.8)"; // Rojo claro/rosa para highlight
            ctx.fill();
          } else if (body.label === "wbc") {
            // Glóbulo blanco: circular con highlight brillante y contorno azul oscuro
            const radius = 10;

            // Contorno azul oscuro para profundidad
            ctx.beginPath();
            ctx.arc(0, 0, radius + 1, 0, Math.PI * 2);
            ctx.strokeStyle = "#4A90E2"; // Azul más oscuro para contorno
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Cuerpo principal azul claro
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#87CEEB"; // Azul claro
            ctx.fill();

            // Highlight brillante blanco en cuadrante superior izquierdo
            const gradient = ctx.createRadialGradient(-3, -3, 0, -3, -3, 4);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.95)"); // Blanco brillante en el centro
            gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.6)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)"); // Transparente hacia afuera

            ctx.beginPath();
            ctx.arc(-3, -3, 4, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Punto de highlight más pequeño y brillante
            ctx.beginPath();
            ctx.arc(-3, -3, 1.5, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 1)"; // Blanco sólido
            ctx.fill();
          } else if (body.label === "platelet") {
            // Plaqueta: circular gris con highlight sutil
            const radius = 4;

            // Sombra sutil
            ctx.beginPath();
            ctx.arc(0, 0, radius + 0.3, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(100, 100, 100, 0.2)"; // Gris oscuro para sombra
            ctx.fill();

            // Cuerpo principal gris
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#808080"; // Gris medio
            ctx.fill();

            // Highlight pequeño en cuadrante superior izquierdo
            ctx.beginPath();
            ctx.arc(-1.2, -1.2, 0.8, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(220, 220, 220, 0.7)"; // Gris claro para highlight
            ctx.fill();
          }

          ctx.restore();
        });
      }

      function calculateClotPercentage() {
        // Si la herida está sellada (red de fibrina de izquierda a derecha y no pasan partículas), 100%
        if (state.hemostasisAchieved) {
          state.clotPercentage = 100;
          return;
        }

        const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
        const woundWidth = CONFIG.wound.width;
        const woundCenterY = 29; // Y position where platelets stick

        // Optimized coverage calculation
        const segments = 20; // Reduced from 30 for better performance
        const segmentWidth = woundWidth / segments;
        let coveredSegments = 0;
        const coverageThreshold = 15 * 15; // Squared distance for comparison

        // Pre-filter platelets that are actually in the wound area (exclude anchor platelets)
        const relevantPlatelets = state.stuckPlatelets.filter((p) => {
          // Excluir plaquetas anchor del cálculo
          if (p.isAnchor) return false;

          const px = p.body.position.x;
          const py = p.body.position.y;
          return (
            px >= woundLeft - 20 &&
            px <= woundLeft + woundWidth + 20 &&
            py >= woundCenterY - 15 &&
            py <= woundCenterY + 15
          );
        });

        for (let i = 0; i < segments; i++) {
          const segmentX = woundLeft + (i + 0.5) * segmentWidth;

          // Check if any stuck platelet covers this segment (optimized)
          const covered = relevantPlatelets.some((p) => {
            const dx = p.body.position.x - segmentX;
            const dy = p.body.position.y - woundCenterY;
            return dx * dx + dy * dy < coverageThreshold;
          });

          if (covered) coveredSegments++;
        }

        state.clotPercentage = Math.min(
          100,
          Math.round((coveredSegments / segments) * 100)
        );

        // Check if wound is sealed by fibrin network crossing left to right
        // Esto detecta cuando la red de fibrina va de izquierda a derecha
        checkWoundSealed();

        // Si está sellada, asegurar que el porcentaje sea 100%
        if (state.hemostasisAchieved) {
          state.clotPercentage = 100;
        }
      }

      function updateUI() {
        // Actualizar métricas con animación
        const bloodLossEl = document.getElementById("blood-loss");
        const clotPercentageEl = document.getElementById("clot-percentage");

        if (bloodLossEl) {
          const oldValue = parseInt(bloodLossEl.textContent) || 0;
          const newValue = state.bloodLoss;
          bloodLossEl.textContent = newValue;
          if (oldValue !== newValue) {
            bloodLossEl.classList.add("updated");
            setTimeout(() => bloodLossEl.classList.remove("updated"), 400);
          }
        }

        if (clotPercentageEl) {
          const oldValue = parseInt(clotPercentageEl.textContent) || 0;
          const newValue = state.clotPercentage;
          clotPercentageEl.textContent = newValue + "%";
          if (oldValue !== newValue) {
            clotPercentageEl.classList.add("updated");
            setTimeout(() => clotPercentageEl.classList.remove("updated"), 400);
          }
        }




      }


      // Controles de velocidad
      function setupSpeedControls() {
        const speedSlider = document.getElementById("speed-slider");
        const speedValue = document.getElementById("speed-value");

        if (speedSlider) {
          // Ajustar timeScale: cuando el slider está en 1.0, la velocidad real es 0.75
          // Esto hace que la velocidad "normal" (1x) sea más lenta
          const baseSpeed = 0.75;
          state.timeScale = baseSpeed;
          if (speedValue) speedValue.textContent = "1x";

          speedSlider.addEventListener("input", (e) => {
            const sliderValue = parseFloat(e.target.value);
            state.timeScale = baseSpeed * sliderValue;
            if (speedValue) speedValue.textContent = sliderValue + "x";

            // Reiniciar el spawn para aplicar el nuevo intervalo
            if (state.simulationRunning && !state.isPaused) {
              startParticleSpawning();
            }
          });
        }
      }

      // Tooltips
      function setupTooltips() {
        const triggers = document.querySelectorAll(".tooltip-trigger");

        triggers.forEach((trigger) => {
          const tooltip = trigger.parentElement.querySelector(".tooltip");

          trigger.addEventListener("mouseenter", () => {
            if (tooltip) tooltip.classList.add("visible");
          });

          trigger.addEventListener("mouseleave", () => {
            if (tooltip) tooltip.classList.remove("visible");
          });
        });
      }

      function applyTreatment() {
        // Verificar que la simulación se haya iniciado al menos una vez
        // (puede estar corriendo o pausada)
        if (!state.startTime) {
          return;
        }
        
        // Verificar que no se haya aplicado ya
        if (state.treatmentApplied) return;

        state.treatmentApplied = true;
        state.showOintment = true;


        // Show treatment indicator
        const indicator = document.getElementById("treatment-indicator");
        indicator.classList.add("visible");
        setTimeout(() => {
          indicator.classList.remove("visible");
        }, 2000);

        // Update button
        const btn = document.getElementById("treatment-btn");
        btn.classList.add("applied");
        btn.innerHTML = "Tratamiento Aplicado";
        btn.disabled = true;

        // Apply treatment effects based on condition
        const condition = CONFIG.conditions[state.condition];

        switch (state.condition) {
          case "hemophilia":
          case "hemophiliaSevere":
            // Factor VIII/IX replacement - enables fibrin formation
            applyFactorReplacement();
            break;

          case "vwd":
            // Desmopresina or vWF concentrate - improves platelet adhesion
            applyVWFReplacement();
            break;

          case "thrombocytopenia":
            // Platelet transfusion - increases platelet count
            applyPlateletTransfusion();
            break;

          case "thrombasthenia":
            // Platelet transfusion - provides functional platelets
            applyPlateletTransfusion();
            break;

          case "anticoagulated":
            // Vitamin K or PCC - reverses anticoagulation (similar a hemofilia)
            applyFactorReplacement();
            break;

          case "factorDeficiency":
            // Factor VII replacement - elimina el retraso de generación
            // Las plaquetas ya pegadas forman fibrina inmediatamente
            state.stuckPlatelets.forEach((plateletData) => {
              if (!plateletData.hasFibrin) {
                setTimeout(() => tryFormFibrin(plateletData), 50);
                setTimeout(() => tryFormFibrin(plateletData), 150);
              }
            });
            // Eliminar retraso para futuras formaciones
            condition.fibrinFormationDelay = 0;
            break;

          default:
            // Generic treatment - improves all parameters
            applyGenericTreatment();
        }

        // For all conditions, try to form additional fibrin connections
        // Con tratamiento, intentar formar fibrina más frecuentemente
        const retryInterval = state.treatmentApplied ? 100 : 200;
        const maxRetries = state.treatmentApplied ? 5 : 3;

        let retryCount = 0;
        const tryFormFibrinRepeatedly = () => {
          if (retryCount < maxRetries && !state.hemostasisAchieved) {
            state.stuckPlatelets.forEach((plateletData) => {
              tryFormFibrin(plateletData);
            });
            retryCount++;
            setTimeout(tryFormFibrinRepeatedly, retryInterval);
          }
        };

        setTimeout(tryFormFibrinRepeatedly, retryInterval);

        updateUI();
      }

      function applyFactorReplacement() {
        // Factor VIII/IX replacement for hemophilia/anticoagulated
        // Las plaquetas ya pegadas "disparan" instantáneamente hilos verdes fuertes
        const condition = CONFIG.conditions[state.condition];

        // Form fibrin on all existing stuck platelets immediately
        state.stuckPlatelets.forEach((plateletData) => {
          if (!plateletData.hasFibrin) {
            // Intentar formar fibrina múltiples veces para asegurar conexiones
            setTimeout(() => tryFormFibrin(plateletData), 50);
            setTimeout(() => tryFormFibrin(plateletData), 150);
            setTimeout(() => tryFormFibrin(plateletData), 300);
          }
        });

        // Make all existing fibrin stable and glowing (verde fuerte)
        state.fibrinConstraints.forEach((f) => {
          f.glowing = true;
          f.stability = 1.0; // Fibrina fuerte
          f.decayRate = 0;
          f.visualColor = "#00E676"; // Verde sólido
          f.opacity = 1.0;
          // Actualizar stiffness del constraint
          if (f.constraint) {
            f.constraint.stiffness = 0.9; // Stiffness fuerte
          }
        });
      }

      function applyVWFReplacement() {
        // Desmopresina or vWF concentrate for von Willebrand disease
        // Las plaquetas flotantes cambian sus propiedades físicas y empiezan a pegarse inmediatamente
        const condition = CONFIG.conditions[state.condition];

        // Cambiar propiedades físicas de todas las plaquetas flotantes
        state.allBodies.forEach((body) => {
          if (body.label === "platelet" && !body.isStuck) {
            // Cambiar restitución para que se peguen (reducir rebote)
            body.restitution = 0.5; // Rebote normal
            body.isSticky = true; // Permitir adhesión
            Body.setVelocity(body, {
              x: body.velocity.x * 0.8, // Reducir velocidad para facilitar adhesión
              y: body.velocity.y * 0.8,
            });
          }
        });

        // Update visual effects - platelets return to normal color
        state.stuckPlatelets.forEach((platelet) => {
          platelet.body.render.fillStyle = "#808080";
        });
      }

      function applyPlateletTransfusion() {
        // Platelet transfusion for thrombocytopenia/thrombasthenia
        const condition = CONFIG.conditions[state.condition];
        
        if (state.condition === "thrombocytopenia") {
          // Trombocitopenia: Inyecta una ráfaga ("bolus") de nuevas plaquetas al flujo
          const bolusCount = 20; // Ráfaga de 20 plaquetas
          for (let i = 0; i < bolusCount; i++) {
            setTimeout(() => {
              createParticle("platelet");
            }, i * 50); // Espaciar ligeramente la creación
          }
        } else if (state.condition === "thrombasthenia") {
          // Trombastenia: Las plaquetas flotantes cambian propiedades y empiezan a agregarse
          state.allBodies.forEach((body) => {
            if (body.label === "platelet" && !body.isStuck) {
              body.isSticky = true;
              // Permitir agregación ahora
            }
          });
          // También aumentar ratio temporalmente para nuevas plaquetas funcionales
          const originalRatio = condition.plateletRatio;
          condition.plateletRatio = 0.30; // Normal
          setTimeout(() => {
            condition.plateletRatio = originalRatio;
          }, 10000);
        }
      }

      function reverseAnticoagulation() {
        // Vitamin K or Prothrombin Complex Concentrate (PCC)
        // Improves fibrin stability and formation
        state.fibrinConstraints.forEach((f) => {
          f.stability = Math.min(1.0, f.stability + 0.3);
          f.decayRate = 0;
          f.visualColor = "#00E676";
          f.opacity = 1.0;
        });
      }

      function applyGenericTreatment() {
        // Generic treatment - improves all parameters slightly
        state.fibrinConstraints.forEach((f) => {
          f.stability = Math.min(1.0, f.stability + 0.2);
          f.glowing = true;
        });
      }

      function setCondition(condition) {
        state.condition = condition;
        state.treatmentApplied = false;
        state.simulationRunning = false;

        // Update UI
        document.querySelectorAll(".condition-btn").forEach((btn) => {
          const isActive = btn.dataset.condition === condition;
          btn.classList.toggle("active", isActive);
          btn.setAttribute("aria-checked", isActive ? "true" : "false");
        });

        // Actualizar ARIA
        updateConditionARIA();


        // Reset simulation
        initSimulation();


        // Habilitar botón de inicio
        const startBtn = document.getElementById("start-btn");
        const pauseBtn = document.getElementById("pause-btn");
        if (startBtn) {
          startBtn.disabled = false;
        }
        if (pauseBtn) {
          pauseBtn.disabled = true; // Deshabilitar pausa cuando no hay simulación corriendo
        }
        
        // Deshabilitar botón de tratamiento hasta que se inicie la simulación
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          treatmentBtn.disabled = true;
        }

      }

      function toggleSimulation() {
        if (!state.simulationRunning) {
          // Iniciar simulación
          state.simulationRunning = true;
          state.isPaused = false;
          state.startTime = Date.now();
          state.adhesionTime = null;
          state.closureTime = null;
          state.plateletsSpawned = 0;
          state.history = {
            time: [],
            clotPercentage: [],
            bloodLoss: [],
            fibrinConnections: [],
            stuckPlatelets: [],
          };
          // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
          lastPhysicsTime = 0;
          accumulatedTime = 0;

          // Asegurar que timeScale tenga un valor válido
          if (!state.timeScale || state.timeScale <= 0) {
            state.timeScale = 1.0;
          }

          // Reiniciar el spawn para asegurar que funcione
          startParticleSpawning();

          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitar botón de inicio cuando está corriendo
          }
          if (pauseBtn) {
            pauseBtn.disabled = false; // Habilitar botón de pausa cuando está corriendo
          }
          
          // Habilitar botón de tratamiento cuando la simulación está corriendo
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied) {
            treatmentBtn.disabled = false;
          }
        } else {
          // Pausar simulación
          state.simulationRunning = false;
          state.isPaused = true;
          // No usar Runner.stop() - usamos nuestro propio loop
          const startBtn = document.getElementById("start-btn");
          const pauseBtn = document.getElementById("pause-btn");
          if (startBtn) {
            startBtn.disabled = false; // Habilitar botón de inicio cuando está pausada
          }
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar botón de pausa cuando está pausada
          }
          
          // El botón de tratamiento permanece habilitado cuando la simulación está pausada
          // (siempre que se haya iniciado al menos una vez y no se haya aplicado ya)
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn && !state.treatmentApplied && state.startTime) {
            treatmentBtn.disabled = false;
          }
        }
      }

      // Event Listeners
      document.addEventListener("DOMContentLoaded", () => {
        initSimulation();


        // Condition buttons
        document.querySelectorAll(".condition-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            setCondition(btn.dataset.condition);
          });
        });

        // Treatment button
        const treatmentBtn = document.getElementById("treatment-btn");
        if (treatmentBtn) {
          treatmentBtn.addEventListener("click", applyTreatment);
          treatmentBtn.disabled = true; // Deshabilitado hasta iniciar simulación
        }

        // Start button
        const startBtn = document.getElementById("start-btn");
        if (startBtn) {
          startBtn.addEventListener("click", toggleSimulation);
          startBtn.disabled = true; // Deshabilitado hasta seleccionar condición
        }

        // Pause button
        const pauseBtn = document.getElementById("pause-btn");
        if (pauseBtn) {
          pauseBtn.addEventListener("click", toggleSimulation);
        }

        // Reset button
        document.getElementById("reset-btn").addEventListener("click", () => {
          state.simulationRunning = false;
          state.isPaused = false;
          state.condition = null;
          
          
          // No necesitamos detener el runner porque usamos nuestro propio loop
          initSimulation();
          
          // Desactivar todas las condiciones
          document.querySelectorAll(".condition-btn").forEach((btn) => {
            btn.classList.remove("active");
            btn.setAttribute("aria-checked", "false");
          });
          
          
          if (startBtn) {
            startBtn.disabled = true; // Deshabilitado hasta seleccionar condición
          }
          
          const pauseBtn = document.getElementById("pause-btn");
          if (pauseBtn) {
            pauseBtn.disabled = true; // Deshabilitar pausa al resetear
          }
          
          // Resetear botón de tratamiento
          const treatmentBtn = document.getElementById("treatment-btn");
          if (treatmentBtn) {
            treatmentBtn.classList.remove("applied");
            treatmentBtn.disabled = true; // Deshabilitado hasta iniciar simulación
            treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"
              />
            </svg>
            Administrar Tratamiento`;
          }
          
          // Remover efecto de pulsación del botón de reiniciar
          const resetBtn = document.getElementById("reset-btn");
          if (resetBtn) {
            resetBtn.classList.remove("hemostasis-pulse");
          }
          
          state.treatmentApplied = false;
          
          // Actualizar UI inmediatamente para mostrar valores reseteados
          updateUI();
        });

        // Inicializar controles avanzados
        setupSpeedControls();
        setupTooltips();



        // No activar ninguna condición por defecto
        // El botón de inicio permanece deshabilitado hasta que se seleccione una condición

        // Actualizar ARIA inicial
        updateConditionARIA();
      });
    </script>
  </body>
</html>
