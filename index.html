<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual de Hemostasia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #F8FAFC;
            min-height: 100vh;
            color: #1E293B;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
            padding: 16px 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .header h1 {
            color: #F8FAFC;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #94A3B8;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #22C55E;
            animation: pulse 2s infinite;
        }

        .status-dot.bleeding {
            background: #EF4444;
            animation: pulse-red 1s infinite;
        }

        .status-dot.treated {
            background: #3B82F6;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Simulation Viewer */
        .viewer-section {
            margin-bottom: 24px;
        }

        .viewer-container {
            position: relative;
            background: #0F172A;
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 
                        0 0 0 1px rgba(255,255,255,0.05);
            overflow: hidden;
            max-width: 1300px;
            margin: 0 auto;
        }

        .viewer-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .label {
            position: absolute;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .label-lumen {
            bottom: 12px;
            left: 12px;
        }

        .label-wound {
            top: 12px;
            right: 12px;
            left: auto;
            transform: none;
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.3);
            color: #FCA5A5;
        }

        .label-wound.healed {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.3);
            color: #86EFAC;
        }

        .treatment-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.9);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 20;
        }

        .treatment-indicator.visible {
            opacity: 1;
            animation: treatment-flash 0.5s ease-out;
        }

        @keyframes treatment-flash {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        #simulation-canvas {
            display: block;
            width: 100%;
            height: 300px;
            max-width: 100%;
        }

        /* FPS Counter */
        .fps-counter {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #94A3B8;
            font-family: 'Courier New', monospace;
            z-index: 15;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .fps-counter.good {
            color: #22C55E;
        }

        .fps-counter.medium {
            color: #F59E0B;
        }

        .fps-counter.low {
            color: #EF4444;
        }

        /* Control Panel */
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            max-width: 1300px;
            margin: 0 auto;
        }

        .panel-card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid #E2E8F0;
        }

        .panel-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64748B;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title svg {
            width: 16px;
            height: 16px;
            fill: #64748B;
        }

        /* Condition Selector */
        .condition-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        @media (min-width: 1200px) {
            .condition-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .condition-btn {
            background: #F8FAFC;
            border: 2px solid #E2E8F0;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .condition-btn:hover {
            border-color: #CBD5E1;
            background: #F1F5F9;
        }

        .condition-btn.active {
            border-color: #3B82F6;
            background: #EFF6FF;
        }

        .condition-btn.active .condition-name {
            color: #1D4ED8;
        }

        .condition-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: #1E293B;
            margin-bottom: 4px;
        }

        .condition-desc {
            font-size: 0.75rem;
            color: #64748B;
            line-height: 1.4;
        }

        /* Metrics Panel */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .metric-box {
            background: #F8FAFC;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            border: 1px solid #E2E8F0;
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 800;
            line-height: 1;
            margin-bottom: 4px;
        }

        .metric-value.blood-loss {
            color: #DC2626;
        }

        .metric-value.clot-progress {
            color: #059669;
        }

        .metric-label {
            font-size: 0.75rem;
            color: #64748B;
            font-weight: 500;
        }

        /* Progress Bar */
        .clot-progress-bar {
            height: 8px;
            background: #E2E8F0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .clot-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #059669);
            border-radius: 4px;
            transition: width 0.3s;
            width: 0%;
        }

        /* Treatment Button */
        .treatment-btn {
            width: 100%;
            padding: 16px 24px;
            background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.4);
        }

        .treatment-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .treatment-btn:disabled {
            background: #94A3B8;
            cursor: not-allowed;
            box-shadow: none;
        }

        .treatment-btn.applied {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.4);
        }

        .treatment-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Simulation Wizard */
        .simulation-wizard {
            margin: 20px 0;
            padding: 16px;
            background: #F8FAFC;
            border-radius: 12px;
            border: 1px solid #E2E8F0;
        }

        .wizard-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .wizard-step.active {
            opacity: 1;
            background: #E0F2FE;
            border: 2px solid #0EA5E9;
        }

        .wizard-step.completed {
            opacity: 0.8;
            background: #D1FAE5;
        }

        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #CBD5E1;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .wizard-step.active .step-number {
            background: #0EA5E9;
        }

        .wizard-step.completed .step-number {
            background: #10B981;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 600;
            color: #1E293B;
            font-size: 0.875rem;
            margin-bottom: 2px;
        }

        .step-desc {
            font-size: 0.75rem;
            color: #64748B;
        }

        /* Start Button */
        .start-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.3);
        }

        .start-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .start-btn.paused {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
        }

        /* Reset Button */
        .reset-btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            color: #64748B;
            border: 2px solid #E2E8F0;
            border-radius: 10px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }

        .reset-btn:hover {
            border-color: #CBD5E1;
            background: #F8FAFC;
            color: #475569;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #64748B;
        }

        .legend-dot {
            position: relative;
            display: inline-block;
        }

        /* Plaqueta: circular gris con highlight */
        .legend-dot.platelet {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #808080;
            box-shadow: 
                0 0 2px rgba(100, 100, 100, 0.3),
                inset -2px -2px 2px rgba(220, 220, 220, 0.4);
            position: relative;
        }
        
        .legend-dot.platelet::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(220, 220, 220, 0.7);
        }

        /* Gl√≥bulo rojo: ovalado con highlight */
        .legend-dot.rbc {
            width: 14px;
            height: 10px;
            border-radius: 50%;
            background: #B91C1C;
            box-shadow: 
                0 0 3px rgba(139, 0, 0, 0.4),
                inset -2px -1px 2px rgba(139, 0, 0, 0.2);
            position: relative;
        }
        
        .legend-dot.rbc::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 3px;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 200, 200, 0.8);
        }

        /* Gl√≥bulo blanco: circular con highlight brillante y contorno */
        .legend-dot.wbc {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #87CEEB;
            border: 1.5px solid #4A90E2;
            box-shadow: 
                0 0 2px rgba(74, 144, 226, 0.3),
                inset -4px -4px 6px rgba(255, 255, 255, 0.6);
            position: relative;
        }
        
        .legend-dot.wbc::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.6) 50%, rgba(255, 255, 255, 0) 100%);
        }
        
        .legend-dot.wbc::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 1);
        }

        /* Fibrina: morada con efecto de brillo */
        .legend-dot.fibrin {
            width: 24px;
            height: 3px;
            border-radius: 2px;
            background: #9D4EDD;
            box-shadow: 0 0 4px rgba(157, 78, 221, 0.6);
        }
        
        .legend-dot.vwf {
            width: 20px;
            height: 2px;
            border-radius: 1px;
            background: #22C55E;
            box-shadow: 0 0 3px rgba(34, 197, 94, 0.5);
        }

        /* Hemostasis Achieved Overlay */
        .hemostasis-achieved {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(16, 185, 129, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            display: none;
            align-items: center;
            gap: 6px;
            animation: fadeIn 0.5s;
        }

        .hemostasis-achieved.visible {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                max-width: 100%;
                padding: 16px;
            }
            
            .viewer-container {
                max-width: 100%;
            }
            
            .control-panel {
                max-width: 100%;
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .main-container {
                padding: 12px;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .header {
                padding: 12px 16px;
                flex-direction: column;
                gap: 12px;
            }
            
            .header-title h1 {
                font-size: 1.1rem;
            }
            
            .header-icon {
                width: 32px;
                height: 32px;
            }
            
            .viewer-container {
                border-radius: 12px;
            }
            
            .panel-card {
                padding: 16px;
            }
            
            .panel-title {
                font-size: 0.7rem;
                margin-bottom: 12px;
            }
            
            .condition-btn, .treatment-btn, .start-btn, .reset-btn {
                padding: 10px 16px;
                font-size: 0.875rem;
            }
            
            .fps-counter {
                font-size: 0.65rem;
                padding: 4px 8px;
                top: 8px;
                left: 8px;
            }
            
            #spawn-interval-counter {
                font-size: 0.65rem;
                padding: 4px 8px;
                top: 32px;
                left: 8px;
                max-width: calc(100% - 16px);
                word-break: break-word;
            }
            
            .label-wound {
                font-size: 0.65rem;
                padding: 4px 8px;
                top: 8px;
                right: 8px;
            }
            
            .treatment-indicator, .hemostasis-achieved {
                font-size: 0.875rem;
                padding: 8px 16px;
            }
            
            .legend {
                flex-wrap: wrap;
                gap: 8px;
                padding: 12px;
            }
            
            .legend-item {
                font-size: 0.75rem;
            }
            
            .wizard-step {
                padding: 8px 12px;
                font-size: 0.875rem;
            }
        }
        
        @media (max-width: 480px) {
            .main-container {
                padding: 8px;
            }
            
            .header {
                padding: 8px 12px;
            }
            
            .header-title h1 {
                font-size: 1rem;
            }
            
            .viewer-container {
                border-radius: 8px;
            }
            
            .panel-card {
                padding: 12px;
            }
            
            .condition-btn, .treatment-btn, .start-btn, .reset-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            .fps-counter, #spawn-interval-counter {
                font-size: 0.6rem;
                padding: 3px 6px;
            }
            
            #spawn-interval-counter {
                top: 28px;
            }
            
            .legend {
                padding: 8px;
                gap: 6px;
            }
            
            .legend-item {
                font-size: 0.7rem;
            }
            
            .wizard-step {
                padding: 6px 10px;
                font-size: 0.8rem;
            }
        }

        /* Fibrin glow effect when treatment applied */
        .fibrin-glow {
            filter: drop-shadow(0 0 8px #00E676) drop-shadow(0 0 16px #00E676);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-title">
            <div class="header-icon">
                <svg viewBox="0 0 24 24"><path d="M12 2C13.1 2 14 2.9 14 4C14 4.74 13.6 5.39 13 5.73V7H14C17.31 7 20 9.69 20 13V20C20 21.1 19.1 22 18 22H6C4.9 22 4 21.1 4 20V13C4 9.69 6.69 7 10 7H11V5.73C10.4 5.39 10 4.74 10 4C10 2.9 10.9 2 12 2M7.5 13C6.67 13 6 13.67 6 14.5C6 15.33 6.67 16 7.5 16C8.33 16 9 15.33 9 14.5C9 13.67 8.33 13 7.5 13M16.5 13C15.67 13 15 13.67 15 14.5C15 15.33 15.67 16 16.5 16C17.33 16 18 15.33 18 14.5C18 13.67 17.33 13 16.5 13M12 9C10.34 9 9 10.34 9 12H15C15 10.34 13.66 9 12 9Z"/></svg>
            </div>
            <h1>Laboratorio Virtual de Hemostasia</h1>
        </div>
        <div class="header-status">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Simulaci√≥n activa</span>
            </div>
        </div>
    </header>

    <main class="main-container">
        <section class="viewer-section">
            <div class="viewer-container">
                <div class="viewer-labels">
                    <div class="label label-wound" id="wound-label">‚ö†Ô∏è Lesi√≥n Activa</div>
                </div>
                <div class="treatment-indicator" id="treatment-indicator">
                    üíâ Tratamiento Administrado
                </div>
                <div class="hemostasis-achieved" id="hemostasis-indicator">
                    ‚úì Hemostasia Lograda
                </div>
                <div class="fps-counter" id="fps-counter">FPS: --</div>
                <div class="fps-counter" id="spawn-interval-counter" style="top: 40px;">Spawn: -- ms</div>
                <canvas id="simulation-canvas"></canvas>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot platelet"></div> Plaquetas</div>
                <div class="legend-item"><div class="legend-dot rbc"></div> Gl√≥bulos Rojos</div>
                <div class="legend-item"><div class="legend-dot wbc"></div> Gl√≥bulos Blancos</div>
                <div class="legend-item"><div class="legend-dot fibrin"></div> Red de Fibrina</div>
                <div class="legend-item"><div class="legend-dot vwf"></div> Factor von Willebrand</div>
            </div>
        </section>

        <section class="control-panel">
            <div class="panel-card">
                <div class="panel-title">
                    <svg viewBox="0 0 24 24"><path d="M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"/></svg>
                    Condici√≥n Cl√≠nica
                </div>
                <div class="condition-grid">
                    <button class="condition-btn active" data-condition="normal">
                        <div class="condition-name">Normal</div>
                        <div class="condition-desc">Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente</div>
                    </button>
                    <button class="condition-btn" data-condition="hemophilia">
                        <div class="condition-name">Hemofilia A/B</div>
                        <div class="condition-desc">D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable</div>
                    </button>
                    <button class="condition-btn" data-condition="vwd">
                        <div class="condition-name">Von Willebrand</div>
                        <div class="condition-desc">D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida</div>
                    </button>
                    <button class="condition-btn" data-condition="thrombocytopenia">
                        <div class="condition-name">Trombocitopenia</div>
                        <div class="condition-desc">Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo</div>
                    </button>
                    <button class="condition-btn" data-condition="hemophiliaSevere">
                        <div class="condition-name">Hemofilia Severa</div>
                        <div class="condition-desc">D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado</div>
                    </button>
                    <button class="condition-btn" data-condition="thrombasthenia">
                        <div class="condition-name">Trombastenia</div>
                        <div class="condition-desc">D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠</div>
                    </button>
                    <button class="condition-btn" data-condition="factorDeficiency">
                        <div class="condition-name">D√©ficit Factor VII</div>
                        <div class="condition-desc">V√≠a extr√≠nseca defectuosa - Formaci√≥n de fibrina reducida</div>
                    </button>
                    <button class="condition-btn" data-condition="anticoagulated">
                        <div class="condition-name">Anticoagulado</div>
                        <div class="condition-desc">Warfarina - Factores dependientes de vitamina K reducidos, fibrina inestable</div>
                    </button>
                </div>
            </div>

            <div class="panel-card">
                <div class="panel-title">
                    <svg viewBox="0 0 24 24"><path d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"/></svg>
                    M√©tricas en Tiempo Real
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-value blood-loss" id="blood-loss">0</div>
                        <div class="metric-label">P√©rdida Sangu√≠nea</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-value clot-progress" id="clot-percentage">0%</div>
                        <div class="metric-label">Cierre de la Herida</div>
                    </div>
                </div>
                <div class="clot-progress-bar">
                    <div class="clot-progress-fill" id="clot-bar"></div>
                </div>
                
                <!-- Simulation Wizard -->
                <div class="simulation-wizard">
                    <div class="wizard-step active" data-step="1">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <div class="step-title">Selecciona condici√≥n</div>
                            <div class="step-desc">Elige una condici√≥n cl√≠nica arriba</div>
                        </div>
                    </div>
                    <div class="wizard-step" data-step="2">
                        <div class="step-number">2</div>
                        <div class="step-content">
                            <div class="step-title">Configura par√°metros</div>
                            <div class="step-desc">Opcional: ajusta tratamiento</div>
                        </div>
                    </div>
                    <div class="wizard-step" data-step="3">
                        <div class="step-number">3</div>
                        <div class="step-content">
                            <div class="step-title">Inicia simulaci√≥n</div>
                            <div class="step-desc">Presiona el bot√≥n Iniciar</div>
                        </div>
                    </div>
                </div>
                
                <button class="start-btn" id="start-btn">‚ñ∂ Iniciar Simulaci√≥n</button>
                <button class="treatment-btn" id="treatment-btn">
                    <svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg>
                    Administrar Tratamiento
                </button>
                <button class="reset-btn" id="reset-btn">‚Üª Reiniciar Simulaci√≥n</button>
            </div>
        </section>
    </main>

    <script>
        // Matter.js modules
        const { Engine, Render, Runner, Bodies, Body, Composite, Constraint, Events, Vector } = Matter;

        // Simulation Configuration
        const CONFIG = {
            canvas: {
                width: 1300,
                height: 300
            },
            wound: {
                x: 550, // Center
                width: 300,
                height: 20
            },
            wall: {
                thickness: 30, // Increased thickness to prevent particles from passing through
                color: '#FDA4AF'
            },
            physics: {
                flowForce: 0.0004,
                suctionForce: 0.0015, // Aumentado para hacer la succi√≥n m√°s fuerte
                suctionRadius: 180
            },
            particles: {
                maxCount: 150, // Reduced for better performance
                spawnRate: 3, // Reduced for better performance
                plateletRatio: 0.35,
                rbcRatio: 0.60,
                wbcRatio: 0.05
            },
            fibrin: {
                maxConnections: 200, // Limit fibrin connections to prevent performance issues
                maxConnectionsPerPlatelet: 8 // Limit connections per platelet
            },
            stuckPlatelets: {
                maxCount: 80 // L√≠mite m√°ximo de plaquetas pegadas para mantener rendimiento
            },
            conditions: {
                normal: {
                    name: "Normal",
                    description: "Coagulaci√≥n fisiol√≥gica normal - Todos los factores funcionan correctamente",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 1.0,
                    fibrinStability: 1.0,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    bleedingTime: 3,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: false, // Puede sellarse autom√°ticamente
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                hemophilia: {
                    name: "Hemofilia A/B",
                    description: "D√©ficit Factor VIII/IX - Las plaquetas se adhieren pero la fibrina se forma muy lentamente y es inestable",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.15,
                    fibrinStability: 0.3,
                    fibrinDecayRate: 0.03,
                    fibrinFormationDelay: 1500,
                    bleedingTime: 30,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FF6B6B',
                        fibrinGlow: false,
                        fibrinOpacity: 0.6
                    }
                },
                vwd: {
                    name: "Enfermedad de Von Willebrand",
                    description: "D√©ficit Factor vWF - Las plaquetas tienen dificultad para adherirse a la herida",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.2,
                    plateletFunction: 0.4,
                    adhesionStrength: 0.25,
                    aggregationRate: 0.3,
                    fibrinFormationRate: 0.7,
                    fibrinStability: 0.85,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    plateletBounceFactor: 0.7,
                    adhesionRetryChance: 0.4,
                    bleedingTime: 15,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: true, // Requiere tratamiento para sellado completo
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                thrombocytopenia: {
                    name: "Trombocitopenia",
                    description: "Recuento bajo de plaquetas - Pocas plaquetas disponibles para formar el co√°gulo",
                    plateletRatio: 0.08,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.6,
                    fibrinStability: 0.8,
                    fibrinDecayRate: 0.0,
                    fibrinFormationDelay: 0,
                    spawnRateMultiplier: 0.3,
                    bleedingTime: 20,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: false,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#00E676',
                        fibrinGlow: false,
                        fibrinOpacity: 1.0
                    }
                },
                hemophiliaSevere: {
                    name: "Hemofilia Severa",
                    description: "D√©ficit grave Factor VIII/IX (<1%) - Sin formaci√≥n de fibrina, sangrado prolongado",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: false,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.0,
                    fibrinStability: 0.0,
                    fibrinDecayRate: 0.2,
                    fibrinFormationDelay: 0,
                    bleedingTime: 60,
                    blockThickCords: true, // Bloquear todas las cuerdas gruesas
                    blockMediumCords: true, // Solo cuerdas peque√±as permitidas
                    blockThinCords: false,
                    requiresTreatment: true,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FF0000',
                        fibrinGlow: false,
                        fibrinOpacity: 0.3
                    }
                },
                thrombasthenia: {
                    name: "Trombastenia de Glanzmann",
                    description: "D√©ficit glicoprote√≠na IIb/IIIa - Las plaquetas se adhieren pero no se agregan entre s√≠",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.9,
                    plateletFunction: 0.2,
                    adhesionStrength: 0.85,
                    aggregationRate: 0.1,
                    fibrinFormationRate: 0.4,
                    fibrinStability: 0.6,
                    fibrinDecayRate: 0.01,
                    fibrinFormationDelay: 500,
                    maxPlateletClusterSize: 2,
                    bleedingTime: 25,
                    blockThickCords: false,
                    blockMediumCords: false,
                    blockThinCords: false,
                    requiresTreatment: true,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FFA500',
                        fibrinGlow: false,
                        fibrinOpacity: 0.8
                    }
                },
                factorDeficiency: {
                    name: "D√©ficit Factor VII",
                    description: "D√©ficit Factor VII - V√≠a extr√≠nseca defectuosa, formaci√≥n de fibrina reducida",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.5,
                    fibrinStability: 0.75,
                    fibrinDecayRate: 0.01,
                    fibrinFormationDelay: 1000,
                    bleedingTime: 12,
                    blockThickCords: false,
                    blockMediumCords: true, // Bloquear cuerdas medianas y peque√±as
                    blockThinCords: true, // Solo cuerdas gruesas (pero d√©biles)
                    requiresTreatment: false,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FFD700',
                        fibrinGlow: false,
                        fibrinOpacity: 0.9
                    }
                },
                anticoagulated: {
                    name: "Anticoagulado (Warfarina)",
                    description: "Anticoagulaci√≥n oral - Factores dependientes de vitamina K reducidos, fibrina inestable",
                    plateletRatio: 0.35,
                    canStick: true,
                    canFormFibrin: true,
                    stickProbability: 0.95,
                    plateletFunction: 1.0,
                    adhesionStrength: 0.95,
                    aggregationRate: 0.9,
                    fibrinFormationRate: 0.4,
                    fibrinStability: 0.5,
                    fibrinDecayRate: 0.05,
                    fibrinFormationDelay: 800,
                    bleedingTime: 8,
                    visualEffects: {
                        plateletColor: '#808080',
                        fibrinColor: '#FF6347',
                        fibrinGlow: false,
                        fibrinOpacity: 0.7
                    }
                }
            }
        };

        // Game State
        let state = {
            condition: 'normal',
            treatmentApplied: false,
            bloodLoss: 0,
            clotPercentage: 0,
            hemostasisAchieved: false,
            stuckPlatelets: [],
            fibrinConstraints: [],
            fibrinBodies: [], // Physical bodies for fibrin network
            allBodies: [],
            showOintment: false,
            fibrinFormationStarted: false, // Secuencia: plaquetas primero, luego malla
            simulationRunning: false, // Control manual de simulaci√≥n
            currentStep: 1 // Paso actual del wizard
        };

        // Spawn timing for fixed interval
        let spawnInterval = null;
        let lastSpawnTime = 0;
        let spawnIntervalCounter = null;
        let actualSpawnIntervals = []; // Array para calcular el intervalo promedio
        const SPAWN_INTERVAL_MS = 100; // Fixed spawn interval in milliseconds
        
        // Performance optimization: frame counters for throttling
        let frameCount = 0;
        const CLEANUP_INTERVAL = 5; // Cleanup every 5 frames (m√°s frecuente para mejor limpieza)
        const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames
        
        // Fixed timestep loop variables - garantizar velocidad constante independiente del FPS
        let physicsLoopId = null;
        let renderLoopId = null;
        let lastPhysicsTime = 0;
        const FIXED_TIMESTEP = 1000 / 60; // 16.67ms = 60 FPS fijo para f√≠sica
        let accumulatedTime = 0;

        // Matter.js Setup
        let engine, render, runner;

        function initSimulation() {
            // Clear spawn interval
            if (spawnInterval !== null) {
                clearInterval(spawnInterval);
                spawnInterval = null;
            }
            if (spawnIntervalCounter !== null) {
                clearInterval(spawnIntervalCounter);
                spawnIntervalCounter = null;
            }
            
            lastSpawnTime = 0;
            actualSpawnIntervals = [];
            spawnStats = {
                lastSpawnCount: 0,
                totalSpawned: 0,
                spawnHistory: []
            };

            // Reset state
            state = {
                condition: state.condition,
                treatmentApplied: false,
                bloodLoss: 0,
                clotPercentage: 0,
                hemostasisAchieved: false,
                stuckPlatelets: [],
                fibrinConstraints: [],
                fibrinBodies: [],
                allBodies: [],
                showOintment: false
            };

            // Stop FPS counter
            stopFPSCounter();
            
            // Clear previous engine events
            if (engine) {
                Events.off(engine, 'beforeUpdate');
                Events.off(engine, 'afterUpdate');
                Events.off(engine, 'collisionStart');
                // Remove anchor platelets before clearing world
                if (state.stuckPlatelets) {
                    state.stuckPlatelets.forEach(plateletData => {
                        if (plateletData.isAnchor && plateletData.body) {
                            Composite.remove(engine.world, plateletData.body);
                        }
                    });
                }
                Composite.clear(engine.world);
                Engine.clear(engine);
            }
            if (render) {
                Events.off(render, 'afterRender');
                Render.stop(render);
            }
            // No necesitamos detener el runner porque usamos nuestro propio loop
            // if (runner) {
            //     Runner.stop(runner);
            // }
            
            // Reset canvas
            const canvas = document.getElementById('simulation-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset state
            state.fibrinFormationStarted = false;
            state.simulationRunning = false;
            state.currentStep = 1;
            
            // Reset UI elements
            document.getElementById('hemostasis-indicator').classList.remove('visible');
            const woundLabel = document.getElementById('wound-label');
            woundLabel.classList.remove('healed', 'hidden');
            woundLabel.innerHTML = '‚ö†Ô∏è Lesi√≥n Activa';
            
            const treatmentBtn = document.getElementById('treatment-btn');
            treatmentBtn.classList.remove('applied');
            treatmentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M11.15,15.18L9.73,13.77L11.15,12.35L12.56,13.77L13.97,12.35L12.56,10.94L13.97,9.53L15.39,10.94L16.8,9.53L13.97,6.7L6.9,13.77L9.73,16.6L11.15,15.18M3.08,9.27L9.73,2.62L11.15,4.03L4.5,10.69L3.08,9.27M20.92,14.73L14.27,21.38L12.85,19.97L19.5,13.31L20.92,14.73Z"/></svg> Administrar Tratamiento`;
            treatmentBtn.disabled = false;

            // Create engine with zero gravity
            engine = Engine.create();
            engine.world.gravity.x = 0;
            engine.world.gravity.y = 0;

            // Create renderer using existing canvas
            const canvasEl = document.getElementById('simulation-canvas');
            
            // Guardar el ancho original del canvas
            const originalCanvasWidth = CONFIG.canvas.width;
            const fixedCanvasHeight = CONFIG.canvas.height; // 300px fijo
            
            // Ajustar tama√±o del canvas seg√∫n el tama√±o de la pantalla
            // Mantener altura fija, solo ajustar ancho
            const updateCanvasSize = () => {
                const container = canvasEl.parentElement;
                const containerWidth = container.clientWidth;
                const maxWidth = Math.min(originalCanvasWidth, containerWidth - 32); // 32px de padding
                
                // Mantener altura fija, solo ajustar ancho
                canvasEl.width = maxWidth;
                canvasEl.height = fixedCanvasHeight;
                
                // Actualizar CONFIG para que la f√≠sica use el nuevo tama√±o
                CONFIG.canvas.width = maxWidth;
                CONFIG.canvas.height = fixedCanvasHeight;
                
                // Mantener la herida siempre centrada
                CONFIG.wound.x = maxWidth / 2;
                
                // Si el engine ya existe, necesitamos recrear las paredes con el nuevo tama√±o
                if (engine && state.simulationRunning === false) {
                    // Solo recrear si la simulaci√≥n no est√° corriendo
                    // Las paredes se recrear√°n en el siguiente initSimulation
                }
            };
            
            updateCanvasSize();
            
            // Actualizar tama√±o cuando cambia el tama√±o de la ventana
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateCanvasSize();
                    // Si la simulaci√≥n est√° corriendo, reiniciar para aplicar los cambios
                    if (state.simulationRunning) {
                        const wasRunning = state.simulationRunning;
                        state.simulationRunning = false;
                        initSimulation();
                        if (wasRunning) {
                            setTimeout(() => {
                                state.simulationRunning = true;
                                lastPhysicsTime = 0;
                                accumulatedTime = 0;
                            }, 100);
                        }
                    }
                }, 250);
            });
            
            render = Render.create({
                canvas: canvasEl,
                engine: engine,
                options: {
                    width: canvasEl.width,
                    height: canvasEl.height,
                    wireframes: false,
                    background: '#0F172A',
                    // Desacoplar el renderer del timestep de la f√≠sica
                    // El renderer se actualiza a su propio ritmo, pero la f√≠sica siempre usa timestep fijo
                    pixelRatio: window.devicePixelRatio || 1
                }
            });
            
            // Asegurar que el engine siempre use timestep fijo
            engine.timing.timeScale = 1.0;
            engine.timing.timestamp = 0;

            // Create vessel walls
            createVesselWalls();

            // Start engine and renderer with fixed timestep
            // Configurar el engine para usar timestep fijo
            engine.timing.timeScale = 1.0; // Asegurar que el timeScale sea 1.0
            
            // Crear Runner pero NO ejecutarlo autom√°ticamente
            // Usaremos nuestro propio loop con timestep fijo garantizado
            runner = Runner.create({
                delta: FIXED_TIMESTEP,
                isFixed: true,
                enabled: false // Deshabilitar el loop autom√°tico
            });
            
            // Loop de renderizado independiente (puede ejecutarse a cualquier FPS)
            function renderLoop() {
                if (render) {
                    Render.world(render);
                }
                renderLoopId = requestAnimationFrame(renderLoop);
            }
            
            // Iniciar el loop de renderizado (siempre activo)
            renderLoop();
            
            // Loop de f√≠sica con timestep fijo (solo se ejecuta cuando simulationRunning = true)
            function physicsLoop(currentTime) {
                if (!state.simulationRunning) {
                    physicsLoopId = requestAnimationFrame(physicsLoop);
                    return;
                }
                
                // Calcular tiempo transcurrido desde el √∫ltimo frame
                if (lastPhysicsTime === 0) {
                    lastPhysicsTime = currentTime;
                }
                
                const deltaTime = currentTime - lastPhysicsTime;
                lastPhysicsTime = currentTime;
                
                // Acumular tiempo y ejecutar pasos de f√≠sica a intervalos fijos
                accumulatedTime += deltaTime;
                
                // Ejecutar tantos pasos de f√≠sica como sean necesarios para mantener timestep fijo
                const maxSteps = 5; // Limitar pasos por frame para evitar "spiral of death"
                let stepsExecuted = 0;
                
                while (accumulatedTime >= FIXED_TIMESTEP && stepsExecuted < maxSteps) {
                    // Ejecutar un paso de f√≠sica con timestep fijo
                    Engine.update(engine, FIXED_TIMESTEP);
                    accumulatedTime -= FIXED_TIMESTEP;
                    stepsExecuted++;
                }
                
                // Si acumulamos demasiado tiempo, resetear para evitar lag
                if (accumulatedTime > FIXED_TIMESTEP * 5) {
                    accumulatedTime = 0;
                }
                
                physicsLoopId = requestAnimationFrame(physicsLoop);
            }
            
            // Iniciar el loop de f√≠sica (siempre activo, pero solo procesa cuando simulationRunning = true)
            // Resetear variables de tiempo
            lastPhysicsTime = 0;
            accumulatedTime = 0;
            
            // Iniciar el loop de f√≠sica
            if (!physicsLoopId) {
                physicsLoopId = requestAnimationFrame(physicsLoop);
            }
            
            // Estado inicial: simulaci√≥n no corriendo
            state.simulationRunning = false;

            // Setup collision events
            setupCollisionEvents();

            // Start particle spawning
            startParticleSpawning();

            // Reset frame counter
            frameCount = 0;
            
            // Update loop for forces - use fixed timestep for frame-independent forces
            // Con isFixed: true, el Runner ejecuta pasos de f√≠sica a intervalos fijos
            // Cada paso siempre es de 16.67ms, independientemente del FPS del renderer
            Events.on(engine, 'beforeUpdate', () => {
                // Solo actualizar si la simulaci√≥n est√° corriendo
                if (!state.simulationRunning) return;
                
                frameCount++;
                // Con isFixed: true, cada paso del engine es exactamente delta (16.67ms)
                // No necesitamos calcular timeScale porque siempre es 1.0
                const timestep = runner.delta; // Usar el delta real del Runner (16.67ms)
                applyForces(timestep);
                
                // Update fibrin barrier positions to follow platelets (every 3 frames for performance)
                if (frameCount % 3 === 0 && state.fibrinConstraints.length > 0) {
                    state.fibrinConstraints.forEach(fibrin => {
                        if (fibrin.body && fibrin.pointA && fibrin.pointB) {
                            const midX = (fibrin.pointA.position.x + fibrin.pointB.position.x) / 2;
                            const midY = (fibrin.pointA.position.y + fibrin.pointB.position.y) / 2;
                            const dist = Vector.magnitude(Vector.sub(fibrin.pointB.position, fibrin.pointA.position));
                            const angle = Math.atan2(
                                fibrin.pointB.position.y - fibrin.pointA.position.y,
                                fibrin.pointB.position.x - fibrin.pointA.position.x
                            );
                            
                            Body.setPosition(fibrin.body, { x: midX, y: midY });
                            Body.setAngle(fibrin.body, angle);
                            // Update width to match distance
                            const currentWidth = fibrin.body.bounds.max.x - fibrin.body.bounds.min.x;
                            if (Math.abs(currentWidth - dist) > 1) {
                                Body.scale(fibrin.body, dist / currentWidth, 1);
                            }
                        }
                    });
                }
                
                // Throttle expensive operations
                if (frameCount % CLEANUP_INTERVAL === 0) {
                    cleanupParticles();
                    // Tambi√©n limpiar plaquetas pegadas antiguas peri√≥dicamente
                    cleanupOldStuckPlatelets();
                }
                if (frameCount % UI_UPDATE_INTERVAL === 0) {
                    calculateClotPercentage();
                    updateUI();
                }
                
                // vWF se renderiza como l√≠neas entre plaquetas (no necesita actualizaci√≥n)
            });

            // Custom render - orden importante: primero fibrina (cuerdas blancas y malla morada), luego vWF (l√≠neas verdes), luego part√≠culas
            Events.on(render, 'afterRender', renderFibrin);
            Events.on(render, 'afterRender', renderVWF); // vWF se renderiza despu√©s de las cuerdas blancas
            Events.on(render, 'afterRender', renderParticlesCustom);
            
            // Start FPS counter
            startFPSCounter();
            
            // Inicializar contador de intervalo de spawn
            const spawnElement = document.getElementById('spawn-interval-counter');
            if (spawnElement) {
                spawnElement.textContent = `Spawn: -- ms | √öltimo: 0 | Promedio: 0 | Total: 0/${CONFIG.particles.maxCount}`;
            }

            // Update UI
            updateUI();
        }
        
        // FPS Counter variables
        let fpsValue = 0;
        let fpsLastTime = performance.now();
        let fpsFrameCount = 0;
        let fpsUpdateInterval = 0;
        let fpsAnimationFrame = null;
        
        function startFPSCounter() {
            // Cancel any existing FPS counter loop
            if (fpsAnimationFrame !== null) {
                cancelAnimationFrame(fpsAnimationFrame);
                fpsAnimationFrame = null;
            }
            
            fpsValue = 0;
            fpsLastTime = performance.now();
            fpsFrameCount = 0;
            fpsUpdateInterval = 0;
            updateFPS();
        }
        
        function stopFPSCounter() {
            if (fpsAnimationFrame !== null) {
                cancelAnimationFrame(fpsAnimationFrame);
                fpsAnimationFrame = null;
            }
        }
        
        function updateFPS() {
            fpsAnimationFrame = requestAnimationFrame(() => {
                const currentTime = performance.now();
                fpsFrameCount++;
                fpsUpdateInterval += currentTime - fpsLastTime;
                fpsLastTime = currentTime;
                
                // Update FPS display every 500ms
                if (fpsUpdateInterval >= 500) {
                    fpsValue = Math.round((fpsFrameCount * 1000) / fpsUpdateInterval);
                    fpsFrameCount = 0;
                    fpsUpdateInterval = 0;
                    
                    const fpsElement = document.getElementById('fps-counter');
                    if (fpsElement) {
                        fpsElement.textContent = `FPS: ${fpsValue}`;
                        
                        // Color coding based on FPS
                        fpsElement.classList.remove('good', 'medium', 'low');
                        if (fpsValue >= 55) {
                            fpsElement.classList.add('good');
                        } else if (fpsValue >= 30) {
                            fpsElement.classList.add('medium');
                        } else {
                            fpsElement.classList.add('low');
                        }
                    }
                }
                
                updateFPS();
            });
        }

        function createVesselWalls() {
            const { width, height } = CONFIG.canvas;
            const { thickness, color } = CONFIG.wall;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;

            // Bottom wall (solid) - with bounce and collision filter
            const bottomWall = Bodies.rectangle(width / 2, height - thickness / 2, width, thickness, {
                isStatic: true,
                render: { fillStyle: color },
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Top wall - Left segment - with bounce and collision filter
            const leftWallWidth = woundX - woundWidth / 2;
            const topWallLeft = Bodies.rectangle(leftWallWidth / 2, thickness / 2, leftWallWidth, thickness, {
                isStatic: true,
                render: { fillStyle: color },
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Top wall - Right segment - with bounce and collision filter
            const rightWallStart = woundX + woundWidth / 2;
            const rightWallWidth = width - rightWallStart;
            const topWallRight = Bodies.rectangle(rightWallStart + rightWallWidth / 2, thickness / 2, rightWallWidth, thickness, {
                isStatic: true,
                render: { fillStyle: color },
                label: 'wall',
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            // Wound edge markers (left and right edges of wound)
            const woundEdgeLeft = Bodies.rectangle(woundX - woundWidth / 2, thickness / 2, 6, thickness + 10, {
                isStatic: true,
                render: { fillStyle: '#F87171' },
                label: 'woundEdge',
                isSensor: false,
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            const woundEdgeRight = Bodies.rectangle(woundX + woundWidth / 2, thickness / 2, 6, thickness + 10, {
                isStatic: true,
                render: { fillStyle: '#F87171' },
                label: 'woundEdge',
                isSensor: false,
                restitution: 0.8, // Higher restitution for stronger bounce
                friction: 0.1,
                collisionFilter: {
                    category: 0x0004, // Wall category
                    mask: 0xFFFFFFFF // Collide with everything
                }
            });

            Composite.add(engine.world, [bottomWall, topWallLeft, topWallRight, woundEdgeLeft, woundEdgeRight]);
            
            // Create invisible anchor platelets on each side of the wound
            createInvisibleAnchorPlatelets(woundX, woundWidth, thickness);
        }
        
        function createInvisibleAnchorPlatelets(woundX, woundWidth, wallThickness) {
            const adhesionLineY = 23; // Same Y position as the adhesion line
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            // Left anchor platelet - positioned just inside the left edge of the wound
            const leftAnchorX = woundLeft + 2;
            const leftAnchor = Bodies.circle(leftAnchorX, adhesionLineY + 6, 4, {
                isStatic: true,
                render: { fillStyle: 'transparent', visible: false },
                label: 'platelet',
                isStuck: true,
                isAnchor: true // Mark as anchor platelet
            });
            
            // Right anchor platelet - positioned just inside the right edge of the wound
            const rightAnchorX = woundRight - 10;
            const rightAnchor = Bodies.circle(rightAnchorX, adhesionLineY + 6, 4, {
                isStatic: true,
                render: { fillStyle: 'transparent', visible: false },
                label: 'platelet',
                isStuck: true,
                isAnchor: true // Mark as anchor platelet
            });
            
            Composite.add(engine.world, [leftAnchor, rightAnchor]);
            
            // Add to stuck platelets list so they can form fibrin connections
            const leftAnchorData = {
                body: leftAnchor,
                constraint: null,
                hasFibrin: false,
                fibrinConnections: [],
                isAnchor: true
            };
            
            const rightAnchorData = {
                body: rightAnchor,
                constraint: null,
                hasFibrin: false,
                fibrinConnections: [],
                isAnchor: true
            };
            
            state.stuckPlatelets.push(leftAnchorData, rightAnchorData);
            
            // Try to form fibrin connections from anchor platelets after a delay
            setTimeout(() => {
                if (state.stuckPlatelets.includes(leftAnchorData)) {
                    tryFormFibrin(leftAnchorData);
                }
                if (state.stuckPlatelets.includes(rightAnchorData)) {
                    tryFormFibrin(rightAnchorData);
                }
            }, 200);
        }

        function createParticle(type) {
            const y = 50 + Math.random() * 200;
            const x = -10;

            let body;

            switch (type) {
                case 'platelet':
                    body = Bodies.circle(x, y, 4, {
                        render: { 
                            fillStyle: 'transparent',
                            strokeStyle: 'transparent',
                            visible: false // No renderizar con Matter.js - solo custom
                        },
                        label: 'platelet',
                        restitution: 0.5, // Increased for better wall bounce
                        friction: 0.1,
                        frictionAir: 0.02,
                        density: 0.001,
                        isSticky: true,
                        isStuck: false,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001,
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;

                case 'rbc':
                    // Gl√≥bulos rojos: usar c√≠rculo pero renderizar como elipse en custom render
                    body = Bodies.circle(x, y, 6, {
                        render: { 
                            fillStyle: 'transparent',
                            strokeStyle: 'transparent',
                            visible: false // No renderizar con Matter.js - solo custom
                        },
                        label: 'rbc',
                        restitution: 0.8, // Higher restitution for better bounce
                        friction: 0.05,
                        frictionAir: 0.01,
                        density: 0.0008,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001, // RBC category
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;

                case 'wbc':
                    body = Bodies.circle(x, y, 10, {
                        render: { 
                            fillStyle: 'transparent',
                            strokeStyle: 'transparent',
                            visible: false // No renderizar con Matter.js - solo custom
                        },
                        label: 'wbc',
                        restitution: 0.7, // Higher restitution for better bounce
                        friction: 0.1,
                        frictionAir: 0.03,
                        density: 0.002,
                        collisionFilter: {
                            group: 0,
                            category: 0x0001, // WBC category
                            mask: 0x0002 | 0x0004 // Collide with fibrin barriers and walls
                        }
                    });
                    break;
            }

            if (body) {
                Composite.add(engine.world, body);
                state.allBodies.push(body);
            }

            return body;
        }

        // Variables para tracking de spawn
        let spawnStats = {
            lastSpawnCount: 0,
            totalSpawned: 0,
            spawnHistory: [] // √öltimos 10 conteos de spawn
        };

        function startParticleSpawning() {
            // Clear any existing interval
            if (spawnInterval !== null) {
                clearInterval(spawnInterval);
                spawnInterval = null;
            }
            if (spawnIntervalCounter !== null) {
                clearInterval(spawnIntervalCounter);
                spawnIntervalCounter = null;
            }
            
            lastSpawnTime = performance.now();
            actualSpawnIntervals = [];
            spawnStats = {
                lastSpawnCount: 0,
                totalSpawned: 0,
                spawnHistory: []
            };
            
            // Use setInterval for absolute precision - this is the most reliable method
            spawnInterval = setInterval(() => {
                // Solo spawnear si la simulaci√≥n est√° corriendo
                if (!state.simulationRunning) {
                    return;
                }
                
                const currentTime = performance.now();
                const actualInterval = currentTime - lastSpawnTime;
                
                // Registrar el intervalo real para el contador
                actualSpawnIntervals.push(actualInterval);
                if (actualSpawnIntervals.length > 20) {
                    actualSpawnIntervals.shift(); // Mantener solo los √∫ltimos 20
                }
                
                let spawnedThisCycle = 0;
                
                // Contar solo part√≠culas m√≥viles (no pegadas) para el l√≠mite de spawn
                const mobileBodies = state.allBodies.filter(b => {
                    return !state.stuckPlatelets.some(p => p.body === b);
                });
                
                if (mobileBodies.length < CONFIG.particles.maxCount) {
                    const conditionConfig = CONFIG.conditions[state.condition];
                    const plateletRatio = conditionConfig.plateletRatio;
                    
                    // Apply spawn rate multiplier for conditions like thrombocytopenia
                    const spawnMultiplier = conditionConfig.spawnRateMultiplier || 1.0;
                    const spawnCount = Math.max(1, Math.floor(CONFIG.particles.spawnRate * spawnMultiplier));

                    for (let i = 0; i < spawnCount; i++) {
                        // Verificar l√≠mite con part√≠culas m√≥viles actualizadas
                        const currentMobileCount = state.allBodies.filter(b => {
                            return !state.stuckPlatelets.some(p => p.body === b);
                        }).length;
                        if (currentMobileCount >= CONFIG.particles.maxCount) break;
                        
                        const rand = Math.random();
                        
                        if (rand < plateletRatio) {
                            createParticle('platelet');
                            spawnedThisCycle++;
                        } else if (rand < plateletRatio + CONFIG.particles.rbcRatio) {
                            createParticle('rbc');
                            spawnedThisCycle++;
                        } else {
                            createParticle('wbc');
                            spawnedThisCycle++;
                        }
                    }
                }
                
                // Registrar estad√≠sticas de spawn
                spawnStats.lastSpawnCount = spawnedThisCycle;
                spawnStats.totalSpawned += spawnedThisCycle;
                spawnStats.spawnHistory.push(spawnedThisCycle);
                if (spawnStats.spawnHistory.length > 10) {
                    spawnStats.spawnHistory.shift();
                }
                
                lastSpawnTime = currentTime;
            }, SPAWN_INTERVAL_MS);
            
            // Contador visual del intervalo de spawn
            spawnIntervalCounter = setInterval(() => {
                if (actualSpawnIntervals.length > 0) {
                    const avgInterval = actualSpawnIntervals.reduce((a, b) => a + b, 0) / actualSpawnIntervals.length;
                    const lastInterval = actualSpawnIntervals[actualSpawnIntervals.length - 1];
                    const avgSpawnCount = spawnStats.spawnHistory.length > 0 
                        ? (spawnStats.spawnHistory.reduce((a, b) => a + b, 0) / spawnStats.spawnHistory.length).toFixed(1)
                        : '0';
                    
                    const spawnElement = document.getElementById('spawn-interval-counter');
                    if (spawnElement) {
                        spawnElement.textContent = `Spawn: ${Math.round(lastInterval)}ms | √öltimo: ${spawnStats.lastSpawnCount} | Promedio: ${avgSpawnCount} | Total: ${state.allBodies.length}/${CONFIG.particles.maxCount}`;
                        // Color coding: verde si est√° cerca del intervalo objetivo, amarillo si est√° un poco desviado, rojo si est√° muy desviado
                        spawnElement.classList.remove('good', 'medium', 'low');
                        if (Math.abs(lastInterval - SPAWN_INTERVAL_MS) < 5) {
                            spawnElement.classList.add('good');
                        } else if (Math.abs(lastInterval - SPAWN_INTERVAL_MS) < 20) {
                            spawnElement.classList.add('medium');
                        } else {
                            spawnElement.classList.add('low');
                        }
                    }
                }
            }, 500); // Actualizar cada 500ms
        }
        
        function toggleSimulation() {
            if (!state.simulationRunning) {
                // Iniciar simulaci√≥n
                state.simulationRunning = true;
                // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
                lastPhysicsTime = 0;
                accumulatedTime = 0;
                const startBtn = document.getElementById('start-btn');
                startBtn.textContent = '‚è∏ Pausar Simulaci√≥n';
                startBtn.classList.add('paused');
                updateWizardStep(3);
            } else {
                // Pausar simulaci√≥n
                state.simulationRunning = false;
                // No usar Runner.stop() - usamos nuestro propio loop
                const startBtn = document.getElementById('start-btn');
                startBtn.textContent = '‚ñ∂ Reanudar Simulaci√≥n';
                startBtn.classList.remove('paused');
            }
        }
        
        function updateWizardStep(step) {
            state.currentStep = step;
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');
                if (stepNum < step) {
                    el.classList.add('completed');
                } else if (stepNum === step) {
                    el.classList.add('active');
                }
            });
        }

        function applyForces(timestep = 16.67) {
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            
            // Invisible adhesion line parameters - positioned at wound opening
            const adhesionLineY = 23; // Y position of the invisible line
            const adhesionLineThreshold = 14; // How close to trigger adhesion check
            
            // IMPORTANTE: Con Runner.isFixed = true y delta = 16.67ms,
            // el timestep siempre es constante independientemente del FPS del renderer.
            // El Runner ejecuta pasos de f√≠sica a intervalos fijos, y cada paso siempre es de 16.67ms.
            // Por lo tanto, timeScale siempre debe ser 1.0 para mantener velocidad constante.
            // NO escalamos por el timestep real porque ya est√° fijo en 16.67ms.
            const timeScale = 1.0; // Siempre 1.0 porque el timestep es fijo

            state.allBodies.forEach(body => {
                // Skip stuck platelets and static bodies
                if (body.isStuck || body.isStatic) return;

                // Prevent particles from passing through walls by checking bounds
                const { width, height } = CONFIG.canvas;
                const wallThickness = CONFIG.wall.thickness;
                const particleRadius = body.circleRadius || (body.label === 'rbc' ? 6 : body.label === 'wbc' ? 10 : 4);
                
                // Check bottom wall
                if (body.position.y > height - wallThickness - particleRadius) {
                    Body.setPosition(body, {
                        x: body.position.x,
                        y: height - wallThickness - particleRadius - 0.1
                    });
                    Body.setVelocity(body, {
                        x: body.velocity.x,
                        y: Math.min(0, body.velocity.y * -0.8) // Bounce up
                    });
                }
                
                // Check top walls (left and right segments)
                const woundX = CONFIG.wound.x;
                const woundWidth = CONFIG.wound.width;
                const woundLeft = woundX - woundWidth / 2;
                const woundRight = woundX + woundWidth / 2;
                
                if (body.position.y < wallThickness + particleRadius) {
                    // Check if particle is in wound area
                    if (body.position.x < woundLeft || body.position.x > woundRight) {
                        // Outside wound - push back from top wall
                        Body.setPosition(body, {
                            x: body.position.x,
                            y: wallThickness + particleRadius + 0.1
                        });
                        Body.setVelocity(body, {
                            x: body.velocity.x,
                            y: Math.max(0, body.velocity.y * -0.8) // Bounce down
                        });
                    }
                }

                // Laminar flow force (right) - scaled by timestep for frame independence
                Body.applyForce(body, body.position, {
                    x: CONFIG.physics.flowForce * body.mass * timeScale,
                    y: 0
                });

                // Suction force (only under the wound) - scaled by timestep
                // Desplazar la succi√≥n hacia la izquierda
                const suctionOffset = -15; // Desplazamiento hacia la izquierda
                const suctionLeft = woundLeft + suctionOffset;
                const suctionRight = woundRight + suctionOffset;
                
                if (body.position.x > suctionLeft - 50 && body.position.x < suctionRight + 50) {
                    const distanceToWound = Math.abs(body.position.y - 20);

                    if (body.position.x > suctionLeft && body.position.x < suctionRight && body.position.y < 250) {
                        // Direct suction upward
                        const suctionStrength = CONFIG.physics.suctionForce * (1 - distanceToWound / 230);
                        
                        // A√±adir componente horizontal hacia la izquierda
                        // M√°s fuerte cuanto m√°s arriba y m√°s a la izquierda est√© la part√≠cula
                        const normalizedY = (body.position.y - 20) / 230; // 0 = arriba, 1 = abajo
                        const normalizedX = (body.position.x - suctionLeft) / woundWidth; // 0 = izquierda, 1 = derecha
                        
                        // Componente horizontal hacia la izquierda (m√°s fuerte arriba y a la izquierda)
                        // Invertimos normalizedY y normalizedX para que sea m√°s fuerte arriba e izquierda
                        const horizontalSuction = (1 - normalizedY) * (1 - normalizedX) * CONFIG.physics.suctionForce * 0.3;
                        
                        Body.applyForce(body, body.position, {
                            x: -horizontalSuction * body.mass * timeScale, // Hacia la izquierda
                            y: -suctionStrength * body.mass * timeScale
                        });
                    }
                }

                // FIBRIN NET BOUNCE - Make RBCs and WBCs bounce off fibrin network
                if ((body.label === 'rbc' || body.label === 'wbc') && state.fibrinConstraints.length > 0) {
                    const cellRadius = body.label === 'rbc' ? 6 : 10;
                    const bounceThreshold = cellRadius + 6; // Increased detection threshold
                    const bounceStrength = body.label === 'rbc' ? 0.008 : 0.012; // Much stronger bounce force
                    const cellPos = body.position;
                    
                    // Only check fibrin near the wound area for performance
                    const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2 - 30;
                    const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2 + 30;
                    
                    if (cellPos.x >= woundLeft && cellPos.x <= woundRight && cellPos.y < 120) {
                        for (let i = 0; i < state.fibrinConstraints.length; i++) {
                            const fibrin = state.fibrinConstraints[i];
                            const pointA = fibrin.pointA.position;
                            const pointB = fibrin.pointB.position;
                            
                            if (!pointA || !pointB) continue;
                            
                            // Quick bounds check - skip if fibrin line is far from cell
                            const minX = Math.min(pointA.x, pointB.x);
                            const maxX = Math.max(pointA.x, pointB.x);
                            const minY = Math.min(pointA.y, pointB.y);
                            const maxY = Math.max(pointA.y, pointB.y);
                            
                            if (cellPos.x < minX - bounceThreshold || cellPos.x > maxX + bounceThreshold ||
                                cellPos.y < minY - bounceThreshold || cellPos.y > maxY + bounceThreshold) {
                                continue;
                            }
                            
                            // Calculate distance from cell to fibrin line segment
                            const lineVec = Vector.sub(pointB, pointA);
                            const lineLength = Vector.magnitude(lineVec);
                            
                            if (lineLength < 0.1) continue; // Skip very short lines
                            
                            const toCell = Vector.sub(cellPos, pointA);
                            const lineLengthSq = lineLength * lineLength;
                            const t = Math.max(0, Math.min(1, Vector.dot(toCell, lineVec) / lineLengthSq));
                            const closestPoint = Vector.add(pointA, Vector.mult(lineVec, t));
                            const distVec = Vector.sub(cellPos, closestPoint);
                            const distance = Vector.magnitude(distVec);
                            const bounceThresholdSq = bounceThreshold * bounceThreshold;
                            const distanceSq = distance * distance;
                            
                            // If cell is close to fibrin line, apply bounce force (or allow passage if weak)
                            if (distanceSq < bounceThresholdSq && distance > 0.1) {
                                // Get fibrin stability - affects barrier effectiveness
                                const fibrinStability = fibrin.stability || 1.0;
                                
                                // Si est√° sellado, bloquear completamente el paso
                                const passThroughChance = state.hemostasisAchieved ? 0 : (1 - fibrinStability) * 0.3; // Up to 30% chance for very weak fibrin
                                
                                if (Math.random() < passThroughChance) {
                                    // Cell passes through weak fibrin - reduce velocity slightly
                                    Body.setVelocity(body, {
                                        x: body.velocity.x * 0.9,
                                        y: body.velocity.y * 0.9
                                    });
                                    continue; // Skip bounce for this fibrin connection
                                }
                                
                                // Normalize distance vector to get bounce direction
                                const bounceDir = {
                                    x: distVec.x / distance,
                                    y: distVec.y / distance
                                };
                                
                                // Calculate velocity component towards the line
                                const velocityDot = body.velocity.x * bounceDir.x + body.velocity.y * bounceDir.y;
                                
                                // Only apply bounce if moving towards the line
                                if (velocityDot < 0) {
                                    // Bounce force reduced by stability - weaker fibrin = weaker bounce
                                    const proximityFactor = 1 - (distance / bounceThreshold);
                                    const stabilityMultiplier = 0.3 + (fibrinStability * 0.7); // 0.3-1.0 range
                                    const bounceForce = bounceStrength * proximityFactor * proximityFactor * stabilityMultiplier;
                                    
                                    // Scale bounce force by timestep for frame independence (use timeScale from function scope)
                                    Body.applyForce(body, body.position, {
                                        x: bounceDir.x * bounceForce * body.mass * 10 * timeScale,
                                        y: bounceDir.y * bounceForce * body.mass * 10 * timeScale
                                    });
                                    
                                    // Invert velocity component - effectiveness depends on stability
                                    const bounceFactor = (0.5 + fibrinStability * 0.3) + (proximityFactor * 0.2); // 0.5-1.0 range
                                    Body.setVelocity(body, {
                                        x: body.velocity.x - bounceDir.x * velocityDot * bounceFactor,
                                        y: body.velocity.y - bounceDir.y * velocityDot * bounceFactor
                                    });
                                    
                                    // Push cell away from the line - less effective for weak fibrin
                                    const pushDistance = (bounceThreshold - distance) * 0.3 * fibrinStability;
                                    Body.setPosition(body, {
                                        x: body.position.x + bounceDir.x * pushDistance,
                                        y: body.position.y + bounceDir.y * pushDistance
                                    });
                                }
                            }
                        }
                    }
                }

                // INVISIBLE ADHESION LINE - Check if platelet crosses the invisible line
                if (body.label === 'platelet' && !body.isStuck) {
                    const inWoundZone = body.position.x > woundLeft && body.position.x < woundRight;
                    const nearAdhesionLine = Math.abs(body.position.y - adhesionLineY) < adhesionLineThreshold;

                    if (inWoundZone && nearAdhesionLine) {
                        const conditionConfig = CONFIG.conditions[state.condition];
                        const canStick = state.treatmentApplied ? true : conditionConfig.canStick;
                        const stickProb = state.treatmentApplied ? 0.85 : conditionConfig.stickProbability * 0.4;

                        // Check platelet function first
                        if (!state.treatmentApplied && Math.random() > conditionConfig.plateletFunction) {
                            // Platelet dysfunction - let it pass through fibrin network instead of bouncing
                            // Reduce restitution to prevent bouncing and allow passage
                            body.restitution = 0;
                            Body.setVelocity(body, {
                                x: body.velocity.x * 0.95,
                                y: body.velocity.y * 0.95
                            });
                            return;
                        }
                        
                        const adhesionStrength = state.treatmentApplied ? 0.85 : conditionConfig.adhesionStrength * 0.4;
                        
                        if (canStick && Math.random() < adhesionStrength) {
                            // Stick to the invisible line
                            stickPlateletToLine(body, adhesionLineY, conditionConfig);
                        } else if (!state.treatmentApplied && conditionConfig.adhesionRetryChance) {
                            // Retry adhesion chance
                            setTimeout(() => {
                                if (!body.isStuck && Math.random() < conditionConfig.adhesionRetryChance) {
                                    if (canStick && Math.random() < adhesionStrength) {
                                        stickPlateletToLine(body, adhesionLineY, conditionConfig);
                                    }
                                }
                            }, 100);
                        } else {
                            // Las plaquetas que no se adhieren atraviesan la malla en lugar de rebotar
                            // Reducir restitution para evitar rebotes y permitir paso
                            body.restitution = 0;
                            Body.setVelocity(body, {
                                x: body.velocity.x * 0.95,
                                y: body.velocity.y * 0.95
                            });
                        }
                    }
                }
            });

            // For hemophilia and conditions with unstable fibrin - apply extra force to dislodge weakly attached platelets
            const conditionConfig = CONFIG.conditions[state.condition];
            if ((state.condition === 'hemophilia' || state.condition === 'hemophiliaSevere' || 
                 conditionConfig.fibrinStability < 0.5) && !state.treatmentApplied) {
                state.stuckPlatelets.forEach(platelet => {
                    if (!platelet.hasFibrin || platelet.fibrinConnections.length === 0) {
                        // Gradually increase dislodge force for platelets without fibrin support - scaled by timestep
                        const dislodgeForce = 0.00015 * (1 - conditionConfig.fibrinStability);
                        Body.applyForce(platelet.body, platelet.body.position, {
                            x: 0,
                            y: -dislodgeForce * platelet.body.mass * (1 + Math.random()) * timeScale
                        });
                    }
                });
            }
        }

        function stickPlateletToLine(platelet, lineY, conditionConfig) {
            if (platelet.isStuck) return;
            
            platelet.isStuck = true;
            
            // Apply visual effects based on condition
            const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
            platelet.render.fillStyle = visualEffects.plateletColor || '#808080';
            
            // Stop movement and position at the line
            Body.setVelocity(platelet, { x: 0, y: 0 });
            const stickY = lineY + 6;
            Body.setPosition(platelet, { x: platelet.position.x, y: stickY });
            
            // Make platelet completely static so it doesn't move
            Body.setStatic(platelet, true);
            
            // Create constraint to the line (static point) - maximum stiffness
            const constraint = Constraint.create({
                bodyA: platelet,
                pointB: { x: platelet.position.x, y: stickY },
                stiffness: 1.0, // Maximum stiffness
                damping: 1.0, // Maximum damping
                length: 0,
                render: { visible: false }
            });

            Composite.add(engine.world, constraint);

            const plateletData = {
                body: platelet,
                constraint: constraint,
                hasFibrin: false,
                fibrinConnections: [],
                condition: state.condition,
                stuckAt: Date.now(), // Timestamp para identificar las m√°s antiguas
                isAnchor: false
            };

            state.stuckPlatelets.push(plateletData);
            
            // Limitar el n√∫mero de plaquetas pegadas para mantener rendimiento
            cleanupOldStuckPlatelets();
            
            // Ocultar cartel cuando hay plaquetas pegadas
            const woundLabel = document.getElementById('wound-label');
            if (state.stuckPlatelets.length > 0) {
                woundLabel.classList.add('hidden');
            }

            // Secuencia: plaquetas primero, luego malla
            // Activar formaci√≥n de fibrina solo despu√©s de umbral de plaquetas
            const minPlateletsForFibrin = 3;
            if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
                state.fibrinFormationStarted = true;
                
                // Try to form fibrin after delay if specified
                const delay = conditionConfig.fibrinFormationDelay || 150;
                setTimeout(() => {
                    if (state.stuckPlatelets.includes(plateletData)) {
                        tryFormFibrin(plateletData);
                        
                        // Also try to form fibrin from nearby anchor platelets
                        state.stuckPlatelets.forEach(other => {
                            if (other.isAnchor && other.body) {
                                const dist = Vector.magnitude(Vector.sub(plateletData.body.position, other.body.position));
                                if (dist < 80) {
                                    tryFormFibrin(other);
                                }
                            }
                        });
                    }
                }, delay);
            }
        }

        function cleanupOldStuckPlatelets() {
            const maxStuckPlatelets = CONFIG.stuckPlatelets.maxCount;
            
            // Si no excedemos el l√≠mite, no hacer nada
            if (state.stuckPlatelets.length <= maxStuckPlatelets) {
                return;
            }
            
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const woundAreaMargin = 100; // Margen alrededor de la herida para considerar "relevante"
            
            // Ordenar plaquetas pegadas por timestamp (m√°s antiguas primero)
            // Pero excluir las anchor platelets y las que est√°n cerca de la herida
            const plateletsToConsider = state.stuckPlatelets
                .filter(p => !p.isAnchor) // No eliminar anchor platelets
                .map(p => ({
                    data: p,
                    distance: Math.abs(p.body.position.x - woundX),
                    isNearWound: p.body.position.x >= woundLeft - woundAreaMargin && 
                                p.body.position.x <= woundRight + woundAreaMargin &&
                                p.body.position.y >= 20 && p.body.position.y <= 100
                }))
                .sort((a, b) => {
                    // Priorizar eliminar las que est√°n lejos de la herida
                    if (a.isNearWound && !b.isNearWound) return 1;
                    if (!a.isNearWound && b.isNearWound) return -1;
                    // Si ambas est√°n cerca o lejos, ordenar por timestamp (m√°s antiguas primero)
                    return (a.data.stuckAt || 0) - (b.data.stuckAt || 0);
                });
            
            // Calcular cu√°ntas necesitamos eliminar
            const toRemove = state.stuckPlatelets.length - maxStuckPlatelets;
            
            // Eliminar las m√°s antiguas que est√°n lejos de la herida
            for (let i = 0; i < toRemove && i < plateletsToConsider.length; i++) {
                const plateletData = plateletsToConsider[i].data;
                
                // Eliminar constraints de fibrina conectados
                for (let j = state.fibrinConstraints.length - 1; j >= 0; j--) {
                    const fibrin = state.fibrinConstraints[j];
                    if (fibrin.pointA === plateletData.body || fibrin.pointB === plateletData.body) {
                        removeFibrinConnection(fibrin);
                    }
                }
                
                // Eliminar constraint de la plaqueta
                if (plateletData.constraint) {
                    Composite.remove(engine.world, plateletData.constraint);
                }
                
                // Eliminar el body
                Composite.remove(engine.world, plateletData.body);
                
                // Eliminar de la lista
                const index = state.stuckPlatelets.indexOf(plateletData);
                if (index > -1) {
                    state.stuckPlatelets.splice(index, 1);
                }
                
                // Eliminar de allBodies
                const bodyIndex = state.allBodies.indexOf(plateletData.body);
                if (bodyIndex > -1) {
                    state.allBodies.splice(bodyIndex, 1);
                }
            }
        }

        function cleanupParticles() {
            const toRemove = [];
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;

            // Optimized cleanup: iterate backwards for better performance when removing
            for (let i = state.allBodies.length - 1; i >= 0; i--) {
                const body = state.allBodies[i];
                const px = body.position.x;
                const py = body.position.y;
                
                // Solo eliminar part√≠culas m√≥viles (no pegadas) en la limpieza b√°sica
                const isStuck = state.stuckPlatelets.some(p => p.body === body);
                
                if (!isStuck) {
                    // Remove particles that exit right (eliminar cuando salen completamente del canvas)
                    if (px > CONFIG.canvas.width + 20) {
                        toRemove.push(body);
                    }
                    // Remove particles that exit top (blood loss)
                    else if (py < -20) {
                        toRemove.push(body);
                        state.bloodLoss++;
                    }
                    // Remove particles that exit through the wound (upward)
                    else if (py < 10 && px >= woundLeft - 5 && px <= woundRight + 5) {
                        toRemove.push(body);
                        state.bloodLoss++;
                    }
                    // Remove particles way off screen (bottom or left)
                    else if (py > CONFIG.canvas.height + 20 || px < -30) {
                        toRemove.push(body);
                    }
                }
            }

            // Optimized removal: use Map for faster lookups
            const bodySet = new Set(toRemove);
            
            toRemove.forEach(body => {
                // Remove associated constraints if it's a stuck platelet
                const plateletIndex = state.stuckPlatelets.findIndex(p => p.body === body);
                if (plateletIndex !== -1) {
                    const plateletData = state.stuckPlatelets[plateletIndex];
                    
                    // Remove fibrin constraints connected to this platelet (iterate backwards)
                    for (let i = state.fibrinConstraints.length - 1; i >= 0; i--) {
                        const fibrin = state.fibrinConstraints[i];
                        if (fibrin.pointA === body || fibrin.pointB === body) {
                            removeFibrinConnection(fibrin);
                        }
                    }
                    
                    // Remove platelet constraint
                    if (plateletData.constraint) {
                        Composite.remove(engine.world, plateletData.constraint);
                    }
                    
                    // Remove from stuck platelets list (but not anchor platelets)
                    if (!plateletData.isAnchor) {
                        state.stuckPlatelets.splice(plateletIndex, 1);
                    }
                }
                
                Composite.remove(engine.world, body);
            });
            
            // Remove from allBodies array (more efficient)
            state.allBodies = state.allBodies.filter(b => !bodySet.has(b));
            
            // Limpieza agresiva: eliminar part√≠culas que est√°n cerca del borde derecho
            // Esto asegura que las part√≠culas se eliminen antes de llegar al l√≠mite m√°ximo
            const aggressiveCleanupThreshold = CONFIG.particles.maxCount * 0.7; // 70% del l√≠mite (105 part√≠culas)
            if (state.allBodies.length > aggressiveCleanupThreshold) {
                const additionalToRemove = [];
                
                for (let i = state.allBodies.length - 1; i >= 0; i--) {
                    const body = state.allBodies[i];
                    if (!body || !body.position) continue;
                    
                    const px = body.position.x;
                    const py = body.position.y;
                    
                    // Solo eliminar part√≠culas m√≥viles (no pegadas)
                    const isStuck = state.stuckPlatelets.some(p => p.body === body);
                    if (isStuck) continue;
                    
                    // Eliminar part√≠culas que est√°n muy cerca del borde derecho (dentro de 30px del final)
                    if (px > CONFIG.canvas.width - 30) {
                        additionalToRemove.push(body);
                    }
                    // Tambi√©n eliminar part√≠culas que est√°n muy abajo (fuera de la vista √∫til)
                    else if (py > CONFIG.canvas.height - 10) {
                        additionalToRemove.push(body);
                    }
                }
                
                // Eliminar las part√≠culas adicionales encontradas
                additionalToRemove.forEach(body => {
                    try {
                        Composite.remove(engine.world, body);
                        const index = state.allBodies.indexOf(body);
                        if (index > -1) {
                            state.allBodies.splice(index, 1);
                        }
                    } catch (e) {
                        // Ignorar errores si el body ya fue eliminado
                    }
                });
            }
        }

        function setupCollisionEvents() {
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    
                    // Check for platelet collision with wound edges or stuck platelets
                    handlePlateletCollision(bodyA, bodyB);
                    handlePlateletCollision(bodyB, bodyA);
                    
                    // Handle weak fibrin barrier collisions - allow occasional passage
                    handleFibrinBarrierCollision(bodyA, bodyB);
                    handleFibrinBarrierCollision(bodyB, bodyA);
                });
            });
        }
        
        function handleFibrinBarrierCollision(cell, barrier) {
            // Check if cell (RBC/WBC) collides with fibrin barrier
            if ((cell.label !== 'rbc' && cell.label !== 'wbc') || barrier.label !== 'fibrinBarrier') {
                return;
            }
            
            // Get fibrin stability from barrier
            const fibrinStability = barrier.fibrinStability || 1.0;
            
            // Si est√° sellado, bloquear completamente el paso
            if (state.hemostasisAchieved) {
                return; // No permitir paso cuando est√° sellado
            }
            
            // Weak fibrin occasionally allows cells to pass through
            if (fibrinStability < 0.6) {
                const passThroughChance = (1 - fibrinStability) * 0.4; // Up to 40% chance for very weak fibrin
                
                if (Math.random() < passThroughChance) {
                    // Allow cell to pass through - make barrier temporarily non-collidable
                    barrier.collisionFilter.mask = 0x0000; // No collisions
                    
                    // Restore collision after a short time
                    setTimeout(() => {
                        if (barrier.label === 'fibrinBarrier') {
                            barrier.collisionFilter.mask = 0x0001;
                        }
                    }, 500);
                    
                    // Reduce cell velocity slightly as it passes through
                    Body.setVelocity(cell, {
                        x: cell.velocity.x * 0.85,
                        y: cell.velocity.y * 0.85
                    });
                } else {
                    // Reduce bounce effectiveness for weak fibrin
                    const bounceReduction = 1 - fibrinStability;
                    Body.setVelocity(cell, {
                        x: cell.velocity.x * (1 - bounceReduction * 0.3),
                        y: cell.velocity.y * (1 - bounceReduction * 0.3)
                    });
                }
            }
        }

        function handlePlateletCollision(platelet, other) {
            if (platelet.label !== 'platelet' || platelet.isStuck) return;

            const conditionConfig = CONFIG.conditions[state.condition];
            
            // Check platelet function first
            if (!state.treatmentApplied && Math.random() > conditionConfig.plateletFunction) {
                // Platelet dysfunction - let it pass through instead of bouncing
                // Reduce restitution to prevent bouncing and allow passage
                platelet.restitution = 0;
                Body.setVelocity(platelet, {
                    x: platelet.velocity.x * 0.95,
                    y: platelet.velocity.y * 0.95
                });
                return;
            }

            const canStick = state.treatmentApplied ? true : conditionConfig.canStick;
            const adhesionStrength = state.treatmentApplied ? 0.95 : conditionConfig.adhesionStrength;

            // Check if collision is with wound edge or stuck platelet
            const isWoundEdge = other.label === 'woundEdge';
            const isStuckPlatelet = other.label === 'platelet' && other.isStuck;

            if (isWoundEdge || isStuckPlatelet) {
                // Check if in wound zone
                const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
                const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;
                
                if (platelet.position.x >= woundLeft - 20 && platelet.position.x <= woundRight + 20 && platelet.position.y < 45) {
                    // Check aggregation rate for platelet-to-platelet adhesion
                    // En vWD sin tratamiento, las plaquetas no se agregan (no hay cemento vWF)
                    if (isStuckPlatelet) {
                        const aggregationRate = state.treatmentApplied ? 0.9 : conditionConfig.aggregationRate;
                        if (Math.random() > aggregationRate) {
                            // Failed aggregation - plaquetas rebotan/se separan (sin cemento vWF)
                            platelet.restitution = 0.9;
                            // En vWD, rebote m√°s fuerte para simular que no hay cemento
                            const bounceStrength = (state.condition === 'vwd' && !state.treatmentApplied) ? 1.5 : 1.0;
                            Body.setVelocity(platelet, {
                                x: platelet.velocity.x * (0.8 * bounceStrength),
                                y: Math.abs(platelet.velocity.y) * (1.2 * bounceStrength) + 1
                            });
                            return;
                        }
                    }
                    
                    if (canStick && Math.random() < adhesionStrength) {
                        stickPlatelet(platelet, other, conditionConfig);
                    } else if (!state.treatmentApplied && conditionConfig.adhesionRetryChance) {
                        // Retry adhesion chance
                        setTimeout(() => {
                            if (!platelet.isStuck && Math.random() < conditionConfig.adhesionRetryChance) {
                                if (canStick && Math.random() < adhesionStrength) {
                                    stickPlatelet(platelet, other, conditionConfig);
                                }
                            }
                        }, 100);
                    } else {
                        // Las plaquetas que no se adhieren atraviesan en lugar de rebotar
                        // Reducir restitution para evitar rebotes y permitir paso
                        platelet.restitution = 0;
                        Body.setVelocity(platelet, {
                            x: platelet.velocity.x * 0.95,
                            y: platelet.velocity.y * 0.95
                        });
                    }
                }
            }
        }

        function stickPlatelet(platelet, anchor, conditionConfig) {
            if (platelet.isStuck) return;
            
            platelet.isStuck = true;
            
            // Apply visual effects based on condition
            const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
            platelet.render.fillStyle = visualEffects.plateletColor || '#808080';
            
            // Stop movement completely
            Body.setVelocity(platelet, { x: 0, y: 0 });
            
            // Make platelet completely static so it doesn't move
            Body.setStatic(platelet, true);
            
            // Create constraint to anchor point - maximum stiffness
            const constraint = Constraint.create({
                bodyA: platelet,
                pointB: anchor.isStatic ? { x: anchor.position.x, y: anchor.position.y } : null,
                bodyB: anchor.isStatic ? null : anchor,
                stiffness: 1.0, // Maximum stiffness
                damping: 1.0, // Maximum damping
                length: 0,
                render: { visible: false }
            });

            Composite.add(engine.world, constraint);

            const plateletData = {
                body: platelet,
                constraint: constraint,
                hasFibrin: false,
                fibrinConnections: [],
                condition: state.condition,
                stuckAt: Date.now(), // Timestamp para identificar las m√°s antiguas
                isAnchor: false
            };

            state.stuckPlatelets.push(plateletData);
            
            // Limitar el n√∫mero de plaquetas pegadas para mantener rendimiento
            cleanupOldStuckPlatelets();
            
            // Ocultar cartel cuando hay plaquetas pegadas
            const woundLabel = document.getElementById('wound-label');
            if (state.stuckPlatelets.length > 0) {
                woundLabel.classList.add('hidden');
            }

            // Secuencia: plaquetas primero, luego malla
            // Activar formaci√≥n de fibrina solo despu√©s de umbral de plaquetas
            const minPlateletsForFibrin = 3;
            if (state.stuckPlatelets.length >= minPlateletsForFibrin) {
                state.fibrinFormationStarted = true;
                
                // Try to form fibrin with delay if specified
                const delay = conditionConfig.fibrinFormationDelay || 100;
                setTimeout(() => {
                    if (state.stuckPlatelets.includes(plateletData)) {
                        tryFormFibrin(plateletData);
                    }
                }, delay);
            }
        }

        function tryFormFibrin(plateletData) {
            const conditionConfig = CONFIG.conditions[state.condition];
            const canFormFibrin = state.treatmentApplied ? true : conditionConfig.canFormFibrin;

            if (!canFormFibrin) return;
            
            // Secuencia: plaquetas primero, luego malla - solo formar si ya empez√≥ la formaci√≥n
            if (!state.fibrinFormationStarted) return;
            
            // Check fibrin formation rate
            const fibrinFormationRate = state.treatmentApplied ? 1.0 : conditionConfig.fibrinFormationRate;
            if (Math.random() > fibrinFormationRate) {
                return; // Failed to form fibrin this time
            }
            
            // Limit total fibrin connections
            if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections) return;
            
            // Limit connections per platelet
            if (plateletData.fibrinConnections.length >= CONFIG.fibrin.maxConnectionsPerPlatelet) return;
            
            // Check max cluster size for thrombasthenia
            if (conditionConfig.maxPlateletClusterSize) {
                const nearbyCount = state.stuckPlatelets.filter(p => {
                    const dx = p.body.position.x - plateletData.body.position.x;
                    const dy = p.body.position.y - plateletData.body.position.y;
                    return (dx * dx + dy * dy) < 400 && p.fibrinConnections.length > 0;
                }).length;
                if (nearbyCount >= conditionConfig.maxPlateletClusterSize) {
                    return; // Cannot form larger clusters
                }
            }

            const platelet = plateletData.body;
            
            // Get fibrin stability from condition - affects connection distance
            const fibrinStability = state.treatmentApplied ? 1.0 : conditionConfig.fibrinStability;
            
            // When fibrin is weaker, platelets must be closer to form connections
            // Strong fibrin (1.0): can connect up to 90px away, minimum 20px
            // Weak fibrin (0.3): can connect up to 40px away, minimum 8px
            const maxSearchRadius = 40 + (fibrinStability * 50); // 40-90px range
            const minDistance = 8 + (fibrinStability * 12); // 8-20px range
            const minDistanceSq = minDistance * minDistance;
            
            const plateletX = platelet.position.x;
            const plateletY = platelet.position.y;

            // Find nearby stuck platelets (optimized with early exit)
            for (let i = 0; i < state.stuckPlatelets.length; i++) {
                const other = state.stuckPlatelets[i];
                if (other.body === platelet) continue;
                if (plateletData.fibrinConnections.includes(other.body.id)) continue;
                
                // Limit connections per other platelet too
                if (other.fibrinConnections.length >= CONFIG.fibrin.maxConnectionsPerPlatelet) continue;

                // Quick distance check using squared distance (avoid sqrt)
                const dx = other.body.position.x - plateletX;
                const dy = other.body.position.y - plateletY;
                const distSq = dx * dx + dy * dy;
                const searchRadiusSq = maxSearchRadius * maxSearchRadius;

                if (distSq < searchRadiusSq && distSq > minDistanceSq) {
                    const dist = Math.sqrt(distSq);
                    
                    // Clasificar tipo de cuerda seg√∫n distancia y estabilidad
                    let fibrinType = 'thin'; // Por defecto peque√±a
                    if (dist < 30 && fibrinStability > 0.7) {
                        fibrinType = 'thick'; // Gruesa: distancia < 30px y estabilidad alta
                    } else if (dist < 60 && fibrinStability > 0.4) {
                        fibrinType = 'medium'; // Mediana: distancia 30-60px y estabilidad media
                    }
                    
                    // Verificar restricciones seg√∫n condici√≥n
                    const canFormThick = !conditionConfig.blockThickCords;
                    const canFormMedium = !conditionConfig.blockMediumCords;
                    const canFormThin = !conditionConfig.blockThinCords;
                    
                    if ((fibrinType === 'thick' && !canFormThick) ||
                        (fibrinType === 'medium' && !canFormMedium) ||
                        (fibrinType === 'thin' && !canFormThin)) {
                        continue; // Saltar esta conexi√≥n si est√° bloqueada
                    }
                    
                    const visualEffects = conditionConfig.visualEffects || CONFIG.conditions.normal.visualEffects;
                    
                    // Create fibrin constraint with stability-based properties
                    const fibrinConstraint = Constraint.create({
                        bodyA: platelet,
                        bodyB: other.body,
                        stiffness: 0.9 * fibrinStability,
                        damping: 0.3 * (2 - fibrinStability),
                        length: dist * 0.8,
                        render: { visible: false }
                    });

                    Composite.add(engine.world, fibrinConstraint);

                    // Create physical body for fibrin barrier (thin rectangle)
                    const midX = (platelet.position.x + other.body.position.x) / 2;
                    const midY = (platelet.position.y + other.body.position.y) / 2;
                    const angle = Math.atan2(
                        other.body.position.y - platelet.position.y,
                        other.body.position.x - platelet.position.x
                    );
                    
                    // Create a thin rectangular body as barrier
                    // Thickness depends on stability - weaker fibrin = thinner barrier
                    const barrierThickness = 2 + (fibrinStability * 3); // 2-5px range
                    const fibrinBody = Bodies.rectangle(midX, midY, dist, barrierThickness, {
                        isStatic: true, // Static so it acts as a solid barrier
                        render: { 
                            fillStyle: 'transparent', // Invisible, we render it separately
                            visible: false
                        },
                        label: 'fibrinBarrier',
                        restitution: 0.9 * fibrinStability, // Stability affects bounce
                        friction: 0.1,
                        collisionFilter: {
                            group: 0,
                            category: 0x0002, // Separate category for fibrin
                            mask: 0x0001 // Only collide with RBCs and WBCs
                        },
                        // Store stability for collision handling
                        fibrinStability: fibrinStability
                    });
                    
                    Body.setAngle(fibrinBody, angle);
                    Composite.add(engine.world, fibrinBody);

                    const fibrinData = {
                        constraint: fibrinConstraint,
                        pointA: platelet,
                        pointB: other.body,
                        body: fibrinBody,
                        glowing: state.treatmentApplied,
                        stability: fibrinStability,
                        decayRate: conditionConfig.fibrinDecayRate || 0,
                        visualColor: '#FFFFFF', // Blanco para las cuerdas (solo la malla horizontal es morada)
                        opacity: visualEffects.fibrinOpacity || 1.0,
                        fibrinType: fibrinType, // 'thick', 'medium', o 'thin'
                        createdAt: Date.now()
                    };
                    
                    state.fibrinConstraints.push(fibrinData);
                    state.fibrinBodies.push(fibrinBody);

                    plateletData.fibrinConnections.push(other.body.id);
                    plateletData.hasFibrin = true;
                    other.fibrinConnections.push(platelet.id);
                    other.hasFibrin = true;
                    
                    // Schedule fibrin decay if condition has decay rate
                    if (conditionConfig.fibrinDecayRate > 0 && !state.treatmentApplied) {
                        scheduleFibrinDecay(fibrinData, conditionConfig.fibrinDecayRate);
                    }
                    
                    // Stop if we've reached the limit
                    if (state.fibrinConstraints.length >= CONFIG.fibrin.maxConnections) break;
                }
            }
            
            // Check if wound is sealed after forming new fibrin connection
            checkWoundSealed();
        }
        
        function scheduleFibrinDecay(fibrinData, decayRate) {
            // Decay fibrin over time based on decay rate
            const decayInterval = setInterval(() => {
                if (!state.fibrinConstraints.includes(fibrinData)) {
                    clearInterval(decayInterval);
                    return;
                }
                
                // Reduce stability over time
                fibrinData.stability -= decayRate * 0.1;
                
                if (fibrinData.stability <= 0.1 || Math.random() < decayRate) {
                    // Remove unstable fibrin
                    removeFibrinConnection(fibrinData);
                    clearInterval(decayInterval);
                } else {
                    // Update constraint properties based on stability
                    fibrinData.constraint.stiffness = 0.9 * fibrinData.stability;
                    fibrinData.constraint.damping = 0.3 * (2 - fibrinData.stability);
                }
            }, 2000); // Check every 2 seconds
        }
        
        function removeFibrinConnection(fibrinData) {
            // Remove from world
            Composite.remove(engine.world, fibrinData.constraint);
            if (fibrinData.body) {
                Composite.remove(engine.world, fibrinData.body);
                state.fibrinBodies = state.fibrinBodies.filter(b => b !== fibrinData.body);
            }
            
            // Remove from arrays
            state.fibrinConstraints = state.fibrinConstraints.filter(f => f !== fibrinData);
            
            // Update platelet connections
            const plateletA = state.stuckPlatelets.find(p => p.body === fibrinData.pointA);
            const plateletB = state.stuckPlatelets.find(p => p.body === fibrinData.pointB);
            
            if (plateletA) {
                plateletA.fibrinConnections = plateletA.fibrinConnections.filter(id => id !== fibrinData.pointB.id);
                plateletA.hasFibrin = plateletA.fibrinConnections.length > 0;
            }
            if (plateletB) {
                plateletB.fibrinConnections = plateletB.fibrinConnections.filter(id => id !== fibrinData.pointA.id);
                plateletB.hasFibrin = plateletB.fibrinConnections.length > 0;
            }
        }
        
        function checkWoundSealed() {
            if (state.hemostasisAchieved) return; // Already sealed
            
            const conditionConfig = CONFIG.conditions[state.condition];
            // En condiciones patol√≥gicas, requerir tratamiento para sellado completo
            if (conditionConfig.requiresTreatment && !state.treatmentApplied) {
                return; // No sellar sin tratamiento
            }
            
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const woundCenterY = 29; // Y position where platelets stick
            
            // Find platelets on the left side of the wound (including anchor platelets)
            const leftSidePlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                // Include anchor platelets or platelets near left edge
                return (p.isAnchor && px < woundLeft) || (px < woundLeft + 30 && Math.abs(py - woundCenterY) < 20);
            });
            
            // Find platelets on the right side of the wound (including anchor platelets)
            const rightSidePlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                // Include anchor platelets or platelets near right edge
                return (p.isAnchor && px > woundRight) || (px > woundRight - 30 && Math.abs(py - woundCenterY) < 20);
            });
            
            if (leftSidePlatelets.length === 0 || rightSidePlatelets.length === 0) {
                return; // Need platelets on both sides
            }
            
            // Check if there's a path from left to right through fibrin connections
            for (let i = 0; i < leftSidePlatelets.length; i++) {
                const leftPlatelet = leftSidePlatelets[i];
                if (hasPathToRight(leftPlatelet, rightSidePlatelets, new Set())) {
                    // Wound is sealed!
                    state.hemostasisAchieved = true;
                    state.clotPercentage = 100;
                    document.getElementById('hemostasis-indicator').classList.add('visible');
                    const woundLabel = document.getElementById('wound-label');
                    woundLabel.classList.add('healed', 'hidden'); // Ocultar cuando est√° sellada
                    woundLabel.innerHTML = '‚úì Lesi√≥n Sellada';
                    updateUI();
                    return;
                }
            }
        }
        
        function hasPathToRight(currentPlatelet, rightSidePlatelets, visited) {
            // Check if current platelet is on the right side
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundRight = CONFIG.wound.x + CONFIG.wound.width / 2;
            
            if (currentPlatelet.body.position.x > woundRight - 20) {
                return true; // Reached right side
            }
            
            // Mark as visited
            visited.add(currentPlatelet.body.id);
            
            // Check all fibrin connections from this platelet
            for (let i = 0; i < state.fibrinConstraints.length; i++) {
                const fibrin = state.fibrinConstraints[i];
                let connectedPlatelet = null;
                
                // Find which platelet is connected to current one
                if (fibrin.pointA === currentPlatelet.body) {
                    connectedPlatelet = state.stuckPlatelets.find(p => p.body === fibrin.pointB);
                } else if (fibrin.pointB === currentPlatelet.body) {
                    connectedPlatelet = state.stuckPlatelets.find(p => p.body === fibrin.pointA);
                }
                
                if (connectedPlatelet && !visited.has(connectedPlatelet.body.id)) {
                    // Check if this connection crosses the wound area
                    const px1 = currentPlatelet.body.position.x;
                    const px2 = connectedPlatelet.body.position.x;
                    const woundLeft = woundX - woundWidth / 2;
                    const woundRight = woundX + woundWidth / 2;
                    
                    // Connection crosses wound if one point is left and other is right
                    if ((px1 < woundLeft && px2 > woundRight) || (px2 < woundLeft && px1 > woundRight)) {
                        // Direct crossing found
                        return true;
                    }
                    
                    // Continue searching through this connection
                    if (hasPathToRight(connectedPlatelet, rightSidePlatelets, visited)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function renderFibrin(event) {
            const ctx = render.context;
            const woundX = CONFIG.wound.x;
            const woundWidth = CONFIG.wound.width;
            const woundLeft = woundX - woundWidth / 2;
            const woundRight = woundX + woundWidth / 2;
            const woundCenterY = 29; // Y position where platelets stick
            
            // Render ointment layer when treatment is applied - ultra simple for performance
            if (state.showOintment) {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.35)';
                ctx.fillRect(woundLeft, 0, woundWidth, 32);
            }
            
            // Calcular opacidad de la malla morada basada en densidad de plaquetas pegadas
            const stuckPlateletsInWound = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                return px >= woundLeft - 20 && px <= woundRight + 20 && 
                       py >= woundCenterY - 15 && py <= woundCenterY + 15;
            }).length;
            
            const maxPlatelets = 20; // M√°ximo esperado de plaquetas en la herida
            // La malla morada empieza muy transparente (0.05) y se opaca progresivamente hasta 0.9
            const meshOpacity = Math.min(0.9, 0.05 + (stuckPlateletsInWound / maxPlatelets) * 0.85);
            
            // Ajustar posici√≥n Y de la malla morada para que est√© m√°s abajo
            const meshY = woundCenterY - 2;
            
            // Renderizar malla morada horizontal en la zona de la herida que se opaca progresivamente
            // Solo esta l√≠nea horizontal es morada - las cuerdas son blancas
            if (state.fibrinFormationStarted && stuckPlateletsInWound > 0) {
                ctx.fillStyle = `rgba(157, 78, 221, ${meshOpacity})`; // Morado #9D4EDD
                ctx.fillRect(woundLeft, meshY, woundWidth, 4);
            }
            
            // Overlay verde cuando est√° sellada
            if (state.hemostasisAchieved) {
                ctx.fillStyle = 'rgba(34, 197, 94, 0.3)'; // Verde semitransparente
                ctx.fillRect(woundLeft, meshY - 3, woundWidth, 10);
            }
            
            // Render fibrin connections (cuerdas) - optimized for performance
            if (state.fibrinConstraints.length > 0) {
                ctx.save(); // Guardar estado del contexto antes de dibujar cuerdas verdes
                
                for (let i = 0; i < state.fibrinConstraints.length; i++) {
                    const fibrin = state.fibrinConstraints[i];
                    const pointA = fibrin.pointA.position;
                    const pointB = fibrin.pointB.position;
                    
                    // Only draw if both points are still valid
                    if (pointA && pointB) {
                        const fibrinType = fibrin.fibrinType || 'thin';
                        let lineWidth, opacity;
                        
                        // Configurar grosor y opacidad seg√∫n tipo de cuerda
                        switch (fibrinType) {
                            case 'thick':
                                lineWidth = 5;
                                opacity = 0.9;
                                break;
                            case 'medium':
                                lineWidth = 3;
                                opacity = 0.6;
                                break;
                            case 'thin':
                            default:
                                lineWidth = 1.5;
                                opacity = 0.4;
                                break;
                        }
                        
                        // Ajustar opacidad seg√∫n estabilidad
                        opacity *= (fibrin.stability || 1.0);
                        
                        // Color verde para las cuerdas (solo la malla horizontal es morada)
                        ctx.strokeStyle = `rgba(34, 197, 94, ${opacity * 0.8})`; // Verde #22C55E con opacidad
                        ctx.lineWidth = lineWidth;
                        
                        ctx.beginPath();
                        ctx.moveTo(pointA.x, pointA.y);
                        ctx.lineTo(pointB.x, pointB.y);
                        ctx.stroke();
                    }
                }
                
                ctx.restore(); // Restaurar estado del contexto despu√©s de dibujar cuerdas blancas
            }
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 230, b: 118 };
        }
        
        function renderVWF(event) {
            const ctx = render.context;
            
            // Verificar si debe mostrar vWF (cemento entre plaquetas)
            const conditionConfig = CONFIG.conditions[state.condition];
            const shouldShowVWF = state.condition === 'normal' || state.treatmentApplied || 
                                  (state.condition === 'vwd' && state.treatmentApplied);
            
            if (!shouldShowVWF || state.stuckPlatelets.length < 2) {
                return; // No mostrar vWF si no hay vWF o menos de 2 plaquetas
            }
            
            // Dibujar l√≠neas verdes cortas (cemento) entre plaquetas pegadas que est√°n cerca
            const maxVWFDistance = 12; // Distancia m√°xima para mostrar conexi√≥n vWF
            const maxVWFDistanceSq = maxVWFDistance * maxVWFDistance;
            
            // Asegurar que el color verde se aplique correctamente
            ctx.save(); // Guardar estado del contexto
            
            // Usar rgba para asegurar que el color verde se aplique correctamente
            ctx.strokeStyle = 'rgba(34, 197, 94, 1.0)'; // Verde #22C55E en formato rgba
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.globalAlpha = 1.0; // Asegurar opacidad completa para el verde
            
            // Dibujar l√≠neas entre plaquetas cercanas
            for (let i = 0; i < state.stuckPlatelets.length; i++) {
                const plateletA = state.stuckPlatelets[i];
                if (!plateletA.body) continue;
                
                const posA = plateletA.body.position;
                
                for (let j = i + 1; j < state.stuckPlatelets.length; j++) {
                    const plateletB = state.stuckPlatelets[j];
                    if (!plateletB.body) continue;
                    
                    const posB = plateletB.body.position;
                    const dx = posB.x - posA.x;
                    const dy = posB.y - posA.y;
                    const distSq = dx * dx + dy * dy;
                    
                    // Solo dibujar si est√°n cerca (como cemento entre piedras adyacentes)
                    if (distSq < maxVWFDistanceSq && distSq > 4) {
                        const dist = Math.sqrt(distSq);
                        // Opacidad basada en distancia (m√°s opaco cuanto m√°s cerca)
                        const opacity = 0.7 + (1.0 - dist / maxVWFDistance) * 0.3; // Entre 0.7 y 1.0
                        
                        // Re-establecer el color verde antes de cada l√≠nea para asegurar que siempre sea verde
                        ctx.strokeStyle = `rgba(34, 197, 94, ${opacity})`; // Verde con opacidad variable
                        ctx.beginPath();
                        ctx.moveTo(posA.x, posA.y);
                        ctx.lineTo(posB.x, posB.y);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.restore(); // Restaurar estado del contexto
        }
        
        function renderParticlesCustom(event) {
            const ctx = render.context;
            
            // Renderizar todas las part√≠culas con estilo personalizado (highlights, sombras, formas)
            // Renderizar solo plaquetas, gl√≥bulos rojos y gl√≥bulos blancos
            state.allBodies.forEach(body => {
                if (!body.label || (body.label !== 'platelet' && body.label !== 'rbc' && body.label !== 'wbc')) return;
                
                const x = body.position.x;
                const y = body.position.y;
                const angle = body.angle;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                if (body.label === 'rbc') {
                    // Gl√≥bulo rojo: ovalado con highlight y sombra
                    const radiusX = 6;
                    const radiusY = 4.5; // M√°s ancho que alto para efecto ovalado
                    
                    // Sombra/contorno oscuro
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radiusX + 0.5, radiusY + 0.5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(139, 0, 0, 0.3)'; // Rojo muy oscuro para sombra
                    ctx.fill();
                    
                    // Cuerpo principal rojo oscuro
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#B91C1C'; // Rojo oscuro
                    ctx.fill();
                    
                    // Highlight peque√±o cerca del centro (superior izquierda)
                    ctx.beginPath();
                    ctx.arc(-1.5, -1, 1.2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 200, 200, 0.8)'; // Rojo claro/rosa para highlight
                    ctx.fill();
                    
                } else if (body.label === 'wbc') {
                    // Gl√≥bulo blanco: circular con highlight brillante y contorno azul oscuro
                    const radius = 10;
                    
                    // Contorno azul oscuro para profundidad
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 1, 0, Math.PI * 2);
                    ctx.strokeStyle = '#4A90E2'; // Azul m√°s oscuro para contorno
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Cuerpo principal azul claro
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#87CEEB'; // Azul claro
                    ctx.fill();
                    
                    // Highlight brillante blanco en cuadrante superior izquierdo
                    const gradient = ctx.createRadialGradient(-3, -3, 0, -3, -3, 4);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)'); // Blanco brillante en el centro
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); // Transparente hacia afuera
                    
                    ctx.beginPath();
                    ctx.arc(-3, -3, 4, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Punto de highlight m√°s peque√±o y brillante
                    ctx.beginPath();
                    ctx.arc(-3, -3, 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)'; // Blanco s√≥lido
                    ctx.fill();
                    
                } else if (body.label === 'platelet') {
                    // Plaqueta: circular gris con highlight sutil
                    const radius = 4;
                    
                    // Sombra sutil
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.2)'; // Gris oscuro para sombra
                    ctx.fill();
                    
                    // Cuerpo principal gris
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#808080'; // Gris medio
                    ctx.fill();
                    
                    // Highlight peque√±o en cuadrante superior izquierdo
                    ctx.beginPath();
                    ctx.arc(-1.2, -1.2, 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(220, 220, 220, 0.7)'; // Gris claro para highlight
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function calculateClotPercentage() {
            // Si la herida est√° sellada (red de fibrina de izquierda a derecha y no pasan part√≠culas), 100%
            if (state.hemostasisAchieved) {
                state.clotPercentage = 100;
                return;
            }
            
            const woundLeft = CONFIG.wound.x - CONFIG.wound.width / 2;
            const woundWidth = CONFIG.wound.width;
            const woundCenterY = 29; // Y position where platelets stick

            // Optimized coverage calculation
            const segments = 20; // Reduced from 30 for better performance
            const segmentWidth = woundWidth / segments;
            let coveredSegments = 0;
            const coverageThreshold = 15 * 15; // Squared distance for comparison

            // Pre-filter platelets that are actually in the wound area
            const relevantPlatelets = state.stuckPlatelets.filter(p => {
                const px = p.body.position.x;
                const py = p.body.position.y;
                return px >= woundLeft - 20 && px <= woundLeft + woundWidth + 20 && 
                       py >= woundCenterY - 15 && py <= woundCenterY + 15;
            });

            for (let i = 0; i < segments; i++) {
                const segmentX = woundLeft + (i + 0.5) * segmentWidth;
                
                // Check if any stuck platelet covers this segment (optimized)
                const covered = relevantPlatelets.some(p => {
                    const dx = p.body.position.x - segmentX;
                    const dy = p.body.position.y - woundCenterY;
                    return (dx * dx + dy * dy) < coverageThreshold;
                });

                if (covered) coveredSegments++;
            }

            state.clotPercentage = Math.min(100, Math.round((coveredSegments / segments) * 100));

            // Check if wound is sealed by fibrin network crossing left to right
            // Esto detecta cuando la red de fibrina va de izquierda a derecha
            checkWoundSealed();
            
            // Si est√° sellada, asegurar que el porcentaje sea 100%
            if (state.hemostasisAchieved) {
                state.clotPercentage = 100;
            }
        }

        function updateUI() {
            document.getElementById('blood-loss').textContent = state.bloodLoss;
            document.getElementById('clot-percentage').textContent = state.clotPercentage + '%';
            document.getElementById('clot-bar').style.width = state.clotPercentage + '%';

            // Status indicator
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            if (state.hemostasisAchieved) {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Hemostasia lograda';
            } else if (state.treatmentApplied) {
                statusDot.className = 'status-dot treated';
                statusText.textContent = 'Tratamiento activo';
            } else if (state.bloodLoss > 20) {
                statusDot.className = 'status-dot bleeding';
                statusText.textContent = 'Sangrado activo';
            } else {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Simulaci√≥n activa';
            }
        }

        function applyTreatment() {
            if (state.treatmentApplied) return;

            state.treatmentApplied = true;
            state.showOintment = true;
            
            // Actualizar wizard - paso 2 completado
            updateWizardStep(2);

            // Show treatment indicator
            const indicator = document.getElementById('treatment-indicator');
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 2000);

            // Update button
            const btn = document.getElementById('treatment-btn');
            btn.classList.add('applied');
            btn.innerHTML = '‚úì Tratamiento Aplicado';
            btn.disabled = true;

            // Apply treatment effects based on condition
            const condition = CONFIG.conditions[state.condition];
            
            switch(state.condition) {
                case 'hemophilia':
                case 'hemophiliaSevere':
                    // Factor VIII/IX replacement - enables fibrin formation
                    applyFactorReplacement();
                    break;
                    
                case 'vwd':
                    // Desmopresina or vWF concentrate - improves platelet adhesion
                    applyVWFReplacement();
                    break;
                    
                case 'thrombocytopenia':
                    // Platelet transfusion - increases platelet count
                    applyPlateletTransfusion();
                    break;
                    
                case 'thrombasthenia':
                    // Platelet transfusion - provides functional platelets
                    applyPlateletTransfusion();
                    break;
                    
                case 'anticoagulated':
                    // Vitamin K or PCC - reverses anticoagulation
                    reverseAnticoagulation();
                    break;
                    
                default:
                    // Generic treatment - improves all parameters
                    applyGenericTreatment();
            }

            // For all conditions, try to form additional fibrin connections
            setTimeout(() => {
                state.stuckPlatelets.forEach(plateletData => {
                    tryFormFibrin(plateletData);
                });
            }, 200);

            updateUI();
        }
        
        function applyFactorReplacement() {
            // Factor VIII/IX replacement for hemophilia
            // Gradually improves fibrin formation rate
            const condition = CONFIG.conditions[state.condition];
            const targetRate = 0.9;
            
            // Form fibrin on all existing stuck platelets immediately
            state.stuckPlatelets.forEach(plateletData => {
                if (!plateletData.hasFibrin) {
                    tryFormFibrin(plateletData);
                }
            });
            
            // Make all fibrin stable and glowing
            state.fibrinConstraints.forEach(f => {
                f.glowing = true;
                f.stability = 1.0;
                f.decayRate = 0;
                f.visualColor = '#39FF14';
                f.opacity = 1.0;
            });
        }
        
        function applyVWFReplacement() {
            // Desmopresina or vWF concentrate for von Willebrand disease
            // Improves platelet adhesion and function
            const condition = CONFIG.conditions[state.condition];
            
            // Update visual effects - platelets return to normal color
            state.stuckPlatelets.forEach(platelet => {
                platelet.body.render.fillStyle = '#808080';
            });
            
            // Improve adhesion for new platelets (handled by canStick check)
        }
        
        function applyPlateletTransfusion() {
            // Platelet transfusion for thrombocytopenia/thrombasthenia
            // Temporarily increases platelet spawn rate
            const condition = CONFIG.conditions[state.condition];
            const originalRatio = condition.plateletRatio;
            
            // Increase platelet ratio temporarily
            condition.plateletRatio = Math.min(0.35, originalRatio * 3);
            
            // Spawn extra platelets immediately
            for (let i = 0; i < 25; i++) {
                if (state.allBodies.length < CONFIG.particles.maxCount) {
                    createParticle('platelet');
                }
            }
            
            // Restore after 10 seconds
            setTimeout(() => {
                condition.plateletRatio = originalRatio;
            }, 10000);
        }
        
        function reverseAnticoagulation() {
            // Vitamin K or Prothrombin Complex Concentrate (PCC)
            // Improves fibrin stability and formation
            state.fibrinConstraints.forEach(f => {
                f.stability = Math.min(1.0, f.stability + 0.3);
                f.decayRate = 0;
                f.visualColor = '#00E676';
                f.opacity = 1.0;
            });
        }
        
        function applyGenericTreatment() {
            // Generic treatment - improves all parameters slightly
            state.fibrinConstraints.forEach(f => {
                f.stability = Math.min(1.0, f.stability + 0.2);
                f.glowing = true;
            });
        }

        function setCondition(condition) {
            state.condition = condition;
            state.treatmentApplied = false;
            state.simulationRunning = false;
            
            // Update UI
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.condition === condition);
            });

            // Reset simulation
            initSimulation();
            
            // Actualizar wizard - paso 1 completado
            updateWizardStep(1);
            
            // Habilitar bot√≥n de inicio
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.textContent = '‚ñ∂ Iniciar Simulaci√≥n';
                startBtn.classList.remove('paused');
            }
        }
        
        function toggleSimulation() {
            if (!state.simulationRunning) {
                // Iniciar simulaci√≥n
                state.simulationRunning = true;
                // No usar Runner.run() - usamos nuestro propio loop con timestep fijo
                lastPhysicsTime = 0;
                accumulatedTime = 0;
                const startBtn = document.getElementById('start-btn');
                startBtn.textContent = '‚è∏ Pausar Simulaci√≥n';
                startBtn.classList.add('paused');
                updateWizardStep(3);
            } else {
                // Pausar simulaci√≥n
                state.simulationRunning = false;
                // No usar Runner.stop() - usamos nuestro propio loop
                const startBtn = document.getElementById('start-btn');
                startBtn.textContent = '‚ñ∂ Reanudar Simulaci√≥n';
                startBtn.classList.remove('paused');
            }
        }
        
        function updateWizardStep(step) {
            state.currentStep = step;
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');
                if (stepNum < step) {
                    el.classList.add('completed');
                } else if (stepNum === step) {
                    el.classList.add('active');
                }
            });
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initSimulation();

            // Condition buttons
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setCondition(btn.dataset.condition);
                });
            });

            // Treatment button
            document.getElementById('treatment-btn').addEventListener('click', applyTreatment);
            
            // Start button
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.addEventListener('click', toggleSimulation);
                startBtn.disabled = true; // Deshabilitado hasta seleccionar condici√≥n
            }

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', () => {
                state.simulationRunning = false;
                // No necesitamos detener el runner porque usamos nuestro propio loop
                initSimulation();
                updateWizardStep(1);
                if (startBtn) {
                    startBtn.textContent = '‚ñ∂ Iniciar Simulaci√≥n';
                    startBtn.classList.remove('paused');
                    startBtn.disabled = false;
                }
            });
            
            // Inicializar wizard
            updateWizardStep(1);
            
            // Asegurar que la condici√≥n normal est√© activa por defecto
            const normalBtn = document.querySelector('[data-condition="normal"]');
            if (normalBtn) {
                normalBtn.classList.add('active');
            }
            
            // Habilitar bot√≥n de inicio ya que la condici√≥n normal est√° activa por defecto
            if (startBtn) {
                startBtn.disabled = false;
            }
        });
    </script>
</body>
</html>

